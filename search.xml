<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[30分钟理解GraphQL核心概念]]></title>
    <url>%2F2018%2F04%2F02%2F30-minutes-graphql%2F</url>
    <content type="text"><![CDATA[写在前面 在上一篇文章RPC vs REST vs GraphQL中，对于这三者的优缺点进行了比较宏观的对比，而且我们也会发现，一般比较简单的项目其实并不需要GraphQL，但是我们仍然需要对新的技术有一定的了解和掌握，在新技术普及时才不会措手不及。 这篇文章主要介绍一些我接触GraphQL的这段时间，觉得需要了解的比较核心的概念，比较适合一下人群： 听说过GraphQL的读者，想深入了解一下 想系统地学习GraphQL的读者 正在调研GraphQL技术的读者 这些概念并不局限于服务端或者是客户端，如果你熟悉这些概念，在接触任意使用GraphQL作为技术背景的库或者框架时，都可以通过文档很快的上手。 如果你已经GraphQL应用于了实际项目中，那么这篇文章可能不适合你，因为其中并没有包含一些实践中的总结和经验，关于实践的东西我会在之后再单另写一篇文章总结。 什么是GraphQL 介绍GraphQL是什么的文章网上一搜一大把，篇幅有长有短，但是从最核心上讲，它是一种查询语言，再进一步说，是一种API查询语言。 这里可能有的人就会说，什么？API还能查？API不是用来调用的吗？是的，这正是GraphQL的强大之处，引用官方文档的一句话： ask what exactly you want. 我们在使用REST接口时，接口返回的数据格式、数据类型都是后端预先定义好的，如果返回的数据格式并不是调用者所期望的，作为前端的我们可以通过以下两种方式来解决问题： 和后端沟通，改接口（更改数据源） 自己做一些适配工作（处理数据源） 一般如果是个人项目，改后端接口这种事情可以随意搞，但是如果是公司项目，改后端接口往往是一件比较敏感的事情，尤其是对于三端（web、andriod、ios）公用同一套后端接口的情况。大部分情况下，均是按第二种方式来解决问题的。 因此如果接口的返回值，可以通过某种手段，从静态变为动态，即调用者来声明接口返回什么数据，很大程度上可以进一步解耦前后端的关联。 在GraphQL中，我们通过预先定义一张Schema和声明一些Type来达到上面提及的效果，我们需要知道： 对于数据模型的抽象是通过Type来描述的 对于接口获取数据的逻辑是通过Schema来描述的 这么说可能比较抽象，我们一个一个来说明。 Type 对于数据模型的抽象是通过Type来描述的，每一个Type有若干Field组成，每个Field又分别指向某个Type。 GraphQL的Type简单可以分为两种，一种叫做Scalar Type(标量类型)，另一种叫做Object Type(对象类型)。 Scalar Type GraphQL中的内建的标量包含，String、Int、Float、Boolean、Enum，对于熟悉编程语言的人来说，这些都应该很好理解。 值得注意的是，GraphQL中可以通过Scalar声明一个新的标量，比如： prisma（一个使用GraphQL来抽象数据库操作的库）中，还有DateTime和ID这两个标量分别代表日期格式和主键 在使用GraphQL实现文件上传接口时，需要声明一个Upload标量来代表要上传的文件 总之，我们只需要记住，标量是GraphQL类型系统中最小的颗粒，关于它在GraphQL解析查询结果时，我们还会再提及它。 Object Type 仅有标量是不够的抽象一些复杂的数据模型的，这时候我们需要使用对象类型，举个例子(先忽略语法，仅从字面上看)： 12345type Article &#123; id: ID text: String isPublished: Boolean&#125; 上面的代码，就声明了一个Article类型，它有3个Field，分别是ID类型的id，String类型的text和Boolean类型的isPublished。 对于对象类型的Field的声明，我们一般使用标量，但是我们也可以使用另外一个对象类型，比如如果我们再声明一个新的User类型，如下： 1234type User &#123; id: ID name: String&#125; 这时我们就可以稍微的更改一下关于Article类型的声明代码，如下： 123456type Article &#123; id: ID text: String isPublished: Boolean author: User&#125; Article新增的author的Field是User类型, 代表这篇文章的作者。 总之，我们通过对象模型来构建GraphQL中关于一个数据模型的形状，同时还可以声明各个模型之间的内在关联（一对多、一对一或多对多）。 Type Modifier 关于类型，还有一个较重要的概念，即类型修饰符，当前的类型修饰符有两种，分别是List和Required，它们的语法分别为[Type]和Type!, 同时这两者可以互相组合，比如[Type]!或者[Type!]或者[Type!]!(请仔细看这里!的位置)，它们的含义分别为： 列表本身为必填项，但其内部元素可以为空 列表本身可以为空，但是其内部元素为必填 列表本身和内部元素均为必填 我们进一步来更改上面的例子，假如我们又声明了一个新的Comment类型，如下： 12345type Comment &#123; id: ID! desc: String, author: User!&#125; 你会发现这里的ID有一个!，它代表这个Field是必填的，再来更新Article对象，如下： 1234567type Article &#123; id: ID! text: String isPublished: Boolean author: User! comments: [Comment!]&#125; 我们这里的作出的更改如下： id字段改为必填 author字段改为必填 新增了comments字段，它的类型是一个元素为Comment类型的List类型 最终的Article类型，就是GraphQL中关于文章这个数据模型，一个比较简单的类型声明。 Schema 现在我们开始介绍Schema，我们之前简单描述了它的作用，即它是用来描述对于接口获取数据逻辑的，但这样描述仍然是有些抽象的，我们其实不妨把它当做REST架构中每个独立资源的uri来理解它，只不过在GraphQL中，我们用Query来描述资源的获取方式。因此，我们可以将Schema理解为多个Query组成的一张表。 这里又涉及一个新的概念Query，GraphQL中使用Query来抽象数据的查询逻辑，当前标准下，有三种查询类型，分别是query（查询）、mutation（更改）和subscription（订阅）。 Note: 为了方便区分，Query特指GraphQL中的查询（包含三种类型），query指GraphQL中的查询类型（仅指查询类型） Query 上面所提及的3中基本查询类型是作为Root Query（根查询）存在的，对于传统的CRUD项目，我们只需要前两种类型就足够了，第三种是针对当前日趋流行的real-time应用提出的。 我们按照字面意思来理解它们就好，如下： query（查询）：当获取数据时，应当选取Query类型 mutation（更改）：当尝试修改数据时，应当使用mutation类型 subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型 仍然以一个例子来说明。 首先，我们分别以REST和GraphQL的角度，以Article为数据模型，编写一系列CRUD的接口，如下： Rest 接口 12345GET /api/v1/articles/GET /api/v1/article/:id/POST /api/v1/article/DELETE /api/v1/article/:id/PATCH /api/v1/article/:id/ GraphQL Query 12345678910Query &#123; articles(): [Article!]! article(id: Int): Article!&#125;mutation &#123; createArticle(): Article! updateArticle(id: Int): Article! deleteArticle(id: Int): Article!&#125; 对比我们较熟悉的REST的接口我们可以发现，GraphQL中是按根查询的类型来划分Query职能的，同时还会明确的声明每个Query所返回的数据类型，这里的关于类型的语法和上一章节中是一样的。需要注意的是，我们所声明的任何Query都必须是Root Query的子集，这和GraphQL内部的运行机制有关。 例子中我们仅仅声明了Query类型和Mutation类型，如果我们的应用中对于评论列表有real-time的需求的话，在REST中，我们可能会直接通过长连接或者通过提供一些带验证的获取长连接url的接口，比如： 1POST /api/v1/messages/ 之后长连接会将新的数据推送给我们，在GraphQL中，我们则会以更加声明式的方式进行声明，如下 12345678subscription &#123; updatedArticle() &#123; mutation node &#123; comments: [Comment!]! &#125; &#125;&#125; 我们不必纠结于这里的语法，因为这篇文章的目的不是让你在30分钟内学会GraphQL的语法，而是理解的它的一些核心概念，比如这里，我们就声明了一个订阅Query，这个Query会在有新的Article被创建或者更新时，推送新的数据对象。当然，在实际运行中，其内部实现仍然是建立于长连接之上的，但是我们能够以更加声明式的方式来进行声明它。 Resolver 如果我们仅仅在Schema中声明了若干Query，那么我们只进行了一半的工作，因为我们并没有提供相关Query所返回数据的逻辑。为了能够使GraphQL正常工作，我们还需要再了解一个核心概念，Resolver（解析函数）。 GraphQL中，我们会有这样一个约定，Query和与之对应的Resolver是同名的，这样在GraphQL才能把它们对应起来，举个例子，比如关于articles(): [Article!]!这个Query, 它的Resolver的名字必然叫做articles。 在介绍Resolver之前，是时候从整体上了解下GraphQL的内部工作机制了，假设现在我们要对使用我们已经声明的articles的Query，我们可能会写以下查询语句（同样暂时忽略语法）： 12345678910111213Query &#123; articles &#123; id author &#123; name &#125; comments &#123; id desc author &#125; &#125;&#125; GraphQL在解析这段查询语句时会按如下步骤（简略版）： 首先进行第一层解析，当前Query的Root Query类型是query，同时需要它的名字是articles 之后会尝试使用articles的Resolver获取解析数据，第一层解析完毕 之后对第一层解析的返回值，进行第二层解析，当前articles还包含三个子Query，分别是id、author和comments id在Author类型中为标量类型，解析结束 author在Author类型中为对象类型User，尝试使用User的Resolver获取数据，当前field解析完毕 之后对第二层解析的返回值，进行第三层解析，当前author还包含一个Query, name，由于它是标量类型，解析结束 comments同上... 我们可以发现，GraphQL大体的解析流程就是遇到一个Query之后，尝试使用它的Resolver取值，之后再对返回值进行解析，这个过程是递归的，直到所解析Field的类型是Scalar Type（标量类型）为止。解析的整个过程我们可以把它想象成一个很长的Resolver Chain（解析链）。 这里对于GraphQL的解析过程只是很简单的概括，其内部运行机制远比这个复杂，当然这些对于使用者是黑盒的，我们只需要大概了解它的过程即可。 Resolver本身的声明在各个语言中是不一样的，因为它代表数据获取的具体逻辑。它的函数签名(以js为例子)如下： 123function(parent, args, ctx, info) &#123; ...&#125; 其中的参数的意义如下： parent: 当前上一个Resolver的返回值 args: 传入某个Query中的函数（比如上面例子中article(id: Int)中的id） ctx: 在Resolver解析链中不断传递的中间变量（类似中间件架构中的context） info: 当前Query的AST对象 值得注意的是，Resolver内部实现对于GraphQL完全是黑盒状态。这意味着Resolver如何返回数据、返回什么样的数据、从哪返回数据，完全取决于Resolver本身，基于这一点，在实际中，很多人往往把GraphQL作为一个中间层来使用，数据的获取通过Resolver来封装，内部数据获取的实现可能基于RPC、REST、WS、SQL等多种不同的方式。同时，基于这一点，当你在对一些未使用GraphQL的系统进行迁移时（比如REST），可以很好的进行增量式迁移。 总结 大概就这么多，首先感谢你耐心的读到这里，虽然题目是30分钟熟悉GraphQL核心概念，但是可能已经超时了，不过我相信你对GraphQL中的核心概念已经比较熟悉了。但是它本身所涉及的东西远远比这个丰富，同时它还处于飞速的发展中。 最后我尝试根据这段时间的学习GraphQL的经验，提供一些进一步学习和了解GraphQL的方向和建议，仅供参考： 想进一步了解GraphQL本身 我建议再仔细去官网，读一下官方文档，如果有兴趣的话，看看GraphQL的spec也是极好的。这篇文章虽然介绍了核心概念，但是其他一些概念没有涉及，比如Union、Interface、Fragment等等，这些概念均是基于核心概念之上的，在了解核心概念后，应当会很容易理解。 偏向服务端 偏向服务端方向的话，除了需要进一步了解GraphQL在某个语言的具体生态外，还需要了解一些关于缓存、上传文件等特定方向的东西。如果是想做系统迁移，还需要对特定的框架做一些调研，比如graphene-django。 如果是想使用GraphQL本身做系统开发，这里推荐了解一个叫做prisma的框架，它本身是在GraphQL的基础上构建的，并且与一些GraphQL的生态框架兼容性也较好，在各大编程语言也均有适配，它本身可以当做一个ORM来使用，也可以当做一个与数据库交互的中间层来使用。 偏向客户端 偏向客户端方向的话，需要进一步了解关于graphql-client的相关知识，我这段时间了解的是apollo，一个开源的grapql-client框架，并且与各个主流前端技术栈如Angular、React等均有适配版本，使用感觉良好。 同时，还需要了解一些额外的查询概念，比如分页查询中涉及的Connection、Edge等。 大概就这么多，如有错误，还望指正。]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>graphql</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RPC vs REST vs GraphQL]]></title>
    <url>%2F2018%2F03%2F24%2Frpc-reset-graphql%2F</url>
    <content type="text"><![CDATA[写在前面 最近2周的时间由于工作不忙，一直在看有关GraphQL的东西，前后端均有涉及，由于我之前做过后端开发，当时实现的接口的大体是符合RPC风格的接口。后来转做了前端开发，从实现接口者变成了调用接口者，接触最多的当属REST风格的接口。因此在这段学习GraphQL的过程中，并且也尝试使用它以全栈的角度做了一个小项目，在这个过程中，一直在思考它对比前两者在API设计的整体架构体系中的各个指标上，孰优孰劣。 其实在使用和学习的过程中，有很多文章都对比过它们的异同，但是大部分文章并没有从一个相对客观的角度来对比，更多是为了突显一个的优点而刻意指出另外一个的缺点。这让我想到一句话，脱离业务情景谈技术就是耍流氓。 昨天订阅的GraphQL Weekly中推送的一个视频正好是讲关于它们这三者的，于是就点进去看了看，发现质量还是不错的，于是就想整理出来，分享给大家。 原视频地址(油管地址，自备梯子)：这里 如果没有梯子的话直接看我整理的东西也可以，我觉的应该都覆盖到视频中所讲的重点内容了。 当然，这些内容如果分开来讲，每一块内容所涉及的东西都够写一本书了，这里仅仅是简单归纳和整理，从宏观的角度来对比它们的异同，从而能够在日后面临技术选型时，有一个更佳明确的决策方向。 RPC 先简单介绍下RPC，它是Remote Procedure Call(远程过程调用)的简称。一般基于RPC协议所设计的接口，是基于网络采用客户端/服务端的模式完成调用接口的。 优点 简单并且易于理解（面向开发者） 轻量级的数据载体 高性能 缺点 对于系统本身耦合性高 因为RPC本身很简单、轻量，因此很容易造成 function explosion 关于RPC的优点其实很好理解，就是因为它性能高同时又很简单，但是我认为这是对于接口提供者来讲的（因为它的高耦合性）。 但是如果从接口调用者的角度来看，高耦合性就变成了缺点，因为高耦合意味着调用者必须要足够了解系统本身的实现才能够完成调用，比如： 调用者需要知道所调用接口的函数名、参数格式、参数顺序、参数名称等等 如果接口提供者(server)要对接口做出一些改变，很容易对接口调用者(client)造成breaking change（违背开闭原则) 一般RPC所暴露接口仅仅会暴露函数的名称和参数等信息，对于函数之间的调用关系无法提供，这意味着调用者必须足够了解系统，从能够知道如何正确的调用这些接口，但是对于接口调用者往往不需要了解过多系统内部实现细节 关于上面的第二点，为了减少breaking change，我之前实现接口的时候一般都会引入版本的概念，就是在暴露接口的方法名中加入版本号，一开始效果确实不错，但是随后就不知不觉的形成了function explosion，和视频中主讲人所举例的例子差不多，贴一下视频中的截图感受一波： REST 当前REST风格的API架构方式已经成了主流解决方案了，相比较RPC，它的主要不同之处在于，它是对于资源(Resource)的模型化而非步骤(Procedure)。 优点 对于系统本身耦合性低，调用者不再需要了解接口内部处理和实现细节 重复使用了一些 http 协议中的已定义好的部分状态动词，增强语义表现力 API可以随着时间而不断演进 缺点 缺少约束，缺少简单、统一的规范 有时候 payload 会变的冗余(overload)，有时候调用api会比较繁琐(chattiness) 有时候需要发送多条请求已获取数据，在网络带宽较低的场景，往往会造成不好的影响 REST的优点基本解决了RPC中存在的问题，就是解耦，从而使得前后端分离成为可能。接口提供者在修改接口时，不容易造成breaking-change，接口调用者在调用接口时，往往面向数据模型编程，而省去了了解接口本身的时间成本。 但是，我认为REST当前最大的问题在于虽然它利用http的动词约束了接口的暴露方式，同时增强了语义，但是却没有约束接口如何返回数据的最佳实践，总让人感觉只要是返回json格式的接口都可以称作REST。 我在实际工作中，经常会遇到第二条缺点所指出的问题，就是接口返回的数据冗余度很高，但是却缺少我真正需要的数据，因此不得已只能调用其他接口或者直接和后端商议修改接口，并且这种问题会在web端和移动端共用一套接口中被放大。 当前比较好的解决方案就是规范化返回数据的格式，比如json-schema或者自己制定的规范。 GraphQL GraphQL是近来比较热门的一个技术话题，相比REST和RPC，它汲取了两者的优点，即不面向资源，也不面向过程，而是面向数据查询(ask for exactly what you want)。 同时GraphQL本身需要使用强类型的Schema来对数据模型进行定义，因此相比REST它的约束性更强。 优点 网络开销低，可以在单一请求中获取REST中使用多条请求获取的资源 强类型Schema（约束意味着可以根据规范形成文档、IDE、错误提示等生态工具） 特别适合图状数据结构的业务场景（比如好友、流程、组织架构等系统） 缺点 本身的语法相比较REST和RPC均复杂一些 实现方面需要配套 Caching 以解决性能瓶颈 对于 API 的版本控制当前没有完善解决方案（社区的建议是不要使API版本化） 仍然是新鲜事物，很多技术细节仍然处于待验证状态 鉴于GraphQL这两个星期我也仅仅是做了一些简单地使用和了解，仅仅说一下感受。 首先值得肯定的是，在某些程度上确实解决了REST的缺点所带来的问题，同时配套社区建议的各种工具和库，相比使用REST风格，全栈开发体验上升一个台阶。 但是这个看起来很好的东西为什么没有火起来呢？我觉的最主要的原因是因为GraphQL所带来的好处，大部分是对于接口调用者而言的，但是实现这部分的工作却需要接口提供者来完成。 同时GraphQL的最佳实践场景应当是类似像Facebook这样的网站，业务逻辑模型是图状数据结构，比如社交。如果在一些业务逻辑模型相对简单的场景，使用GraphQL确实不如使用REST来得简单明了、直截了当。 另外一方面是GraphQL的使用场景相当灵活，在我自己的调研项目中，我是把它当做一个类似ORM的框架来使用的，在别人的一些文章中，会把它当做一个中间层来做渐进式开发和系统升级。这应当算是另外一个优点。 到底用哪个 下面根据要设计的API类型给予一些技术选型建议。 如果是Management API，这类API的特点如下： 关注于对象与资源 会有多种不同的客户端 需要良好的可发现性和文档 这种情景使用REST + JSON API可能会更好。 如果是Command or Action API，这类API的特点如下： 面向动作或者指令 仅需要简单的交互 这种情况使用RPC就足够了。 如果是Internal Micro Services API，这类API的特点如下： 消息密集型 对系统性能有较高要求 这种情景仍然建议使用RPC。 如果是Micro Services API，这类API的特点如下： 消息密集型 期望系统开销较低 这种情景使用RPC或者REST均可。 如果是Data or Mobile API，这类API的特点是： 数据类型是具有图状的特点 希望对于高延迟场景可以有更好的优化 这种场景无疑GraphQL是最好的选择。 写在最后 提供一张表格来总览它们之间在不同指标下的表现： 耦合性 约束性 复杂度 缓存 可发现性 版本控制 RPC(Function) high medium low custom bad hard REST(Resource) low low low http good easy GraphQL(Query) medium high medium custom good ??? 最后引用人月神话中的观点no silver bullet，在技术选型时需要具体情况具体分析，不过鉴于GraphQL的灵活性，把它与RPC和REST配置使用，也是不错的选择。]]></content>
      <categories>
        <category>原创</category>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级 Angular 组件模式 (4)]]></title>
    <url>%2F2018%2F02%2F17%2Faacp-4%2F</url>
    <content type="text"><![CDATA[04 Avoid Namespace Clashes with Directives 原文: Avoid Namespace Clashes with Directives 提示 在同一个html元素上绑定多个指令可能会造成命名冲突。 命名冲突不仅存在于指令的选择器之间，同时也会存在于指令的Inputs和Outputs属性，当这些属性名一样时，Angular并不会进行提示，它会按原本的逻辑正常工作。这种情况有时候是我们希望看到的，有些时候却不是。 目标 避免存在于绑定在相同元素上的多个指令上的命名冲突。 实现 因为toggle和withToggle指令都绑定于&lt;toggle&gt;元素，我们将通过为它们增加一个label属性来说明问题。 首先我们设置一个label属性，比如： 1&lt;toggle label=&quot;some label&quot;&gt; 这个label属性的值会同时绑定在每个指令上，如果想要为其中的某个指令单独绑定，只能通过使用prefix(前缀)来实现。 Angular官方提供的规范指南也警示了这一点，当你在使用prefix修饰指令的名称时，也需要注意使用prefix来修饰Input和Output属性的名称。 Note: 当使用Output属性重写原生DOM元素的事件和使用Input属性重写原生元素的属性时，请额外注意，没有任何方式可以获知别人在他们编写的应用或者库中使用的命名，但是你可以很轻易的知道的具体命名的大体规则是什么，并且不要重写它们，除非你有意为之。 增加prefix的一种方式是在每个指令的label属性的装饰器内增加一个字符串参数，如下： 12345// In withToggle.directive.ts@Input(&apos;withToggleLabel&apos;) label;// In toggle.directive.ts@Input(&apos;toggleLabel&apos;) label; 但是这种解决方案的前提时，你至少能够更改存在命名冲突中的一个或多个指令的源码。如果在两个第三方库中存在命名冲突，这种情况是最棘手的，我们不在这里讨论它们。 成果 https://stackblitz.com/edit/adv-ng-patterns-04-namespace-clashes 译者注 原文中关于最后一段提出的关于在多个第三方库中存在的命名冲突的场景，作者提供做出具体的解决方案，我在这里简单分享一下自己对于这种情况的解决方案： 通常这种情况比较少见，但是万一存在这种情况，我们可以通过创建一个新的wrapper指令来封装第三方指令，wrapper指令提供与第三方指令一样的接口属性，但是因为我们对于wrapper指令有绝对的控制权，我们可以提供统一的prefix来修饰这些接口属性，从而达到解决冲突的效果。]]></content>
      <categories>
        <category>翻译</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级 Angular 组件模式 (5)]]></title>
    <url>%2F2018%2F02%2F17%2Faacp-5%2F</url>
    <content type="text"><![CDATA[05 Handle Template Reference Variables with Directives 原文: Handle Template Reference Variables with Directives 在之前的例子中，已经出现多次使用template reference variable（模板引用变量）的场景，现在让我们来深入研究如何通过使用模板引用变量来关联某个具体指令。 目标 在视图模板内，获取一个指令的引用。 实现 模板引用变量是获取某个元素、组件或者指令引用的一种方式，这个引用可以在当前的视图模板中的任何地方使用。它们通常是以#baseToggle或者#myToggle=&quot;toggle&quot;的语法声明的。一旦声明，在视图模板的任何地方就可以使用它。 Note: 请注意作用域的问题，如果你使用&lt;ng-template&gt;或者是一个结构性指令，比如*ngIf或者*ngFor，它会在这个模板上创建一个新的作用域，之后在其内部声明的模板引用变量无法在该模板作用域以外使用。 模板引用变量的解析顺序通常为： 一个指令或者组件通过它自身的exportAs属性，比如#myToggle=&quot;toggle&quot; 声明于以自定义标签存在的组件，比如&lt;toggle-on #toggleOn&gt;&lt;/toggle-on&gt; 原生html元素，并且没有任何组件绑定与它，比如&lt;div #someDiv&gt;&lt;/div&gt; 之后我们来分别看3个例子。 指令与exportAs 指令可以在它的元数据中声明exportAs属性，这个属性表示它被这个模板引用变量所标识，如下： 123456// toggle.directive.ts@Directive(&#123; selector: &apos;[toggle]&apos;, exportAs: &apos;toggle&apos;,&#125;)export class ToggleDirective &#123; ... &#125; 之后我们可以在视图模板中直接使用toggle来获取指令的引用，如下： 123// app.component.html&lt;div toggle #myTemplateRefVar=&quot;toggle&quot;&gt;&lt;/div&gt;// myTemplateRefVar is the ToggleDirective 组件 对于每一个html元素，只会有一个组件与之对应。当一个组件绑定于一个元素时，那么声明的模板引用变量将会被解析为当前元素上所绑定的组件，比如： 123// app.component.html&lt;toggle-on #toggleOn&gt;&lt;/toggle-on&gt;// toggleOn is the ToggleOnComponent HTML元素 如果没有组件与元素绑定，模板引用变量会指向当前这个html元素。 123// app.component.html&lt;div #someDiv&gt;&lt;/div&gt;// someDiv is an HTMLDivElement 成果 Note: 在stackblitz中，我通过打印模板引用变量所指向的类的名字（constructor.name）来演示它所代表的引用。 https://stackblitz.com/edit/adv-ng-patterns-05-template-ref-variables 译者注 这篇文章作者关于模板引用变量，仅仅介绍了关于如何声明和在视图模板中如何使用，我在这里再补充一些，如何在组件或者指令类的内部使用。 在类内部获取模板引用变量所指向的引用是通过使用ViewChild装饰器完成的，比如上述文章中的第二个例子: 1234567891011121314@Component(&#123; selector: &apos;my-app&apos;, template: ` &lt;div #myDiv&gt;&lt;/div&gt; `,&#125;)export class AppComponent &#123; @ViewChild(&apos;myDiv&apos;) myDiv: ElementRef; ngAfterViewInit() &#123; console.log(this.myDiv); &#125;&#125; 这里的myDiv即指向当前模板引用变量所指向的html元素。 Note: 在类中获取模板引用变量所指向的引用时，请格外注意你期望获取的引用类型，在例子中，我们期望获取html元素，因此这里的引用类型是ElementRef，如果是指令或者组件，则分别要对应其类型的Type。]]></content>
      <categories>
        <category>翻译</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript原型链-review]]></title>
    <url>%2F2018%2F02%2F08%2Fjavascript%E5%8E%9F%E5%9E%8B%E9%93%BEreview%2F</url>
    <content type="text"><![CDATA[写在前面 虽然现在es8都已经在预发布阶段了，但是无论发布到es几，其本身的运作原理都是一样的。 首先祭上一张图, 这张图主要描述了以下的关系，如果觉的这里的说明过于复杂可以直接看最后一段。 简单说明 关于function(class)A和它的原型之间的关系 A.prototype.constructor与A等价 关于function(class)A的实例a与它的原型之间的关系 a.__proto__与A.prototype等价 在上面两个等价条件的基础上，就可以很容易得到 a.__proto__.prototype.constructor与A等价 这是一般的类和对象实例之间的原型继承关系。 在此基础上，对于Object和Function还有一些特殊的关系。 关于function(class)A和Function之间的关系 A.__proto__与Function.prototype等价 关于function(class)A的原型和Object之间的关系 A.prototype.__proto__与Object.prototype等价 关于Function的原型和Object之间的关系 Function.prototype.__proto__与Object.prototype等价 所以也可以很容易知道 A.__proto__.__proto__与Object.prototype等价 Object对象比较特殊，因为它是所有对象的根，所以约定它的原型所指向的原型对象为空 Object.prototype.__proto__与null等价 同时javascript中一切皆为对象，但Object本身是一个构造函数，因此它本身的原型对象指向Function.prototype Object.__proto__与Function.prototype 总结 所以无论是es5风格的继承还是es6风格的继承语法，原型链的形成是都是通过__proto__和prototype描述的，举个例子，这里使用es6, 即: 如果有: 12class B extends A &#123;&#125;const a = new B() 则有： a.__proto__ === B.prototype B.prototype.constructor.__proto__ === B.__proto__ B.__proto__ === A A.prototype.constructor.__proto === A.__proto__ A.__proto__ === Function.prototype Function.prototype.__proto__ === Object.prototype Object.prototype.__proto__ === null 其他的以此类推。]]></content>
      <categories>
        <category>原创</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Understanding SOLID Principles - Liskov Substitution Principle]]></title>
    <url>%2F2018%2F02%2F08%2FSOLID-l%2F</url>
    <content type="text"><![CDATA[Understanding SOLID Principles: Liskov Substitution Principle 这是理解SOLID原则，关于里氏替换原则为什么提倡我们面向抽象层编程而不是具体实现层，以及为什么这样可以使代码更具维护性和复用性。 什么是里氏替换原则 Objects should be replaceable with instances of their subtypes without altering the correctness of that program. 某个对象实例的子类实例应当可以在不影响程序正确性的基础上替换它们。 这句话的意思是说，当我们在传递一个父抽象的子类型时，你需要保证你不会修改任何关于这个父抽象的行为和状态语义。 如果你不遵循里氏替换原则，那么你可能会面临以下问题： 类继承会变得很混乱，因此奇怪的行为会发生 对于父类的单元测试对于子类是无效的，因此会降低代码的可测试性和验证程度 通常打破这条原则的情况发生在修改父类中在其他方法中使用的，与当前子类无关联的内部或者私有变量。这通常算得上是一种对于类本身的一次潜在攻击，而且这种攻击可能是你在不经意间自己发起的，而且不仅在子类中。 反面例子 让我们通过一个反面例子来演示这种修改行为和它所产生的后果。比如，我们有一个关于Store的抽象类和它的实现类BasicStore，这个类会储存一些消息在内存中，直到储存的个数超过每个上限。客户端代码的实现也很简单明了，它期望通过调用retrieveMessages就可以获取到所有储存的消息。 代码如下： 1234567891011121314151617181920212223242526interface Store &#123; store(message: string); retrieveMessages(): string[];&#125;const STORE_LIMIT = 5;class BasicStore implements Store &#123; protected stash: string[] = []; protected storeLimit: number = STORE_LIMIT; store(message: string) &#123; if (this.storeLimit === this.stash.length) &#123; this.makeMoreRoomForStore(); &#125; this.stash.push(message); &#125; retrieveMessages(): string[] &#123; return this.stash; &#125; makeMoreRoomForStore(): void &#123; this.storeLimit += 5; &#125;&#125; 之后通过继承BasicStore，我们又创建了一个新的RotatingStore实现类，如下： 12345class RotatingStore extends BasicStore &#123; makeMoreRoomForStore() &#123; this.stash = this.stash.slice(1); &#125;&#125; 注意RotatingStore中覆盖父类makeMoreRoomForStore方法的代码以及它是如何隐蔽地改变了父类BasicStore关于stash的状态语义的。它不仅修改了stash变量，还销毁了在程序进程中已储存的消息已为将来的消息提供额外的空间。 在使用RotatingStore的过程中，我们会遇到一些奇怪的现象，这正式由于RotatingStore本身产生的，如下： 1234567891011const st: Store = new RotatingStore()st.store(&quot;hello&quot;)st.store(&quot;world&quot;)st.store(&quot;how&quot;)st.store(&quot;are&quot;)st.store(&quot;you&quot;)st.store(&quot;today&quot;)st.store(&quot;sir?&quot;)st.retrieveMessages() // 一些消息丢失了 一些消息会无故消失，当前这个类的表现逻辑与所有消息均可以被取出的基本需求不一致。 如何实践里氏替换原则 为了避免这种奇怪现象的发生，里氏替换原则推荐我们通过在子类中调用父类的公有方法来获取一些内部状态变量，而不是直接使用它。这样我们就可以保证父类抽象中正确的状态语义，从而避免了副作用和非法的状态转变。 它也推荐我们应当尽可能的使基本抽象保持简单和最小化，因为对于子类来说，有助于提供父类的扩展性。如果一个父类是比较复杂的，那么子类在覆盖它的时候，在不影响父类状态语义的情况下进行扩展绝非易事。 对于内部系统做可行的后置条件检查也是一个不错的方式，这种检查通常会验证是否子类会搅乱一些关键代码的运行路径（译者注：也可以理解为状态语义），但是我本身对这个实践并没有太多的经验，所以无法给予具体的例子。 代码评论也可以一定程度上给予好的帮助。当你在开发一些你可能无意间做出一些对已有系统的破坏，但是你的同事可能会很容易地发现这些（当局者迷旁观者清）。软件设计保持一致性是一件十分重要的事情，因此应当尽早、尽可能多地查明那些对对象继承链作出潜在修改的代码。 最后，在单一职责原则中，我们曾提及，考虑使用组合模式来替换继承模式。 总结 正如你所看到的，在开发软件时，我们往往需要额外花一些努力和精力来使它变得更好。将这些原则牢记于心，理解它们所存在的意义以及它们想要解决的问题，这样会使你的工作变得更加容易、更具条理性，但是同时记住，这并不是一件容易的事，相反，你应当在构思软件时，花相当多的事件思考如何更好地实践这些原则。 试着让自己设计的软件系统具备可适应性，这种适应性可以抵御各种不利的变化以及潜在的错误，这样自然而然地可以使你少加班和早回家（译者注：看来加班是每个程序员都要面临的问题啊） 译者注 这是SOLID原则中我所接触和了解较少的一个原则，但经过仔细思考后，发现其实我们还是经常会在实际工作中运用它的。 在许多面向相对的编程语言中，关于对象的继承机制中，都会提供一些内部变量和状态的修饰符，比如public（公有）、protect（保护）和private（私有），关于这些修饰符本身的异同这里不再赘述，我想说的是，这些修饰符存在必然有它存在的意义，一定要在实际工作中，使用它们。之前做java后端时，经常在公司的项目的历史代码中发现，很少使用protect和private对类内部的方法和变量做约束，可见当时的编写者并没有对类本身的职能有一个清晰的认识，又或者是随着时间一步步迭代出来的结果。 那么问题来了，一些静态语言有这些修饰符，但是像javascript这种鸭子类型语言怎么办呢？其实没有必要担心，最早开始学前端的时候，这个问题我就问过自己无数次，javascript虽然没有这些修饰符，但是我们可以通过别的方式来达到类似的效果，或者使用typescript。 除了在编程语言层面，在前端实际工作中，你可能会听到一个叫作immutable的概念，这个概念我认为也是里氏替换原则的一直延伸。因为当前的前端框架一般提倡的理念均是f(state) =&gt; view，即数据状态代表视图，而数据状态本身由于javascript动态语言的特性，很容易会在不经意间被修改，一旦存在这种修改，视图中便会产生一些意想不到的问题，因此immutable和函数式的概念才会在前段时间火起来。 写在最后 经过这五篇文章，我们来分别总结一下这五条基本原则以及它们带来的好处： 单一职责原则：提高代码实现层的内聚度，降低实现单元彼此之间的耦合度 开闭原则：提高代码实现层的可扩展性，提高面临改变的可适应性，降低修改代码的冗余度 里氏替换原则：提高代码抽象层的可维护性，提高实现层代码与抽象层的一致性 接口隔离原则：提高代码抽象层的内聚度，降低代码实现层与抽象层的耦合度，降低代码实现层的冗余度 依赖倒置原则：降低代码实现层由依赖关系产生的耦合度，提高代码实现层的可测试性 可以注意到我这里刻意使用了降低/提高 + 实现层/抽象层 + 特性/程度（耦合度、内聚度、扩展性、冗余度、可维护性，可测试性）这样的句式，之所以这么做是因为在软件工作中，我们理想中的软件应当具备的特点是, 高内聚、低耦合、可扩展、少冗余、可维护、易于测试，而这五个原则也按正确的方向，将我们的软件系统向我们理想中的标准推进。 为了便于对比，特别绘制了下面的表格，希望大家从真正意义上做到将这些原则牢记于心，并付诸于行。 原则 耦合度 内聚度 扩展性 冗余度 维护性 测试性 适应性 一致性 单一职责原则 - + o o + + o o 开闭原则 o o + - + o + o 里氏替换原则 - o o o + o o + 接口隔离原则 - + o - o o + o 依赖倒置原则 - o o - o + + o Note: +代表增加, -代表降低, o代表持平]]></content>
      <categories>
        <category>翻译</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>principle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Understanding SOLID Principles - Interface Segregation Principle]]></title>
    <url>%2F2018%2F02%2F08%2FSOLID-i%2F</url>
    <content type="text"><![CDATA[Understanding SOLID Principles: Interface Segregation Principle 这是理解SOLID原则，关于接口隔离原则如何帮助我们创建简单的抽象接口，并使客户端代与接口之间存在的更少的依赖关系。 接口隔离原则是什么 Clients should not be forced to depend on methods that they do not use. 客户端代码不应当被迫依赖于它们不需要的方法。 这个原则本身与单一职责原则关系十分紧密，它意味着当你在定义你的抽象层代码时，不应当在客户端代码在实现抽象逻辑时，暴露一些客户端代码不需要使用或者关心的方法。 进一步说明的话，就是当你有意地在抽象层中暴露的方法时，这意味着所有实现这些抽象逻辑的客户端代码都必须要实现所有的抽象方法，尽管这些方法并不一定都对客户端代码有意义。 将你的接口的保持精简和小颗粒度，并且不要在它们中间增加无用的抽象方法，当你在对新的抽象接口进行命名时，你就会拥有更好的选择，因为你已有了若干小颗粒的命名类型。这样做的意义在于当你在需要提供一个更加大颗粒度的抽象接口时，你可以拥有足够的灵活性来将已有的小颗粒度接口进行组合。 如何实践接口隔离原则 这个例子是关于一个ATM用户界面的抽象接口，这个接口会处理诸如存款请求、取款请求等逻辑，从这个例子中我们会了解到，我们如何对这个接口进行隔离，使其进一步划分为多个独立的、更加具体的若干接口。 首先我们应当有一个工具函数库接口，这个接口会描述我们想要暴露的关于byte操作逻辑的方法，让我们创建这样一个接口，如下 12345type ByteUtils interface &#123; Read(b []byte) (n int, err error) // Read into buffer Write(b []byte)(n int, err error) // Write into buffer Trim(b []byte, exclusions string)[]byte // Trim buffer by removing bytes from the exclusion chars&#125; 它可以正常工作一段时间，但是很快我们就会发现以下两个问题： 它的命名ByteUtils太过于通用，如果我们仅通过命名本身，基本无法获取任何具体的信息 当使用它时，会有一些古怪的感觉，因为当你根据不同的优化场景来按不同逻辑实现trim方法时，你所实现的read和write几乎没什么差别，但是你却需要重复地实现它们，同时在某些不需要读或者写的场景，仍然需要实现它们。 所以它虽然能够正常工作，但是却不够好。 我们可以通过创建三个更精简、更具体的接口来替代原先通用的接口： 123456789type Reader interface &#123; Read(b []byte) (n int, err error) &#125;type Writer interface &#123; Write(b []byte)(n int, err error) &#125;type Trimmer interface &#123; Trim(b []byte, exclusions string)[]byte &#125; 这种颗粒度比较细的接口也可以称为角色接口，因为它们更易于重构和改变，甚至对于已经定义好的角色和目的也可以很容易的进行重新部署和定义。 在这三个基础上，我们可以通过组合它们来获取一个更有关联性的接口列表，比如： 12345678type ReadWriter interface &#123; Reader Writer &#125;type TrimReader interface &#123; Trimmer Reader&#125; 这意味客户端代码拥有了可以根据它们各自的需求来组合抽象层接口的灵活性，这样就会避免在实现抽象接口时不必要的麻烦（比如必须要实现某些无用的方法），比如上面的TrimReader的实现并未包含多余的Write方法的声明。 总结 正如你所看到的，通用的接口往往会无意识的将自己和类的实现耦合在了一起，所以你应当尽量的避免这种情况的发生。在设计接口时，你应当时刻提醒自己，我是否需要使用所有在接口中声明的方法呢？如果不是的话，将接口细分为更多个更精简、更具体的接口。 正如甘地曾经说过： 你的行动决定你的习惯，你的习惯决定你的价值，你的价值会决定你的命运。 如果在架构中，你每次都会经过仔细思考，会按照好的模式来进行设计，它将会成为一种习惯，自然慢慢会转变为你的价值或者原则，最终则会成为你的命运，比如成为了一个始终给予完善解决方案的软件架构师。 我的观点是，始终通过挑战自己来变的更好，在某些时刻，你可能会遇到问题，但是往往你可能已经拥有了答案。 Happy coding! 译者注 对于接口隔离原则的理解，我一直觉的它本身其实是单一职责原则的一个扩展，但是它们之间也有细微的不同： 单一职责原则往往面向实现层，比如具体的类或者某个方法 接口隔离原则往往面向抽象层，比如一些抽象类或者抽象方法 所以将两个原则结合起来看的话，可以很容器得到当时提出这两个原则的人的意图，那就是一定要时刻保持简单。 在实际工作中，我深知保持简单是一件十分困难的事情，因为工程师本身的使命便是解决问题，而问题往往充满了未知性，而未知性往往代表着改变，这还没有考虑到在项目实施过程中，产品经理天马行空的设计思路，客户们五花八门的需求等等。在这些外界条件下，我们的代码往往会变得复杂无比，充满了各种反模式和冗余代码，最终会使自己陷入无尽的bug修复和维护工作中，怎么还会有时间进行自我提升呢？ 所以，为了能够按时下班，为了能够及早回家，为了能够让我们的拥有更多的时间来提升自己和陪伴家人，在软件设计之初，尽可能地针对将来所面临的改变，在设计层面降低软件抽象模块间的耦合程度，在项目实施时，提高每个具体实现模块内部的内聚程度，同时使它们保持简单，这样便是一个好的开始。]]></content>
      <categories>
        <category>翻译</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>principle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Understanding SOLID Principles - Open Closed Principle]]></title>
    <url>%2F2018%2F02%2F04%2FSOLID-o%2F</url>
    <content type="text"><![CDATA[Understanding SOLID Principles: Open Closed Principle 这是理解SOLID原则，介绍什么是开闭原则以及它为什么能够在对已有的软件系统或者模块提供新功能时，避免不必要的更改（重复劳动）。 开闭原则是什么 Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification. 软件实体（类、模块、函数等）都应当对扩展具有开放性，但是对于修改具有封闭性。 首先，我们假设在代码中，我们已经有了若干抽象层代码，比如类、模块、高阶函数，它们都仅做一件事（还记得单一职责原则吗？），并且都做的十分出色，所以我们想让它们始终处于简洁、高内聚并且好用的状态。 但是另一方面，我们还是会面临改变，这些改变包含范围（译者注：应当是指抽象模块的职责范围）的改变，新功能的增加请求还有新的业务逻辑需求。 所以对于上面我们所拥有的抽象层代码，在长期想让它处于一成不变的状态是不现实的，你不可避免的会针对以上的需要作出改变的需求，增加更多的功能，增加更多的逻辑和交互。在上一篇文章，我们知道，改变会使系统复杂，复杂会促使模块间的耦合性上升，所以我们迫切地需要寻找一种方法能够使我们的抽象模块不仅可以扩大它的职责范围，同时还能够保持当前良好的状态（简洁、高内聚、好用）。 这便是开闭原则存在的意义，它能够帮助我们完美地实现这一切。 如何实践开闭原则 当你需要对已有代码作出一些修改时，请切记以下两点： 保持函数、类、模块当前它们本身的状态，或者是近似于它们一般情况下的状态（即不可修改性） 使用组合的方式（避免使用继承方式）来扩展现有的类，函数或模块，以使它们可能以不同的名称来暴露新的特性或功能 这里关于继承，我们特意增加了一个注释，在这种情况下使用继承可能会使模块之间耦合在一起，同时这种耦合是可避免的，我们通常在一些预先有着良好定义的结构上使用继承。（译者注：这里应该是指，对于我们预先设计好的功能，推荐使用继承方式，对于后续新增的变更需求，推荐使用组合方式） 举个例子（译者注：我对这里的例子做了一些修改，原文中并没有详细的说明） 1234567891011121314151617interface IRunner &#123; run: () =&gt; void;&#125;class Runner implements IRunner &#123; run(): void &#123; console.log(&quot;9.78s&quot;); &#125;&#125;interface IJumper &#123; jump: () =&gt; void;&#125;class Jumper implements IJumper &#123; jump(): void &#123; console.log(&quot;8.95,&quot;); &#125;&#125; 例子中，我们首先声明了一个IRunner接口，之后又声明了IJumper，并分别实现了它们，并且实现类的职能都是单一的。 假如现在我们需要提供一个既会跑又会跳的对象，如果我们使用继承的方式，可以这么写 123class RunnerAndJumper extends Runner &#123; jump: () =&gt; void&#125; 或者 123class RunnerAndJumper extends Jumper &#123; run: () =&gt; void&#125; 但是使用继承的方式会使这个RunnerAndJumper与Runner（或者Jumper）耦合在一起（耦合在一起的原因是因为它的职责不再单一），我们再来用组合的方式试试看，如下： 1234567891011121314class RunnerAndJumper &#123; private runnerClass: IRunner; private jumperClass: IJumper; constructor(runner: IRunner, jumper: IJumper) &#123; this.runnerClass = new runner(); this.jumperClass = new jumper(); &#125; run() &#123; this.runnerClass.run(); &#125; jump() &#123; this.jumperClass.jump(); &#125;&#125; 我们在RunnerAndJumper的构造函数中声明两个依赖，一个是IRunner类型，一个是IJumper类型。 最终的代码其实和依赖倒置原则中的例子很像，而且你会发现，RunnerAndJumper类本身并没有与任何别的类耦合在一起，它的职能同样是单一的，它是对一个即会跑又会跳的实体的抽象，并且这里我们还可以使用DI（依赖注入）技术进一步的优化我们的代码，降低它的耦合度。 反思 开闭原则所带来最有用的好处就是，当我们在实现我们的抽象层代码时，我们就可以对未来可能需要作出改变的地方拥有一个比较完整的设想，这样当我们真正面临改变时，我们所对原有代码的修改，更贴近于改变本身，而不是一味的修改我们已有的抽象代码。 在这种情况下，由于我们节省了不必要的劳动和时间，我们就可以将更多的精力投入到关于更加长远的事宜计划上面，而且可以针对这些事宜需要作出的改变，提前和团队沟通，最终给予一套更加健壮、更符合系统模块本身的解决方案。 在整个软件开发周期中（比如一个敏捷开发周期），你对于整个周期中的事情了解的越透彻、越多，则越好。身为一个工程师，在一个开发冲刺中，为了在冲刺截止日期结束前，实现一个高效的、可靠的系统，你不会期望作出太多的改变，因此往往你可能会“偷工减料”。 从另一个角度来讲，我们也应当致力于在每一次面临需求变更的情况下，不需要一而再，再而三的更改我们已有的代码。所有新的功能都应当通过增加一个新的组合类或方法实现，或者通过复用已有的代码来实现。 插件与中间件 充分贯彻开闭原则的另一个例子，便是插件与中间件架构，我们可以从三个角度来简单分析这种架构是如何运作的： 内核或者容器：往往是核心功能的实现的前提，一般会成为整个系统最核心的部分 插件：在实现容器的基础上，往往一些核心功能都是以内置的插件实现的，并且，通过实现一套通用的网关类接口，我们可以使插件具有可插拔性，这样在需要新增特性和功能时，只需要实现新的插件并添加到容器即可，比如支持插件扩展功能的浏览器Chrome。 中间件：中间件我们可以通过一个例子来说明，比如我们拥有一个请求 - 响应周期，我们可以通过中间件，在周期中添加中间业务逻辑，以便为应用程序提供额外的服务或横切关注点，比如Redux、express还有很多框架都支持这样的功能。 总结 希望这篇文章能够帮助你学会如何应用开闭原则并且从中收益。设计一个具有可组合性的系统，同时提供具有良好定义的扩展接口，是一种非常有用的技术，这种技术最关键的地方在于，它使我们的系统能够在保持强健的同时，提供新功能、新特性，但是却不会影响它当前的状态。 译者注 开闭原则是面向对象编程中最重要的原则之一，有多重要呢？这么说吧，很多的设计原则和设计模式所希望达成的最终状态，往往符合开闭原则，因此需要原则也都作为实现开闭原则的一种手段，在原文的例子中，我们可以很明显的体会到，在实现开闭原则所提倡的理念的过程中，我们不经意地使用之前两篇文章中涉及的原则，比如： 保持对象的单一性（单一职责） 实现依赖于抽象（依赖倒置原则） 我之前一直是做后端相关工作的，所以对于开闭原则接触较早，这两年转行做了前端，随着nodejs的发展，框架技术日新月异，但是其中脱颖而出的优秀框架往往是充分贯彻了开闭原则，比如express、webpack还有状态管理容器redux，它们均是开闭原则的最佳实践。 另外一方面，在这两年的工作也感受到，适当的使用函数式编程的思想，往往是贯彻开闭原则一个比较好的开始，因为函数式的编程中的核心概念之一便是compose（组合）。以函数式描述业务往往是原子级的指令，之后在需要描述更复杂的业务时，我们复用并组合之前已经存在的指令以达到目的，这恰恰符合开闭原则所提倡的可组合性。 最后在分享一些前端中，经常需要使用开闭原则的最佳业务场景， UI组件的表单组件：对于表单本身以容器来实现，表单项以插件来实现，这样对于表单项如何渲染、如何加载、如何布局等功能，均会封闭与表单容器中，而对于表单项如何校验、如何取值、如何格式化等功能，则会开放与表单项容器中。 API服务：一般我们可能会在项目中提供自定义修改请求头部的工具方法，并在需要的时候调用。但这其实是一种比较笨的方法，如果可能的话，建议使用拦截器来完成这项任务，不仅会提供代码的可读性，同时还会使发接口的业务层代码保持封闭。 事件驱动模型：对于一些复杂的事件驱动模型，比如拖拽，往往使用开闭原则会达到意想不到的效果。最近有一个比较火的拖拽库draggable，提供的拖拽体验相比其他同类型的库简直不是一个级别。我前段时间去读它的源码，发现它之所以强大，是因为在它内部，针对多种拖拽事件，封装了独立的事件发射器（其内部称作Sensor），之后根据这些发射器指定了一套独立的抽象事件驱动模型，在这个模型基础上，针对不同的业务场景提供不同的插件，比如： 原生拖拽(Draggable) 拖拽排序(Sortable) 拖拽放置(Droppable) 拖拽交换(Swappable) 还有若干提高用户体验的其他插件，这一切均是以开闭原则而实现的。]]></content>
      <categories>
        <category>翻译</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>principle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Understanding SOLID Principles - Single Responsibility]]></title>
    <url>%2F2018%2F02%2F02%2FSOLID-s%2F</url>
    <content type="text"><![CDATA[Understanding SOLID Principles: Single Responsibility 这是理解SOLID原则中，关于单一职责原则如何帮助我们编写低耦合和高内聚的第二篇文章。 单一职责原则是什么 之前的第一篇文章阐述了**依赖倒置原则（DIP）**能够使我们编写的代码变得低耦合，同时具有很好的可测试性，接下来我们来简单了解下单一职责原则的基本概念： Every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. 每一个模块或者类所对应的职责，应对应系统若干功能中的某个单一部分，同时关于该职责的封装都应当通过这个类来完成。 往简单来讲： A class or module should have one, and only one, reason to be changed. 一个类或者模块应当用于单一的，并且唯一的缘由被更改。 如果仅仅通过这两句话去理解, 一个类或者模块如果如果越简单（具有单一职责），那么这个类或者模块就越容易被更改是有一些困难的。为了便于我们理解整个概念，我们将分别从三个不同的角度来分析这句话，这三个角度是： Single: 单一 Responsibility: 职责 Change: 改变 什么是单一 Only one; not one of several. 唯一的，而不是多个中的某个。 Synonyms: one, one only, sole, lone, solitary, isolated, by itself. 同义词：一，仅有的一个，唯一，独个，独自存在的，孤立的，仅自己。 单一意味着某些工作是独立的。比如，在类中，类方法仅完成某家独立的事情，而不是两件，如下： 123456789101112131415161718class UserComponent &#123; // 这是第一件事情，获取用户详情数据 getUserInfo(id) &#123; this.api.getUserInfo(id).then(saveToState) &#125; // 这是第二件事情，渲染视图的逻辑 render() &#123; const &#123; userInfo &#125; = this.state; return &lt;div&gt; &lt;ul&gt; &lt;li&gt;Name: &#123; userInfo.name &#125;&lt;/li&gt; &lt;li&gt;Surname: &#123; userInfo.surname &#125;&lt;/li&gt; &lt;li&gt;Email: &#123; userInfo.email &#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &#125;&#125; 看了上面的代码，你可能很快就会联想到，这些代码基本存在于所有的React组件中。 确实，对于一些小型的项目或者演示型项目，这样编写代码不会产生太大的问题。但是如果在大型或者复杂度很高的项目中，仍然按照这样的风格，则是一件比较糟糕的事情，因为一个组件往往做了它本不应当做的事情（承担了过多的职责）。 这样会带来什么坏处呢？比如对于以上的api服务，在将来的某天你做出了一些修改，增加了一些额外的逻辑，那么为了使代码能够正常工作，你至少需要修改项目中的两个地方以适应这个修改，一处修改是在API服务中，而另一处则在你的组件中。如果进一步思考的，我们会发现，修改次数与在项目直接使用API服务的次数成正比，如果项目足够复杂，足够大，一处简单的逻辑修改，就需要做出一次贯穿整个系统的适配工作。 那么我们如果避免这种情况的发生呢？很简单，我们仅仅需要将关于用户详情数据的逻辑提升到调用层，在上面的例子中，我们应当使用React.component.prop来接受用户详情数据。这样，UserComponent组件的工作不再与如何获取用户详情数据的逻辑耦合，从而变得单一。 对于鉴别什么是单一，什么不是单一，有很多不同的方式。一般来说，只需要牢记，让你的代码尽可能的少的去了解它已经做的工作。（译者注：我理解意思应当是，应当尽可能的让已有的类或者方法变得简单、轻量，不需要所有事情都亲自为之） 总之，不要让你的对象成为上帝对象。 A God Object aka an Object that knows everything and does everything. 上帝对象，一个知道一切事情，完成一切事情的对象。 In object-oriented programming, a God object is an object that knows too much or does too much. The God object is an example of an anti-pattern. 在面向对象编程中，上帝对象指一个了解太情或者做太多事情的对象。上帝对象是反模式的一个典型。 什么是职责 职责指软件系统中，每一个指派给特定方法、类、包和模块所完成的工作或者动作。 Too much responsibility leads to coupling. 太多的职责导致耦合。 耦合性代表一个系统中某个部分对系统中另一个部分的了解程度。举个例子，如果一段客户端代码在调用class A的过程中，必须要先了解有关class B的细节，那么我们说A和B耦合在了一起。通常来说，这是一件糟糕的事情。因为它会使针对系统本身的变更复杂化，同时会在长期越来越糟。 为了使一个系统到达适当的耦合度，我们需要在以下三个方面做出调整 组件的内聚性 如何测量每个组件的预期任务 组件如何专注于任务本身 低内聚性的组件在完成任务时，和它们本身的职责关联并不紧密。比如，我们现在有一个User类，这个类中我们保存了一些基本信息： 123456class User &#123; public age; public name; public slug; public email;&#125; 对于属性本身，如果对于每个属性声明一些getter或者setter方法是没什么问题的。但是如果我们加一些别的方法，比如： 12345678910class User &#123; public age; public name; public slug; public email; // 我们为什么要有以下这些方法？ checkAge(); validateEmail(); slugifyName();&#125; 对于checkAge、validateEmail、slugifyName的职责，与Userclass本身关系并不紧密，因此就会这些方法就会使User的内聚性变低。 仔细思考的话，这些方法的职责和校验和格式化用户信息的关系更紧密，因此，它们应当从User中被抽离出来，放入到另一个独立的UserFieldValidation类中，比如： 123456789101112class User &#123; public age; public name; public slug; public email;&#125;class UserFieldValidation &#123; checkAge(); validateEmail(); slugifyName();&#125; 什么是变更 变更指对于已存在代码的修改或者改变。 那么问题来了，什么原因迫使我们需要对源码进行变更？从众多过期的软件系统的历史数据的研究来看，大体有三方面原因促使我们需要作出变更： 增加新功能 修复缺陷或者bug 重构代码以适配将来作出的变更 做为一个程序员，我们天天不都在做这三件事情吗？让我们来用一个例子完整的看一下什么是变更，比方说我们完成了一个组件，现在这个组件性能非常好，而且可读性也非常好，也许是你整个职业生涯中写的最好的一个组件了，所以我们给它一个炫酷的名字叫作SuperDuper（译者注：这个名字的意思是超级大骗子） 12345class SuperDuper &#123; makeThingsFastAndEasy() &#123; // Super readable and efficient code &#125;&#125; 之后过了一段时间，在某一天，你的经理要求你增加一个新功能，比如说去调用别的class中的每个函数，从而可以使当前这个组件完成更多的工作。你决定将这个类以参数的形式传入构造方法，并在你的方法调用它。 这个需求很简单，只需要增加一行调用的代码即可，然后你做了以下变更(增加新功能)： 123456789class SuperDuper &#123; constructor(notDuper: NotSoDuper) &#123; this.notDuper = notDuper &#125; makeThingsFastAndEasy() &#123; // Super readable and efficient code this.notDuper.invokeSomeMethod() &#125;&#125; 好了，之后你针对你做的变更代码运行了单元测试，然后你突然发现这条简单的代码使100多条的测试用例失败了。具体原因是因为在调用notDuper方法之前，你需要针对一些额外的业务逻辑增加条件判断来决定是否调用它。 于是你针对这个问题又进行了一次变更(修复缺陷或者bug)，或许还会针对一些别的边界条件进行一些额外的修复和改动： 1234567891011121314class SuperDuper &#123; constructor(notDuper: NotSoDuper) &#123; this.notDuper = notDuper &#125; makeThingsFastAndEasy() &#123; // Super readable and efficient code if (someCondition) &#123; this.notDuper.invokeSomeMethod() &#125; else &#123; this.callInternalMethod() &#125; &#125;&#125; 又过了一段时间，因为这个SuperDuper毕竟是你职业生涯完成的最棒的类，但是当前调用noDuper的方法实在是有点不够逼格，于是你决定引入事件驱动的理念来达到不在SuperDuper内部直接调用noDuper方法的目的。 这次实际是对已经代码的一次重构工作，你引入了事件驱动模型，并对已有的代码做出了变更(重构代码以适配将来作出的变更): 12345678class SuperDuper &#123; makeThingsFastAndEasy() &#123; // Super readable and efficient code ... dispatcher.send(actionForTheNotDuper(payload)) // Send a signal &#125;&#125; 现在再来看我们的SuperDuper类，已经和最原始的样子完全不一样了，因为你必须针对新的需求、存在的缺陷和bug或者适配新的软件架构而做出变更。 因此为了便于我们做出变更，在代码的组织方式上，我们需要用心，这样才会使我们在做出变更时更加容易。 如何才能使代码贴近这些原则 很简单，只需要牢记，使代码保持足够简单。 Gather together the things that change for the same reasons. Separate those things that change for different reasons. 将由于相同原因而做出改变的东西聚集在一起，将由于不同原因而做出改变的东西彼此分离。 孤立变化 对于所编写的做出变更的代码，你需要仔细的检查它们，无论是从整体检查，还是有逻辑的分而治之，都可以达到孤立变化的目的。你需要更多的了解你所编写的代码，比如，为什么这样写，代码到底做了什么等等，并且，对于一些特别长的方法和类要格外关注。 Big is bad, small is good… 大即是坏，小即是好。 追踪依赖 对于一个类，检查它的构造方法是否包含了太多的参数，因为每一个参数都作为这个类的依赖存在，同时这些参数也拥有自身的依赖。如果可能的话，使用DI机制来动态的注入它们。 Use Dependency Injection 使用依赖注入 追踪方法参数 对于一个方法，检查它是否包含了太多参数，一般来讲，一个方法的参数个数往往代表了其内部所实现的职能。 同时，在方法命名上也投入一精力，尽可能地使方法名保持简单，它将帮助你在重构代码时，更好的达到单一职责。长的函数名称往往意味着其内部有糟糕的味道。 Name things descriptively 描述性命名。 尽早重构 尽可能早的重构代码，当你看到一些代码可以以更简明的方式进行时，重构它。这将帮助你在项目进行的整个周期不断的整理代码以便于更好的重构。 Refactor to Design Patterns 按设计模式重构代码 善于做出改变 最后，在需要做出改变时，果断地去做。当然这些改变会使系统的耦合性更低，内聚性更高，而不是往相反的方向，这样你的代码会一直建立在这些原则之上。 Introduce change where it matters. Keep things simple but not simpler. 在重要的地方介绍改变。保持事情的简单性，但不是一味追求简单。 译者注 单一职责原则其实在我们日常工作中经常会接触到，比方说 我们经常会听到DIY（dont repeat yourself）原则，其本身就是单一职责的一个缩影，为了达到DIY，对于代码中的一些通用方法，我们经常会抽离到独立的utils目录甚至编写为独立的工具函数库, 比如lodash和ramda等等 OAOO, 指Once And Only Once, 原则本身的含义可以自行搜索，实际工作中我们对于相同只能模块的代码应当尽可能去在抽象层合并它们，提供抽象类，之后通过继承的方式来满足不同的需求 我们都会很熟悉单例模式这个模式，但在使用时一定要小心，因为本质上单例模式与单一职责原则相悖，在实践中一定要具体情况具体分析。同时也不要过度优化，就如同文章中最后一部分提及的，我们要保证一件事情的简单性，但不是一味地为了简单而简单。 前端的技术栈中，redux对于数据流层的架构思想，便充分体现了单一职责原则的重要性，action作为对具体行为的抽象, store用来描述应用的状态，reducer作为针对不同行为如何对store作出修改的抽象。 react中经常提及的木偶组件(dump component)其实和文章中第一部分的例子如出一辙 工厂模式和命令模式也一定程度体现了单一职责原则，前者对于作为生产者存在并不需要关心消费者如何消费对象实例，后者以命令的方式封装功能本身就是单一职责原则的体现。 我能够想到的就这么多，写的比较乱，抛砖引玉，如有错误，还望指正。]]></content>
      <categories>
        <category>翻译</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>principle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Understanding SOLID Principles - Dependency Inversion]]></title>
    <url>%2F2018%2F01%2F22%2FSOLID-d%2F</url>
    <content type="text"><![CDATA[Understanding SOLID Principles: Dependency Inversion 这是理解SOLID原则中，关于依赖倒置原则如何帮助我们编写低耦合和可测试代码的第一篇文章。 写在前头 当我们在读书，或者在和一些别的开发者聊天的时候，可能会谈及或者听到术语SOILD。在这些讨论中，一些人会提及它的重要性，以及一个理想中的系统，应当包含它所包含的5条原则的特性。 我们在每次的工作中，你可能没有那么多时间思考关于架构这个比较大的概念，或者在有限的时间内或督促下，你也没有办法实践一些好的设计理念。 但是，这些原则存在的意义不是让我们“跳过”它们。软件工程师应当将这些原则应用到他们的开发工作中。所以，在你每一次敲代码的时候，如何能够正确的将这些原则付诸于行，才是真正的问题所在。如果可以那样的话，你的代码会变得更优雅。 SOLID原则是由5个基本的原则构成的。这些概念会帮助创造更好（或者说更健壮）的软件架构。这些原则包含（SOLID是这5个原则的开头字母组成的缩略词）： S stands for SRP (Single responsibility principle)：单一职能原则 O stands for OCP (Open closed principle)：开闭原则 L stands for LSP (Liskov substitution principle)：里氏替换原则 I stand for ISP ( Interface segregation principle)：接口隔离原则 D stands for DIP ( Dependency inversion principle)：依赖倒置原则 起初这些原则是Robert C. Martin在1990年提出的，遵循这些原则可以帮助我们更好的构建，低耦合、高内聚的软件架构，同时能够真正的对现实中的业务逻辑进行恰到好处的封装。 不过这些原则并不会使一个差劲的程序员转变为一个优秀的程序员。这些法则取决于你如何应用它们，如果你是很随意的应用它们，那等同于你并没有使用它们一样。 关于原则和模式的知识能够帮助你决定在何时何地正确的使用它们。尽管这些原则仅仅是启示性的，它们是常见问题的常规解决方案。实践中，这些原则的正确性已经被证实了很多次，所以它们应当成为一种常识。 依赖倒置原则是什么 高级模块不应当依赖于低级模块。它们都应当依赖于抽象。 抽象不应当依赖于实现，实现应当依赖于抽象。 这两句话的意思是什么呢？ 一方面，你会抽象一些东西。在软件工程和计算机科学中，抽象是一种关于规划计算机系统中的复杂性的技术。它的工作原理一般是在一个人与系统交互的复杂环境中，隐藏当前级别下的更复杂的实现细节，同时它的范围很广，常常会覆盖多个子系统。这样，当我们在与一个以高级层面作为抽象的系统协作时，我们仅仅需要在意，我们能做什么，而不是我们如何做。 另外，你会针对你的抽象，有一写低级别的模块或者具体实现逻辑。这些东西与抽象是相反的。它们是被用于解决某些特定问题所编写的代码。它们的作用域仅仅在某个单元和子系统中。比如，建立一个与MySQL数据库的连接就是一个低级别的实现逻辑，因为它与某个特定的技术领域所绑定。 现在仔细读这两句话，我们能够得到什么暗示呢？ 依赖倒置原则存在的真正意义是指，我们需要将一些对象解耦，它们的耦合关系需要达到当一个对象依赖的对象作出改变时，对象本身不需要更改任何代码。 这样的架构可以实现一种松耦合的状态的系统，因为系统中所有的组件，彼此之间都了解很少或者不需要了解系统中其余组件的具体定义和实现细节。它同时实现了一种可测试和可替换的系统架构，因为在松耦合的系统中，任何组件都可以被提供相同服务的组件所替换。 但是相反的，依赖倒置也有一些缺点，就是你需要一个用于处理依赖倒置逻辑的容器，同时，你还需要配置它。容器通常需要具备能够在系统中注入服务，这些服务需要具备正确的作用域和参数，还应当被注入正确的执行上下文中。 以提供Websocket连接服务为例子 举个例子，我们可以在这个例子中学到更多关于依赖倒置的知识，我们将使用Inversify.js作为依赖倒置的容器，通过这个依赖倒置容器，我们可以看看如何针对提供Websocket连接服务的业务场景，提供服务。 比如，我们有一个web服务器提供WebSockets连接服务，同时客户端想要连接服务器，同时接受更新的通知。当前我们有若干种解决方案来提供一个WebSocket服务，比如说Socket.io、Socks或者使用浏览器提供的关于原生的WebSocket接口。每一套解决方案，都提供不同的接口和方法供我们调用，那么问题来了，我们是否可以在一个接口中，将所有的解决方案都抽象成一个提供WebSocket连接服务的提供者？这样，我们就可以根据我们的实际需求，使用不同的WebSocket服务提供者。 首先，我们来定义我们的接口： 1234567export interface WebSocketConfiguration &#123; uri: string; options?: Object;&#125;export interface SocketFactory &#123; createSocket(configuration: WebSocketConfiguration): any;&#125; 注意在接口中，我们没有提供任何的实现细节，因此它既是我们所拥有的抽象。 接下来，如果我们想要一个提供Socket.io服务工厂： 1234567import &#123;Manager&#125; from &apos;socket.io-client&apos;;class SocketIOFactory implements SocketFactory &#123; createSocket(configuration: WebSocketConfiguration): any &#123; return new Manager(configuration.uri, configuration.opts); &#125;&#125; 这里已经包含了一些具体的实现细节，因此它不再是抽象，因为它声明了一个从Socket.io库中导入的Manager对象，它是我们的具体实现细节。 我们可以通过实现SocketFactory接口，来增加若干工厂类，只要我们实现这个接口即可。 我们在提供一个关于客户端连接实例的抽象： 123456export interface SocketClient &#123; connect(configuration: WebSocketConfiguration): Promise&lt;any&gt;; close(): Promise&lt;any&gt;; emit(event: string, ...args: any[]): Promise&lt;any&gt;; on(event: string, fn: Function): Promise&lt;any&gt;;&#125; 然后再提供一些实现细节： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class WebSocketClient implements SocketClient &#123; private socketFactory: SocketFactory; private socket: any; public constructor(webSocketFactory: SocketFactory) &#123; this.socketFactory = webSocketFactory; &#125; public connect(config: WebSocketConfiguration): Promise&lt;any&gt; &#123; if (!this.socket) &#123; this.socket = this.socketFactory.createSocket(config); &#125; return new Promise&lt;any&gt;((resolve, reject) =&gt; &#123; this.socket.on(&apos;connect&apos;, () =&gt; resolve()); this.socket.on(&apos;connect_error&apos;, (error: Error) =&gt; reject(error)); &#125;); &#125; public emit(event: string, ...args: any[]): Promise&lt;any&gt; &#123; return new Promise&lt;string | Object&gt;((resolve, reject) =&gt; &#123; if (!this.socket) &#123; return reject(&apos;No socket connection.&apos;); &#125; return this.socket.emit(event, args, (response: any) =&gt; &#123; if (response.error) &#123; return reject(response.error); &#125; return resolve(); &#125;); &#125;); &#125; public on(event: string, fn: Function): Promise&lt;any&gt; &#123; return new Promise&lt;any&gt;((resolve, reject) =&gt; &#123; if (!this.socket) &#123; return reject(&apos;No socket connection.&apos;); &#125; this.socket.on(event, fn); resolve(); &#125;); &#125; public close(): Promise&lt;any&gt; &#123; return new Promise&lt;any&gt;((resolve) =&gt; &#123; this.socket.close(() =&gt; &#123; this.socket = null; resolve(); &#125;); &#125;); &#125;&#125; 值得注意的是，这里我们在构造函数中，传入了一个类型是SocketFactory的参数，这是为了满足关于依赖倒置原则的第一条规则。对于第二条规则，我们需要一种方式来提供这个不需要了解内部实现细节的、可替换的、易于配置的参数。 这也是为什么我们要使用Inversify这个库的原因，我们来加入一些额外的代码和注解（装饰器）： 12345678910111213141516import &#123;injectable&#125; from &apos;inversify&apos;;const webSocketFactoryType: symbol = Symbol(&apos;WebSocketFactory&apos;);const webSocketClientType: symbol = Symbol(&apos;WebSocketClient&apos;);let TYPES: any = &#123; WebSocketFactory: webSocketFactoryType, WebSocketClient: webSocketClientType&#125;;@injectable()class SocketIOFactory implements SocketFactory &#123;...&#125;...@injectable()class WebSocketClient implements SocketClient &#123;public constructor(@inject(TYPES.WebSocketFactory) webSocketFactory: SocketFactory) &#123; this.socketFactory = webSocketFactory;&#125; 这些注释（装饰器）仅仅会在代码运行时，在如何提供这些组件实例时，提供一些元数据，接下来我们仅仅需要创建一个依赖倒置容器，并将所有的对象按正确的类型绑定起来，如下： 12345678import &#123;Container&#125; from &apos;inversify&apos;;import &apos;reflect-metadata&apos;;import &#123;TYPES, SocketClient, SocketFactory, SocketIOFactory, WebSocketClient&#125; from &apos;@web/app&apos;;const provider = new Container(&#123;defaultScope: &apos;Singleton&apos;&#125;);// Bindingsprovider.bind&lt;SocketClient&gt;(TYPES.WebSocketClient).to(WebSocketClient);provider.bind&lt;SocketFactory&gt;(TYPES.WebSocketFactory).to(SocketIOFactory);export default provider; 让我们来看看我们如何使用我们提供连接服务的客户端实例： 1var socketClient = provider.get&lt;SocketClient&gt;(TYPES.WebSocketClient); 当然，使用Inversify可以提供一些更简单易用的绑定，可以通过浏览它的网站来了解。 译者注 一般说到依赖倒置原则，往往第一个想到的术语即是依赖注入，这种在各个技术栈都有应用，之后又会马上想到spring、ng等前后端框架。 我们确实是通过使用这些框架熟知这个概念的，但是如果你仔细想想的话，是否还有其他的一些场景也使用了类似的概念呢？ 比如： 一些使用插件和中间件的框架，如express、redux js中this的动态绑定 js中的回调函数 也许有的人会不同意我的观点，会说依赖注入一般都是面向类和接口来讲的，这确实有一定的道理，但是我认为没有必要局限在一种固定的模式中去理解依赖倒置，毕竟它是一种思想，一种模式，在js中，所有的东西都是动态的，函数是一等公民，是对象，那么把这些与依赖倒置原则联系起来，完全也讲的通。我们真正关心的是核心问题是如何解耦，把更多的注意力投入的真正的业务逻辑中去。]]></content>
      <categories>
        <category>翻译</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>principle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尝鲜 workerize 源码]]></title>
    <url>%2F2018%2F01%2F16%2Fworkerize%2F</url>
    <content type="text"><![CDATA[写在前面 最近正好在看web worker相关的东西，今天无意中就看到了github一周最热项目的推送中，有这么一个项目workerize，repo里的文档的描述如下： Moves a module into a Web Worker, automatically reflecting exported functions as asynchronous proxies. 例子 关于README很简单，包含一个类似hello world的例子就没其他什么了。但是从例子本身可以看出这个库要解决的问题，是想通过模块化的方式编写运行在web worker中的脚本，因为通常情况下，web worker每加载一个脚本文件是需要通过一个符合同源策略的URL的，这样会对服务端发送一个额外的请求。同时对于web worker本身加载的js文件的执行环境，与主线程是隔离的（这也是它在进行复杂运算时不会阻塞主线程的原因），与主线程的通讯靠postMessageapi和onmessage回调事件来通讯，这样我们在编写一些通信代码时，需要同时在两个不同的环境中分别编写发送消息和接受消息的逻辑，比较繁琐，同时这些代码也不能以模块化的形式存在。 如果存在一种方式，我们可以以模块化的方式来编写代码，注入web worker，之后还能通过类似Promsie机制来处理等异步，那便是极好的。 先来看看例子： 12345678910111213141516171819202122232425262728import workerize from &apos;workerize&apos;let worker1 = workerize(` export function add(a, b) &#123; let start = Date.now(); while (Date.now()-start &lt; 500); return a + b; &#125; export default function minus(a, b)&#123; let start = Date.now(); while (Date.now()-start &lt; 500); return a - b &#125;`)let worker2 = workerize(function (m) &#123; m.add = function (a, b) &#123; let start = Date.now() while (Date.now() - start &lt; 500); return a + b &#125;&#125;);(async () =&gt; &#123; console.log(&apos;1 + 2 = &apos;, await worker1.add(1, 2)) console.log(&apos;3 + 9 = &apos;, await worker2.call(&apos;add&apos;, [3, 9]))&#125;)() worker1和worker2是两种不同的使用方式，一种是以字符串的形式声明模块，一种以函数的形式声明模块。但是无论哪种，最后的结果都是一样的，我们可以通过worker实例显示的调用我们想要调用的方法，每个方法的调用结果均是一个Promise，因此它还可以完美的适配async/await语法。 源码 那么问题来了，这种模块的加载机制和调用方式是怎样实现的呢？我在运行demo代码的时候心中也默默想到，我去，看了好几天的web worker原来还能这么玩，所以一定要研究研究它的源码和它的实现原理。 打开源代码才发现其实并没有多少代码，官文文档也通过一句话强调了这一点： Just 900 bytes of gzipped ES3 所以对其中主要的两点进行简单说明： 如何实现按内容模块化加载脚本而不是通过URL 如何通过Promise来代理主线程与worker线程的通讯过程 使用Blob动态生成加载脚本资源 12345let blob = new Blob([code], &#123; type: &apos;application/javascript&apos; &#125;), url = URL.createObjectURL(blob), worker = new Worker(url) 这其实不是什么新鲜的东西，就是将代码的内容转化为Blob对象，之后再通过URL.createObjectURL将Blob对象转化为URL的形式，之后再用worker加载它，仅此而已。但是这里的问题是，这个code是哪里从哪里来的呢？ 将加载代码模块化 在加载代码之前，还有重要的一步，就是需要将加载的代码转变为模块，模板本身只对外暴露统一的接口，这样不论对于主线程还是worker线程，就有了统一的约束条件。源码中作者把上一步中的code转化为了类似commonjs的形式，主要涉及的代码有: 1234let exportsObjName = `__EXPORTS_$&#123;Math.random().toString().substring(2)&#125;__` if (typeof code === &apos;function&apos;) code = `($&#123;toCode(code)&#125;)($&#123;exportsObjName&#125;)` code = toCjs(code, exportsObjName, exports) code += `\n($&#123;toCode(setup)&#125;)(self, $&#123;exportsObjName&#125;, &#123;&#125;)` 和toCjs方法 12345678910111213function toCjs (code, exportsObjName, exports) &#123; exportsObjName = exportsObjName || &apos;exports&apos; exports = exports || &#123;&#125; code = code.replace(/^(\s*)export\s+default\s+/m, (s, before) =&gt; &#123; exports.default = true return `$&#123;before&#125;$&#123;exportsObjName&#125;.default = ` &#125;) code = code.replace(/^(\s*)export\s+(function|const|let|var)(\s+)([a-zA-Z$_][a-zA-Z0-9$_]*)/m, (s, before, type, ws, name) =&gt; &#123; exports[name] = true return `$&#123;before&#125;$&#123;exportsObjName&#125;.$&#123;name&#125; = $&#123;type&#125;$&#123;ws&#125;$&#123;name&#125;` &#125;) return `var $&#123;exportsObjName&#125; = &#123;&#125;;\n$&#123;code&#125;\n$&#123;exportsObjName&#125;;`&#125; 关于toCjs方法，如果你的正则知识比较扎实的话，可以发现，它做了一件事，就是将字符串类型的code中的所有导出方法的声明，使用commonjs的导出语法替换掉(中间会涉及一些具体的语法规则)，如下： 123// 如果 exportsObjName 使用默认值 exports, ...代表省略代码export function foo()&#123; ... &#125; =&gt; exports.foo = function foo()&#123; ... &#125;export default ... =&gt; exports.default = ... 如果code是函数类型，则首先使用toCode函数将code转化为string类型，之后再将它转化为IIFE的形式，如下 123456789// 如果 exportsObjName 使用默认值 exports, ...代表省略代码// 传入的code是如下形式：function( m )&#123; ... &#125;// 转化为(function( m )&#123; ...&#125;)(exports) 这里的exportsObjName代表模块的名字，默认值是exports(联想commonjs)，不过这里会在一开始就随机生成一个模块名字，生成代码如下： 1let exportsObjName = `__EXPORTS_$&#123;Math.random().toString().substring(2)&#125;__` 这样只有我们按照约定的语法来编写web worker加载的代码，它便会加载了一个符合同样约定的commonjs模块。 使用 Promise 来做异步代理 经过上面两步，web worker加载到了模块化的代码，但是worker线程与主线程进行通讯则是仍然需要通过postMessage方法和onmessage回调事件来进行，如果无法优雅地处理这里的异步逻辑，那么之前所做的工作其实意义并不大。 workerize针对这里的异步逻辑，设计了一个简单的rpc协议（文档中将这个称作a tiny, purpose-built RPC），先来看一下源码中的setup函数： 123456789101112131415161718192021222324252627282930313233343536function setup (ctx, rpcMethods, callbacks) &#123; ctx.addEventListener(&apos;message&apos;, (&#123; data &#125;) =&gt; &#123; // 只捕获满足条件的数据对象 if (data.type === &apos;RPC&apos;) &#123; // 获取数据对象中的 id 属性 let id = data.id if (id != null) &#123; // 如果数据对象中存在非空 method 属性，则证明是主线程发送的消息 if (data.method) &#123; // 获取所要调用的方法实例 let method = rpcMethods[data.method] if (method == null) &#123; // 如果所调用的方法实例不存在，则发送方法不存在的消息 ctx.postMessage(&#123; type: &apos;RPC&apos;, id, error: &apos;NO_SUCH_METHOD&apos; &#125;) &#125; else &#123; // 如果方法存在，则调用它，并将调用结果按不同的类型发送 Promise.resolve() .then(() =&gt; method.apply(null, data.params)) .then(result =&gt; &#123; ctx.postMessage(&#123; type: &apos;RPC&apos;, id, result &#125;) &#125;) .catch(error =&gt; &#123; ctx.postMessage(&#123; type: &apos;RPC&apos;, id, error &#125;) &#125;) &#125; // 如果 method 属性为空，则证明是 worker 线程发送的消息 &#125; else &#123; // 获取每个消息所对应的处于pending状态的Promise实例 let callback = callbacks[id] if (callback == null) throw Error(`Unknown callback $&#123;id&#125;`) delete callbacks[id] // 按消息的类型将Promise转化为resolve状态或reject状态。 if (data.error) callback.reject(Error(data.error)) else callback.resolve(data.result) &#125; &#125; &#125; &#125;) &#125; 根据注释我们可以知道，这里的setup函数包含了rpc协议的解析规则，因此主线程和worker线程对会调用该方法来注册安装这个rpc协议，具体的代码如下： 主线程: setup(worker, worker.rpcMethods, callbacks) worker线程: code += `\n(${toCode(setup)})(self, ${exportsObjName}, {}) 这两处代码都是在各自的作用域中，将rpc协议与当前加载的模块绑定起来，只不过主进程所传callbacks是有意义的，而worker则使用一个空对象代替。 注册调用逻辑 在拥有了rpc协议的基础上，只需要实现调用逻辑即可，代码如下： 12345worker.call = (method, params) =&gt; new Promise((resolve, reject) =&gt; &#123; let id = `rpc$&#123;++counter&#125;` callbacks[id] = &#123; method, resolve, reject &#125; worker.postMessage(&#123; type: &apos;RPC&apos;, id, method, params &#125;)&#125;) 这个call方法，每次会将一次方法的调用，转化为一个pending状态的Promise实例，并存在callbacks变量中，同时向worker线程发送一个格式为调用方法数据格式的消息。 12345for (let i in exports) &#123; if (exports.hasOwnProperty(i) &amp;&amp; !(i in worker)) &#123; worker[i] = (...args) =&gt; worker.call(i, args) &#125;&#125; 同时在初始化的过程中，会将主线程加载的模块中的每个方法，都绑定一个快捷方法，其方法名与模块中的函数声明保持一致，内部则使用worker.call来完成调用逻辑。 最后 关于这个库本身，还存在一些可以探讨的问题，比如： 是否支持依赖解析机制 如果引入外部依赖模块 针对消息是否需要按队列进行处理 关于前两点，似乎作者有一个相同的项目，叫做workerize-loader，可以解决，关于第三点，作者在代码中增加了todo，表示实现消息队列机制可能没有必要，因为当前的通讯基于postMessage，本身的结果已经是有序状态的了。 关于源码本身的分析大概就这样了，希望可以抛砖引玉，如有错误，还望指正。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>web worker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级 Angular 组件模式 (3a)]]></title>
    <url>%2F2018%2F01%2F10%2Faacp-3a%2F</url>
    <content type="text"><![CDATA[03-a Communicate Between Components Using Dependency Injection 原文: Communicate Between Components Using Dependency Injection 当前的&lt;toggle&gt;组件仍然存在其他的问题，比如： 我们无法在其中方式多个&lt;toggle-on&gt;或者是&lt;toggle-button&gt;在同一个&lt;toggle&gt;中 如果一个&lt;toggle-on&gt;作为另外一个自定义组件的内容的话，我们无法是使用@ContentChild装饰器获取它 目标 我们需要将这两个问题作为新的目标： 我们可以增加多个相同类型的子组件(&lt;toggle-on&gt;、&lt;toggle-off&gt;、&lt;toggle-button&gt;) 并且可以使这些子组件放置在任意的自定义容器的视图模板(views)中 实现 针对第一个问题，我们使用@ContentChildren装饰器（因为它获取所有的子组件引用），但是它无法解决第二个问题。 为了同时解决这两个问题，我们可以使用Angular提供的DI机制(dependency injection mechanism)。你可以将一个组件的祖先组件通过DI机制注入到子组件的构造方法中，这样你就可以通过祖先组件的引用来访问它们的方法和属性。 所以，&lt;toggle-on&gt;、&lt;toggle-off&gt;、&lt;toggle-button&gt;都可以通过DI机制来获得最相近的&lt;toggle&gt;组件的引用，从而共享它的开关状态。 Note: 这里也可以使用service来共享状态，也许还会更便捷，但是我们可以通过DI来达到目的，我们可以在之后的章节（第十二章）来阐述service相关的内容，这部分内容会与React Context Provider的内容对应。 成果 你可以在在线代码仓库看到，有两个&lt;toggle-off&gt;组件如我们预期的那样被渲染，并且有一个&lt;other-component&gt;组件，其中有&lt;toggle-off&gt;和&lt;toggle-on&gt;两个组件。 这些子组件都会监听同一个&lt;toggle&gt;组件的开关状态。 译者注 依赖注入是Angular中提供的很强大的功能，在angularjs中就表现出色并作为卖点。 如果仔细思考的话，我们可以发现，在这一版的实现中，对于&lt;toggle&gt;组件的引用获取方式，从命令式转变为了声明式，因为我们不再关心获取&lt;toggle&gt;引用的细节（比如具体使用@ContentChild还是@ContentChildren）。 同时，依赖注入机制是依附于组件本身存在的，并不依附于模板的层级关系，因此不会面临问题二的困扰。 对于木偶组件本身，往往作为消费者存在，这种情况下使用DI机制可能会达到更好的效果。]]></content>
      <categories>
        <category>翻译</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级 Angular 组件模式 (3b)]]></title>
    <url>%2F2018%2F01%2F10%2Faacp-3b%2F</url>
    <content type="text"><![CDATA[03-b Enhance Components with Directives 原文: Enhance Components with Directives Kent C. Dodds的第四篇文章中的一个重要元素在上一篇文章中没有涉及，使用withToggle高阶组件(HoC, react中的常用模式)可以将&lt;toggle-on&gt;、&lt;toggle-off&gt;、&lt;toggle-button&gt;组件中的公用逻辑分离出来。 虽然上一篇文章中上面提及的三个组件并没有太多的公用逻辑，可以万一它们有公用逻辑呢？如果我们想要提供更加声明式的功能，比如能够显式的声明它们使用的&lt;toggle&gt;组件实例而非最邻近的父实例。 同时，因为&lt;toggle&gt;组件的模板并不存在任何的变动，我们可以将它转化为一个指令，这样我们可以以更加灵活的方式来使用它。 目标 允许我们的&lt;toggle&gt;组件能够以tag的形式或者attribute的形式使用，如&lt;toggle&gt;或者&lt;div toggle&gt;&lt;/div&gt; 允许通过`withToggle1234## 实现### 1）将``&lt;toggle&gt;``作为一个指令将``&lt;toggle&gt;``组件改变为指令十分简单，因为它本身的模板仅仅是``&lt;ng-content&gt;&lt;/ng-content&gt;``，在组件渲染时，``&lt;ng-content&gt;``会被替换为我们当前组件标签内包含的内容，所以我们可以直接移除它，并使用``@Directive``装饰器来描述``&lt;toggle&gt;``组件，如下： @Directive({ exportAs: 'toggle', selector: 'toggle, [toggle]', }) export class ToggleDirective {} 123456你可能注意到了，指令的选择器允许``toggle``指令可以以**标签名**和**属性名**的形式来使用。对于``exportAs``关键字是必须要提供的，因为这是当我们需要在别的指令或者组件能够获取``toggle``指令引用的名字，会在这个系列文章的第5章详细删除``exportAs``（Handle Template Reference Variables with Directives）。### 2）``withToggle``指令在这个新的指令中，我们将会封装关于如何选取需要绑定某个``toggle``指令实例的逻辑。首先，我们的设想是这样的，每一个组件注入``withToggle``指令，而不是直接注入最邻近的父``toggle``指令。同时每个使用``withToggle``指令的组件通过使用``withToggle.toggle``来访问它所绑定的``toggle``指令的实例，如下： @Component({ selector: 'toggle-off', template: &lt;ng-content *ngIf=&quot;!withToggle.toggle?.on&quot;&gt;&lt;/ng-content&gt;, }) export class ToggleOffComponent { constructor(public withToggle: WithToggleDirective) {} } 12其次，``withToggle``指令将它自身与``toggle``指令的选择器绑定（就是两个指令的选择器是相同的），同时增加一个额外的选择器``[withToggle]``，如下： @Directive({ exportAs: 'withToggle', selector: 'toggle, [toggle], [withToggle]', }) export class WithToggleDirective //... 1234567现在``withToggle``指令为它的子组件们提供所绑定的``toggle``指令实例，无论这个实例是显示绑定的，还是默认的父``toggle``指令。关于其中实现的具体细节，可以参考文章最后的[附录部分](#附录)。## 成果我们的``app.component.html``现在可以通过三种不同的使用方式来展现内容。### 1）基本 &lt;div toggle #firstToggle=&quot;toggle&quot;&gt; ... &lt;toggle #secondToggle=&quot;toggle&quot;&gt; ... &lt;/toggle&gt; &lt;/div&gt; 12345注意``#firstToggle``和``#secondToggle``视图变量是如何使用``toggle``组件的，前者使用属性声明的方式，后者使用标签名声明方式，无论怎样，它们都按理想中那样运行。而且，``#secondToggle``是嵌套在``#firstToggle``中的，所以它的子组件使用的是它本身的开关状态，而非``#firstToggle``中的，这符合我们的预期。### 2）显式引用 &lt;p [withToggle]=&quot;firstToggle&quot;&gt; First: &lt;toggle-on&gt;On&lt;/toggle-on&gt; &lt;toggle-off&gt;Off&lt;/toggle-off&gt; &lt;toggle-button&gt;&lt;/toggle-button&gt; &lt;/p&gt; 123这里没有任何``toggle``指令是当前``p``标签的子组件的祖先，但是通过``withToggle``指令，我们可以让所有的子组件使用``#firstToggle``的``toggle``指令实例。### 3）自定义组件 &lt;div [withToggle]=&quot;firstToggle&quot;&gt; &lt;labelled-state toggleName=&quot;First&quot;&gt;&lt;/labelled-state&gt; &lt;labelled-button toggleName=&quot;First&quot;&gt;&lt;/labelled-button&gt; &lt;/div&gt; &lt;labelled-state toggleName=&quot;Second&quot; [withToggle]=&quot;secondToggle&quot;&gt; &lt;/labelled-state&gt; &lt;labelled-button toggleName=&quot;Second&quot; [withToggle]=&quot;secondToggle&quot;&gt; &lt;/labelled-button&gt; 1234``withToggle``指令甚至可以通过DI机制注入到内部的任何自定义组件中，如``&lt;labelled-state&gt;``组件和``&lt;labelled-button&gt;``都没有任何关于``withToggle``或者``toggle``的引用声明。它们无需关心这个开关状态的来源，它们仅仅需要知道的是，根据这个开关状态，如何与它们的子组件进行交互。## 附录``withToggle``的实现，是一个标准的指令声明方式，除了它的构造方法，如下： constructor( @Host() @Optional() private toggleDirective: ToggleDirective, ) {} 12345值得注意的有两点：* ``@Host()``：这个装饰器的作用是，可以限制从属于当前指令的DI注入器，仅注入**绑定到某个满足特定条件指定或者组件上的**``toggle``指令实例，而不是从它的祖先组件们中注入。（这里选择器为空，则为宿主对象）* ``@Optional()``：这个装饰器会告诉编译器，当注入器没有找到任何可注入的``toggle``指令时，不要抛出错误（如果我们手动的指定某个引用），这样在它无法被注入时，使它保持``undefined``即可。现在我们可以很容易的理解在``ngOnChanges``生命周期钩子函数中的代码的作用， this.toggle = this.withToggle || this.toggleDirective; * 如果我们的``@Input()``被指定，那么使用它的值 * 如果没有，则尝试去使用在当前宿主对象上注入的``toggle``指令实例 * 如果没有，则使用``undefined`` 当前的``this``指定``withToggle``本身，所以拥有它引用的子组件都可以访问它。 https://stackblitz.com/edit/adv-ng-patterns-03b-enhance-with-directives ## 译者注 在这一节中，主要进行了以下几方面的改进： * 简化``toggle``本身，因为它一直是作为一个容器组件使用的，所以完全可以以指令（可以理解为没有模板的组件）的形式存在 * 依赖注入（DI）的机制虽然很强大，但是受限于它的运作原理（关于具体的运作原理可以参考[官方文档](https://angular.cn/guide/dependency-injection)）。这里原作者使用一个额外的``withToggle``指令作为中间件，来作为``toggle``指令的托管容器。这部分理解起来可能需要先了解一下视图变量和``exportAs``的相关的知识 * 对于``toggle``指令实例的获取逻辑，采用平稳退化的策略，就好比人在实际生活中思考问题的方式一样。 这种开发模式，在实际工作中，我有一次在重构公司项目中一个关于表单组件的过程中曾使用过，之所以使用这种方式，是因为在表单组件中，会存在一些关于联动校验或者分组的需求，如果将这部门逻辑封装为``service``或者直接写在``controller``内部，越到后面会发现逻辑复杂度越高，从而越来越难维护。 使用这种模式，将复杂的逻辑划分成小的颗粒，再封装为独立的指令，在需要用到这些逻辑的组件中注入这些指令即可，指令的特点就是一般都会比较简洁，只会做一些简单的事情，相比之下，维护一个十分复杂的service和维护若干简单的指令，我更倾向于后者。]]></content>
      <categories>
        <category>翻译</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级 Angular 组件模式 (2)]]></title>
    <url>%2F2018%2F01%2F10%2Faacp-2%2F</url>
    <content type="text"><![CDATA[02 Write Compound Components 原文: Write Compound Components 目标 我们需要实现的需求是能够使使用者通过&lt;toggle&gt;组件动态的改变包含在它内部的内容。 实现 我们可以把toggle抽象为一个复合组件，由三个新的组件&lt;toggle-button&gt;、&lt;toggle-on&gt;、&lt;toggle-off&gt;构成。 每一个组件的职能与它们的父组件保持一致，它们各自的职能如下： toggle-button: 代表开关，用来渲染父组件的开关状态 toggle-on: 根据父组件的开关状态，渲染当状态为开时的内容 toggle-off: 根据父组件的开关状态，渲染当状态为关时的内容 &lt;toggle&gt;组件可以实现@ContentChild装饰器获取这三个子组件的引用，从而可以根据开关状态的变化调整它们之间的关联逻辑。 成果 经过这样的调整，我们可以使用户通过使用&lt;toggle&gt;组件去自定义包含在它其中内容的显示逻辑，内容中会有一个按钮负责切换开关的状态。可以尝试在在线代码库中调整子组件的顺序，你可以在它们中间嵌套任何的html字符串，只要这三个组件是作为&lt;toggle&gt;的子组件存在的，一切都将正常的运行。 相关话题 @ContentChild装饰器将会返回在组件标签包含的内容中，第一个符合选择器的子组件或者子指令的引用，比如&lt;toggle&gt; This is the content &lt;/toggle&gt;。如果想获取所有的子组件或者子指令，使用@ContentChildren。 @ViewChild或者@ViewChildren装饰器是用来获取在组件内部模板中使用的单个或者多个组件的。比如template: 'This is the view'或者templateUrl: './my.component.html' 译者注 这里组件架构方式是标准的Smart Component（智能组件）和Dump Component（木偶组件）组件架构方式。 以上的需求完全是可以在&lt;toggle&gt;内部实现的，但是这样会使它的内部充满逻辑代码，反之我们可以将一些职能划分为成更小的碎片，并委托到它的子组件中，本身作为容器组件存在，负责协作子组件从而达到目的。 对于@ContentChild和@ViewChild的使用场景，我认为通过看装饰器前缀的寓意是最后的方式。 Content代表内容，这些内容在组件渲染时已经存在于组件声明标签的内部，通常在组件内部以&lt;ng-content&gt;为占位符 View代表视图，视图代表组件本身的模板，代表组件本身的渲染逻辑 @ContentChildren和@ViewChildren同理。]]></content>
      <categories>
        <category>翻译</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级 Angular 组件模式 (1)]]></title>
    <url>%2F2018%2F01%2F10%2Faacp-1%2F</url>
    <content type="text"><![CDATA[写在前头 Angular到现在已经到5.x的版本了，对于MVVM框架我首先接触的是angularjs后来又转为react，之后换了工作因项目技术栈的原因又转换到之前的angularjs，在实际工作中实施了公司几个比较重要项目中前端的重构工作，这个过程逐步意识到，对于MVVM框架本身，在使用层面讲，掌握一些通用的模式是很有必要的，尤其现在已经很流行的组件化开发。这样我们在实际工作中就可以无缝（或者花很少的时间成本）转化到任何的MVVM框架，并把节省下来的时间去学习新的知识。 最近一直在关注Angular In Depth的博客，偶尔看到这个系列的文章，觉的质量还挺高，所以抽空余时间翻译并分享给大家，并在每个文章后面加了一点自己的拙见，希望可以达到抛砖引玉的效果，如果观点有误，还望各位看官轻喷。 01 Build a Toggle Component 原文: Build a Toggle Component 如Kent C. Dodds Advanced React Component Patterns那样，我们将使用一个相对简单的&lt;toggle&gt;组件来说明这些模式。&lt;toggole&gt;组件的职责是仅仅是管理一个简单的布尔值状态属性: on。使用如此简单的组件进行说明的目的，是因为我们可以将更多的注意力投入到相对组件本身而言较复杂的模式中。 经过这一系列文章，我将提供包含完整功能的、可运行的演示代码链接。你仅仅需要将注意力集中到app文件夹和toggle文件夹。toggle文件夹包含一些可复用的库（一系列组件），当然这个库会随着文章的深入而改变。app文件夹并且特别是app.component.html，将针对库在不同的情形下的使用做出相应的改变。 我们将从最原始的toggle组件版本开始。它仅仅有一个使用了@Input()装饰器的on属性，这个属性所控制的状态代表组件本身的开关状态，同时它还有一个是使用了@Output()装饰器的toggle事件发射器，这个事件发射器会在组件开关状态改变的情况下，通知父组件。 在我们开始下一个话题02 Write Compound Components之前，可以在在线代码仓库看看这个组件的实现以及演示。 译者注 toggle组件的实现是一个很典型的利用单向数据流作为数据源的简单组件： on是单向数据源，同时代表组件内部的开关状态 toggle`是事件发射器`，以回调的方式将on``状态的变化传递给父组件]]></content>
      <categories>
        <category>翻译</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多维数组取值问题]]></title>
    <url>%2F2017%2F12%2F18%2F%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%8F%96%E5%80%BC%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题简述 给予一个多维数组和一个描述取值路径的一维数组, 通过调用函数f返回取值路径描述的值，如 f([[1, 2], [3, 4], [5, 6]], [0, 0]) -&gt; 1 原问题传送门 之所以想记录一下是因为之前有在codewars刷题的习惯，后来工作忙就怠慢了，今天闲来无事就准备刷几道玩玩，然后就挑了一个比较简单的7kyu（codewars中的难度评级）的题。 因为这题比较简单，我也没多想，上来就干，仔细想了下，很容易嘛，不就是递归吗？按大学老师教的来一套： 先找递归退出的条件，当路径取到最后或者目标数组已经取尽（这里似乎题目没有说清楚，暂定不对取值路径做限定吧） 再找递归的模式, 如果不满足递归退出的条件，则将目标数组缩小一维，传递新的取值路径并递归 然后就有了第一版代码 123456function getElement(array, indexes) &#123; const idx = indexes.shift() if(indexes.length === 0 || array[idx].constructor !== Array ) return array[idx] else return getElement(array[idx], indexes)&#125; 然后跑了跑作者提供的简单测试用例，all passed，我就说嘛，这么简单的题目不一把过岂不是有点丢脸，然后就直接点了提交，然后就蹦了一大片的failed测试用例出来，仔细看了看失败的测试用例，并没有看懂，因为都是很多莫名奇妙的数据，并且每次返回的结果都不一致（后来才知道是随机的用例）。 之后一直以为是自己有一些边界情况没有考虑到，就前前后后又看了几次自己的答案，并没有发现什么大的问题，但是无论怎么提交都是失败。之后前前后后大概看了15分钟左右，突然就觉得是我自己把问题想简单了。 因为最近一直在看函数式的东西，突然就联想到，自己写的这个函数，并不纯。关于纯函数是函数式编程中最基本的概念之一，所谓纯既是要求函数没有副作用，我这里的getElement使用了Array.shift方法，会对原数组进行修改，从而产生副作用。这么一想一下就和之前每次跑用例总是产生意想不到的结果的情况联系上了，随机用例的失败原因一定是因为测试路径会有很多个，但是测试目标数组只有一个，因此有副作用的话，只有第一次测试的结果是正确的，后面都会因副作用产生不同的结果。 既然是因为数组是引用类型而产生的问题，那么直接来一个深拷贝就可以了。因为这里只是答题，所以使用一个最简单粗暴的深拷贝大法x =&gt; JSON.parse(JSON.stringify(x))，然后代码就有了第二版代码 123456789function getElement(array, indexes) &#123; array = JSON.parse(JSON.stringify(array)) indexes = JSON.parse(JSON.stringify(indexes)) const idx = indexes.shift() if(indexes.length === 0 || array[idx].constructor !== Array ) return array[idx] else return getElement(array[idx], indexes)&#125; 之后提交，所有的用例都通过了。但是还没有结束，因为自己的代码在实现上还是挺啰嗦的，同时还使用了深拷贝大法，有没有更简单的方法呢？ 有的。如果仔细思考一下，这里的解题的思路其实和Array.reduce的模式很像 对一个数组进行遍历（对路径数组进行遍历） 每次遍历返回一个值，并作为参数传入下一次遍历（对目标函数的降维） 在遍历完成后，返回一个结果（取值路径对应的值） 因此利用Array.reduce，这个问题一行代码就可以解决，如下 123function getElement(array, indexes) &#123; return indexes.reduce((a, i) =&gt; a[i], array);&#125; 同样多考虑一下，它是纯函数吗？是的，它是纯的。因为这里只做了取值的操作（a[i]），并不涉及任何的修改原数组的操作。这个答案也是在我提交后，所有答案中实现方案最好的一个。 当然还有其他的暴力破解法，我觉的想法也不错，比如 123function getElement(array, indexes) &#123; return eval(`array[$&#123;indexes.join(&quot;][&quot;)&#125;]`);&#125; 还有利用spread运算符的方法，如 1const getElement = (array,[index,...moreIndices]) =&gt; moreIndices.length ? getElement( array[index], moreIndices ) : array[index] 所以工作累了，或者闲来无事，刷刷题还是挺有意思的，可以看见一些自己平时很熟悉但是在需要用时又难以想起的知识。]]></content>
      <tags>
        <tag>js</tag>
        <tag>kata</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从ng1看ng2 关于NgModule的简易归纳]]></title>
    <url>%2F2017%2F07%2F21%2Fng2-%E5%85%B3%E4%BA%8ENgModule%E7%9A%84%E7%AE%80%E6%98%93%E5%BD%92%E7%BA%B3%2F</url>
    <content type="text"><![CDATA[写在前面 最近开始折腾ng2，其实说是ng2，到目前为止，它已经发布了4.3版，就是这么的高产，高产似**，我连2都还木有完整的看完它竟然发布了4.*的版本（鄙视脸）。 不过话说回来，之前工作不忙的时候，想看看ng2的东西，我的天，又是ts，又是observable的，吓的我硬是没有上来就直接去看它的入门文档，而是买了本typescript的入门开始看，后来书看了一半，工作又忙了，就想着可否重构历史代码加顺带学习rxjs的姿势去做需求，后来我也是这么做的，庆幸的是，这么做效果是挺好的，不仅实际开发效率高了不少，同时也入门了rxjs。 最近工作又闲了下来，就想着赶紧带着半吊子的ts和rxjs水平看看ng2的文档吧，虽然ng2在国内似乎热度不如react和vue流行，但是在全世界还是劲头还是比较强劲的，毕竟有谷歌爸爸和微软爸爸做东，强强联合。 而且我是个遵守规则的人，一向喜欢大而全的东西，ng这种框架我觉的真的是很对我的胃口。不过这ng2的文档不看不要紧，一看真的是有些蛋疼，随便看个啥，连码代码加理解，估计一下午也就能看一个简单的概念，就比如今天想归纳的NgModule这部分东西，前后大概有30几页的东西，所以我觉的如果不写点东西总结一下，必然是看了就忘，忘了再看的节奏。 ng1中的module回顾 其实熟悉ng1的话，对于这ng2中的module的理解是很有帮助的。从ng1开始，就一直再提倡一个module的概念，比如 1234567angular.module(&apos;baz&apos;, [])angular.module(&apos;bar&apos;, [])angular.module(&apos;foo&apos;, [&apos;bar&apos;, &apos;baz&apos;]) .factory(&apos;fooFactory&apos;, function()&#123; ... &#125;) .service(&apos;fooService&apos;, function()&#123; ... &#125;) .component(&apos;fooComponent1&apos;, &#123; ... &#125;) .directive(&apos;fooDirective&apos;, function()&#123; ... &#125;) 这么的我就分别声明了foo、bar和baz的module，同时foo依赖于baz和bar，然后就没有然后了，之后你就可以在这个这些module中做一切你想做的任何事情。通过这种module的划分，我们可以在各个维度中，抽象我们的代码，比如从业务上、从代码类别上等等。 ng2中的module简述 ng2将这种概念更推进了一步，虽然我们可以使用module的方法来改变我们编程的思维，但是代码本身并不具有module的含义，这么说可能有点难理解，举个例子，就上面的例子，对于bar和baz模块，我们很难简单的从代码层面来区分它们分别的职能是什么。因此ng2改用了以Decorator的方式来使代码具有语意性，如下 1234567@NgModule(&#123; imports: [ ... ], declarations: [ ... ], providers: [ ... ], exports: [ ... ]&#125;)export class FooModule &#123; &#125; 通过NgModule这个装饰器来对一个class进行描述。如果直接和ng1对比的话，装饰器的参数对象中的几个属性分别对应ng1中的： imports: 对应ng1声明中的模块依赖数组['bar', 'baz']，进行一些依赖模块的声明 declarations: 对应ng1中的.component('fooComponent1', { ... })和.directive('fooDirective', function(){ ... })，进行一些声明式类的声明 providers: 对应ng1中的.service('fooService', function(){ ... })和.factory('fooFactory', function(){ ... })，进行一些服务类的声明 exports: ng1中没有独立的exports语法，因此不做对比，在ng1中只有依赖模块中提供的服务、模块，加载模块均可使用。 ng2中module分类 ng2对不同的module提供了不同的语意性描述方式，可以通过装饰器属性来描述它们。 root-module（根模块） 所谓根模块，即一个应用的最上层的模块，即应用的入口模块，有时候也会称作app-module（这也是文档中指出的最佳实践）。这个概念在ng1中同样有，但是和上面指出的问题一样，就是没有代码层面的语意性描述，为了更好的描述它，ng2中的root-module会提供额外的装饰器属性来修饰它 12345@NgModule(&#123; ..., bootstrap: [ ... ]&#125;)export class AppModule &#123; &#125; 这个bootstrap代表这个模块会在应用初始化阶段被引导和加载，一般来讲，ng2都会有一个独立的main.ts文件来引导加载根模块，这个过程对于根模块是透明的，因为它并不知道它如何被加载，有可能是在浏览器加载，有可能是在移动端加载等等，有可能使用JIT做动态加载，有可能提前编译好做静态加载，这些都是未知的，它仅仅需要表达的是，这个模块是可被引导加载的。通常情况下，一个应用只有一个root-module（这不是废话吗），但是在一些大型的应用中，可能会存在多个独立的子项目，那么就有可能存在多个root-module。 sub-module（子模块） 所谓子模块，即一个应用从属于根模块的模块，即应用按各个维度划分形成的颗粒，比如从功能划分、代码架构划分等等，有时候也会称作feature-module（这也是文档中指出的最佳实践），ng1同样无法在代码层面进行语意性描述。 一般来讲，只要符合ng2中的module简述中的模块声明方式声明的模块，就是一个feature-module，它具有什么样的feature，完全取决于它提供什么样的声明式组件和服务。对于不同的feature，如服务、指令和组件会以其他的装饰器进行修饰和声明，这不是本篇文章的内容，我们只需要知道，一个feature-module负责声明和管理它提供的服务和声明式组件。值得一提的是，和ng1不同，ng2中的feature-module可以声明一些私有的组件和服务，这一点在ng1中时做不到的。 core-module（核心模块） 核心模块其实本质上讲，即是feature-module，只不过它提供的声明式组件和服务，是基于app本身构建的。言外之意，就是它必须是单例的，比如像登录验证这种服务，就是一种全局性的、app级别的服务，再入导航、顶部条等组件，也是app级别的组件，这些东西应该归并到core-module中，并在app-module中加载它，而坚决不要在feature-module中加载它。 share-module（共享模块） 共享模块也是feature-module，只不过它提供的声明式组件和服务，是从各个feature-module中提取出的公共组件和服务，在官方的例子中，高亮这个指令，就是一个公用的指令，并不依赖于任何独立的业务逻辑。这些东西应该归并到share-module中，并在各个feature-module中加载它，从而使得我们的代码尽可能的保持简洁。 lazy-load-module（懒加载模块） 对于SPA来讲，路由是必不可少的东西。那么对于一些未使用页面所加载的模块，我们没有必要从一开始就加载它们，很自然的，它们就成为了懒加载模块，这些模块本质上讲均是feature-module，因为core-module和share-module从职能来讲，在整个的应用生命周期，尤其初始化必不可少，因此它们很少成为懒加载模块。]]></content>
      <categories>
        <category>原创</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 redux 中集成 angular di 机制]]></title>
    <url>%2F2017%2F05%2F31%2F%E5%9C%A8-redux-%E4%B8%AD%E9%9B%86%E6%88%90-angular-di-%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[最近一直在折腾redux相关的东西，算然说官方鼓励的使用方式是将redux和react一起使用，但并不影响我们在其他的mvvm框架中使用它。 众所周知，angular是一个大而全的框架，想和redux一起使用，需要摒弃一些angular中常用的开发理念与模式，仅仅将它作为一个视图层框架使用，就和react一样，不在将类似domain state和app state的状态维护在controller或service中，而是全权交给redux维护。 我们可以通过使用ng-redux注入redux服务，从而在angular中使用它。 基本的使用项目文档介绍的已经很详细了，这里仅仅想分享在这段时间折腾redux和angular遇到的一个比较蛋疼的问题，以及是如何解决的。 在redux中，业务逻辑的抽象被描述在action中，因此除了一些同步action以外，必然存在类似向后端发送请求获取数据之类的异步action。那么问题来了，在angular中有一个大家很熟悉的机制，叫做依赖注入（简称di），因为这种机制的存在，在angular中，我们一般使用一个服务是不关心它的实例化过程的，我们所做的，仅仅是声明它，告诉模块，我们在运行时，需要注入相关依赖的实例，但是在redux中没有这种机制，对于想在action使用的服务，你必须先导入它，实例化，你才可以使用，这与angular本身的di机制相悖。 那么我们如何来解决这个问题呢？ 一种简单粗暴的方法就是，完全摒弃angular的di机制，使用外部的模块来解决问题。比如发请求，难道我们非要使用$http服务吗？我们完全可以直接使用像superagent这样的第三方库来代替它。但是随之而来的问题就是，对于angular已经使用$http服务的代码，你必须考虑是否重构它们，如果不重构，你则会在代码中拥有两套发送请求的逻辑，代码冗余了，如果重构呢，工作量又会很大，没准折腾redux不成，又给全改回去，得不偿失，因此这种方法不是完美的解决方案。最完美的方法应当是，既不摒弃angular的di机制，又可以兼顾redux框架，可是redux没有di机制这怎么破呢？ 这个问题费了我不少时间去搜索网上的资料，类似如何在action使用angular di机制，如果在action获取service实例等等，虽然能查到的资料都没有完美的给出解决方案，但是都把问题的解决方向，指向了同一处，即redux的中间件机制。 第二种方法则通过redux中间件的机制来实现 什么是中间件机制呢？这个可是个大概念，简单的理解的话，我只引用一个计算机常用的用来调侃的话解释。 计算机科学中，没有什么问题是不能通过增加一个中间件来解决的。 话虽然这么说，但是它是很有道理的，对于redux的中间件机制呢，它是对于action来设计的，即一个action，在最终转移到到处理它的reducer之前，会经过若干大大小小的中间件，这些中间件做的事情十分的简单，即输入一个action，按自己的处理逻辑加工它，再交到下一个中间件手中，直到没有下一个中间件为止。 明白了redux的中间件机制，那么上面的问题就好解决了，对于想在action中使用的通过angular di机制来实例化的服务，我们没有必要在action中实例化，我们完全可以仅仅在action中声明，之后呢，将实例化的过程交由中间件处理即可，那么可能你又会问，action没有办法集成di机制，中间件难道能集成吗，如果不能岂不是又回到了问题的原点？是的，但是中间件它的确可以集成di功能，为什么呢，因为中间件的实例化逻辑是通过ng-redux在angular内部进行的，而中间件本身呢，有仅仅是一个函数而已，那么我们完全可以把中间件的实现，声明成一个angular中的factory或者service，之后在其中使用angular的di机制，动态的实例化action中依赖服务的实例，关于这一点呢，在ng-redux的文档中有提及，但是没有说的特别的清楚。 talk is cheap, show me the code. 下面贴一下关于实现解决以上问题的中间件实现源码。 123456789101112131415161718192021222324252627282930import angular from &apos;angular&apos;import R from &apos;ramda&apos;export default function thunkWithDepsMiddleware () &#123; const injector = angular.element(document.body).injector() return (&#123;dispatch, getState&#125;) =&gt; next =&gt; action =&gt; &#123; const isNotNil = R.complement(R.isNil) const isFSA = R.both(R.has(&apos;payload&apos;), R.has(&apos;type&apos;)) const isLastItemIsFunction = R.compose(R.is(Function), R.last) const isAngularInlineArrayAnnotation = R.both(R.is(Array), isLastItemIsFunction) let annotation // FSA 处理逻辑 if (isFSA(action)) annotation = R.prop(&apos;payload&apos;, action) // 普通 action 处理逻辑 else annotation = action if (isAngularInlineArrayAnnotation(annotation)) &#123; const locals = &#123;dispatch: dispatch, getState: getState&#125; const payload = injector.invoke(annotation, this, locals) if (isNotNil(payload)) return dispatch(&#123;...action, payload&#125;) &#125; else if (R.is(Function, annotation)) &#123; const payload = annotation(dispatch, getState) if (isNotNil(payload)) return dispatch(&#123;...action, payload&#125;) &#125; else &#123; return next(action) &#125; &#125;&#125; 大体逻辑呢，就是通过angular中$injector服务来解决问题，抽离出action中的关于di的声明逻辑，该中间间仅支持inline array annotation语法来声明依赖，对于符合FSA(Flux Standard Action)的action, 如果传入的action中的payload符合该语法，则通过injector.invoke来解析它，如果不是，则简单的按redux-thunk的处理逻辑进行处理，对于一般action同理，只不过是对于它本身进行处理。 实现之后呢，通过ng-redux的语法注册它， 1$ngReduxProvider.createStoreWith(reducers, [&apos;thunkWithDepsMiddleware&apos;, promiseMiddleware]) 之后我们的action即可直接返回符合inline array annotation语法的数组声明依赖，如下： 1234export const fetchRoles = createAction(FETCH_ROLES, () =&gt; &#123; return [&apos;$q&apos;, &apos;dispatch&apos;, ($q, dispatch) =&gt; &#123; // do something ...&#125;)]]></content>
      <categories>
        <category>原创</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>angular</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6中的混合器模式]]></title>
    <url>%2F2017%2F04%2F24%2Fes6%E4%B8%AD%E7%9A%84%E6%B7%B7%E5%90%88%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[这是有关设计模式相关的第一篇文章，谈及设计模式，一般情况下呢，很多人马上就会说出很多关于它的东西，比如单例模式、策略模式等等。对于各个技术栈的工程师们，各种设计模式应该再熟悉不过，这篇文章要分享的是关于前端中的混合器模式，也可以称作装饰器模式，并分享一些在实际开发中的应用。 在面向对象的开发中，实际业务的描述是通过类(Class)来进行描述的，如果想给一个已经存在的类扩展某些行为（如增加某个方法、某个属性等），可以通过类的继承来实现，即将可复用、可扩展的方法抽象为父类中的方法之后继承它。 但是思考一下，这种做法的弊端： 类的继承所扩展的方法或属性是静态的，既你无法为一个已有的类的实例扩展某些方法。 类的继承会继承父类中的所有可继承的方法和属性，但是你只想继承其中的某个或某几个方法。 在es6中，加入了装饰器(Decorator)语法，提供了对于装饰器模式的原生支持。这里对于语法不再进行详细的阐述，可以点击这里进行了解或学习。 在这种模式下，我们可以动态的来为一个类增加某个方法或属性，你可能会问，这样听起来似乎和继承没什么不同？你错了，它的优势体现在动态二字，其含义即为可以动态的为类的实例增加某种行为，也许你又会说，在js中，它本身就是动态语言，这种动态性也失去了优势了吧。 是的，但是在js中想要实现继承绝非易事，因为它的继承机制是通过原型链进行描述的，对于js新手的话，理解起来其实是有点晦涩的，有些时候我们仅仅想通过更清晰的手段使用另一个类中的某些方法。 举个例子，在SPA开发中，经常会遇到处理分页数据的需求，对于分页逻辑的处理，很显然是一块需要抽象为公共方法的逻辑，但是如果你按继承的角度去考虑，就会发现，有些时候你继承了这些处理分页逻辑的方法反而是多余了，因为并不是每个页面都需要分页，这种情况下，使用混合器模式来实现则可以更好的解决问题。 我们先来实现一个分页逻辑的混合器，它其实是个函数，函数的参数是一个类，之后会动态的在这个类上增加一些方法，从而达到在一个类中混入另一个类的某些方法的目的。 123456789101112131415export const PaginationMixin = (superClass) =&gt; class extends superClass &#123; nextPage (url, callback) &#123; this.handlePaginationResolve(url, callback) &#125; previousPage (url, callback) &#123; this.handlePaginationResolve(url, callback) &#125; handlePaginationResolve (url, callback) &#123; if (!url) return customAPIComposer(url, &apos;get&apos;).then(callback) &#125;&#125; 之后，只需要按如下进行代码，对需要扩展的类进行扩展， 1class AttendanceManageCtrl extends PaginationMixin(MixinBase) 扩展后就可以使用混合器中混入的方法了，如下 1&lt;oa-list-table list-data=&apos;$ctrl.listData&apos; on-next=&apos;$ctrl.nextPage($ctrl.listData.next, $ctrl.render)&apos; on-previous=&apos;$ctrl.previousPage($ctrl.listData.previous, $ctrl.render)&apos;&gt; 这样做似乎和继承没什么区别，但是不妨看看如下代码 1class PeopleCtrl extends R.compose(PaginationMixin, StateManageMixin)(MixinBase) 没错，你可以对一个类同时使用多个混合器，但是你却无法使一个类同时继承与多个类，虽然你可以通过多重继承实现，但显然比前者繁琐很多。 尽情混入吧。]]></content>
      <categories>
        <category>原创</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codereview-s8]]></title>
    <url>%2F2017%2F02%2F07%2Fcodereview-s8%2F</url>
    <content type="text"><![CDATA[当元素间存在父子关系时，留意事件冒泡机制所引发的连锁反应 123456&lt;tr style=&quot;cursor: pointer;&quot; ng-repeat=&quot;row in $ctrl.efficiencyTable.bodyData&quot; ng-click=&quot;$ctrl.stepView(row)&quot;&gt; ... &lt;td class=&quot;text-left&quot;&gt; &lt;a ng-click=&quot;$ctrl.efficiencyView(row)&quot; class=&quot;hover-link&quot;&gt;查看流程&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; a元素的点击事件会efficiencyView方法，但因为事件冒泡机制，也会间接的调用stepView方法 最佳实践 angular中可以使用内置的 $event 对象来解决相应问题 首先声明使用$event对象并传参 1&lt;a ng-click=&quot;$ctrl.efficiencyView(row, $event)&quot; class=&quot;hover-link&quot;&gt;查看流程&lt;/a&gt; 之后再efficiencyView方法中调用stopPropagation方法阻止事件冒泡 1234efficiencyView (workflow, $event) &#123; ... $event.stopPropagation() &#125; 也可以对比$event对象中的target和currentTarget属性是否相同，因为这两个属性分别代表触发事件的dom节点与响应事件的当前节点 1if($event.target === $event.currentTarget) ... 扩展 EventTarget.addEventListener 方法及其参数的含义 解析Javascript事件冒泡机制 z-index 常见问题 关于z-index本身用法我是了解的，但是最近在做下拉框组件和datepicker时，踩了一些坑，如下： 只有设置了position属性的元素的z-index才会生效 当父容器的z-index小于元素A时，其子容器的z-index无论多大都无法覆盖元素A 最佳实践 实现具有下拉菜单展开特效的组件时，一般会套用一下结构 12345678&lt;div class=&quot;dropdown-wrapper&quot;&gt; &lt;div class=&quot;dropdown-toggle&quot;&gt; ... &lt;/div&gt; &lt;div class=&quot;dropdown-list&quot;&gt; ... &lt;/div&gt;&lt;/div&gt; 当两个下拉菜单处于垂直布局时，如果没有设置z-index属性，因为dropdown-toggle比dropdown-list先出现，因此默认的图层顺序是前者高于后者，所以当上面的下拉菜单出现的时候，并不会覆盖下面的toggle,为了解决这个问题，必须做如下处理 12345.dropdown-list&#123; ... z-index: 1000; ...&#125; 最后附上DEMO 扩展 z-index 对表格中的单元格增加一个hover高亮效果 对于表格中td增加hover高亮时可能会遇到一个问题，就是当你使用常规的border属性对边框进行设置时，可能会发现，每个单元格的上边框和左边框都没有达到理想的效果，但是下边框和右边框却是正常的。 这种问题会出现在对table增加border-collapse: collapse属性或是引用一些第三方的css库，比如bootstrap，具体现象参考DEMO。 最佳实践 解决方法其实很简单，就是将td边框的样式从solid改为double，如下： 123table tr td &#123; border-style: double;&#125; 原因如下： Since double is &quot;more distinct&quot; then solid, its colour takes precedence over cells around it, and looks identical to solid anyway ;) 扩展 border-style各属性值及赋值语法 angular中遭遇的一个奇葩问题 这个问题是我在本期开发排班器组件时遇到的一个很奇葩的问题，大体描述就是如上面github链接中描述的一样，就是当父组件的一个数据采用双向绑定时，并且需要已事件回调的方法更新其内部的某个属性值，然后使用签名为onChange的scope属性传给子组件，比如: 12345scope:&#123; ... onChange: &apos;&amp; ...&#125; 那么这个onChange的调用在父组件进行更新某条以双向绑定方式进行绑定的属性时，会先于子组件的更新前自动调用，这么说有点抽象，大体的问题我简单描述下。 本来onChange的调用时机应当是自下而上的，也就是当子组件发生更新时，调用父组件通过onChange属性传递的事件回调方法，这个方法会更具子组件的当前状态来对父组件进行更新，这就是理想中的单向数据流子组件通知父组件进行更新的机制。但是在angular中遇到的奇葩现象现象就是，在父组件进行更新时，不知道是因为签名的缘故还是双向绑定的缘故，这个onChange都会先于子组件运行一次，那么问题来了，这个方法本来的调用时机是子组件更新后需要通知父组件进行相应更新时调用的，然而现在子组件还未更新则先调用了该方法，那么回调函数中的参数必为空，除非onChange中加入了空校验代码，不然就会报错，其实加了空校验也没有什么意义，因为这个方法都会调用的，但是却不会进行任何的改变，相当于浪费了一部分性能。 最佳实践 解决方法在这里，这种解决方法算是一种workaround，即在组件中使用另一个对象来储存父组件需要更新的那个值，算是做了一种类似中间件的处理，之后因为双向绑定自动更新机制对于对象的更新时更具reference来进行的，那么在父组件或子组件中对于这一个数据的引用均是相同的，而不会像基本数据类型存在一个新旧值的差异，不过这终究是一个workaround。 限制上传文件的类型 现在通过type为文件类型的input上传文件已经很普遍了，并且对于表单的校验，通常我们会在提交时进行，文件类型的表单也不例外，一般校验的内容有文件大小、文件类型（扩展名）等等。今天遇到一个需求很有意思，大体意思是想在用户进行文件上传时，就有偏向性的屏蔽掉一些不支持的文件格式，比如上传图片，那么在文件选择对话框就不要出现文本类型的文件。 这个问题我一开始是不知道怎么解决的，因为浏览器对于操作系统是一个沙盒，因此对于文件显示的控制应当没有权限控制，去网上google了下，答案也是这样的，没有方式可以实现百分之百屏蔽某种文件类型的方式。但是却发现了另一个很有意思的属性，也可以达到类型的效果。 这个属性就是input标签的accept属性： If the value of the type attribute is file, then this attribute will indicate the types of files that the server accepts, otherwise it will be ignored. The value must be a comma-separated list of unique content type specifiers: 它可以接受的值的描述： A file extension starting with the STOP character (U+002E). (e.g. .jpg, .png, .doc). A valid MIME type with no extensions. audio/* representing sound files. HTML5 video/* representing video files. HTML5 image/* representing image files. HTML5 最佳实践 比如我们想要限制上传文件类型为excel文件类型，只需要创建如下标签: 1&lt;input type=&quot;file&quot; accept=&quot;.xls,.xlsx&quot;/&gt; 这样这个文件表单对话框被激活时，默认会选取以.xls和.xlsx结尾的文件。 虽然这个属性可以达到类似的效果，但是是无法完全替代对于文件扩展名的校验的。因为只要用户想要上传别的类型的文件，通过切换文件对话框中的选取文件类型选项（比如显示全部文件类型），就可以选取别的类型的文件了，因此在提交时，也别忘了添加校验逻辑，防止因为上传了一些不支持的类型造成服务器内部错误。 扩展 input]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async-for-js]]></title>
    <url>%2F2016%2F11%2F28%2Fasync-for-js%2F</url>
    <content type="text"><![CDATA[介绍关于js开发中所涉及的主流异步编程解决方案 repo: async-for-js 例子 插入3个div元素，其中第二个div元素使用setTimeout模拟异步操作，理想的插入顺序为div1 div2 div3，但这里的代码的插入顺序为div1 div3 div2。 123456789101112// async wayfunction _async() &#123; document.body.appendChild(div1) setTimeout(function () &#123; document.body.appendChild(div2) &#125;, 2000) document.body.appendChild(div3)&#125;_async() Callback 最常用的方法是利用callback(回调函数)的方式，因为js中函数也是作为对象存在的，因此可以被当做参数传入另一个函数中，只需要在异步操作执行代码后调用回调函数即可。 但是使用回调函数有很明显的局限性，一方面体现在需要自己对异步操作进行控制，另一方面还很容易陷入&quot;回调地狱&quot;。 123456789101112131415// use plain callback to syncfunction _callback(cb) &#123; document.body.appendChild(div1) setTimeout(function () &#123; document.body.appendChild(div2) cb(&apos;done&apos;) &#125;, 2000) return &apos;done&apos;&#125;_callback(function () &#123; document.body.appendChild(div3)&#125;) Promise 因为回调地狱的问题，后来聪明的人使用将回调延迟执行的思想，从而发明了promise库，调用者可以根据异步流程随心所欲的resolve或reject某个值给之后的操作，从而解决了毁掉地狱的问题。 不过使用promise仍然有问题，就是当代码逻辑很长的时候，总需要带着大片大片的then方法，可读性仍然不够清晰。 12345678910111213141516// use promise to syncfunction _promise() &#123; document.body.appendChild(div1) return new Promise(res =&gt; &#123; setTimeout(function () &#123; document.body.appendChild(div2) res(&apos;done&apos;) &#125;, 2000) &#125;)&#125;_promise().then(data =&gt; &#123; console.log(data) document.body.appendChild(div3)&#125;) Generate 后来promise加入了es6标准，同时推出了新的异步解决方案，叫做generate函数，大体讲是提供了一个具有状态机功能的函数，每次执行会停止在实现者声明的某个状态，下次调用会继续从这个状态开始执行。 generate的出现，使必须依靠callback实现异步操作的代码风格，可以使用同步代码风格实现，是一颗非常甜的语法糖。 但是它仍有有一些缺点，就是它作为状态机，无法自执行，必须借助实现一个run函数或使用第三方库(如co)。 123456789101112131415161718192021222324252627282930313233// use generate to syncfunction* _generate() &#123; document.body.appendChild(div1) yield function (cb) &#123; setTimeout(function () &#123; document.body.appendChild(div2) cb() &#125;, 2000) &#125; document.body.appendChild(div3) return &apos;done&apos;&#125;function run(fn) &#123; var gen = fn() function next(data) &#123; var result = gen.next(data) console.log(result.value) if (result.done) return result.value(next) &#125; next()&#125;run(_generate) Async/await 为了解决generate的缺点，es7很快发布了继generate更强大的一个东西，叫做async函数。简单说，它并没有什么新特性，把它看做是可以自执行的generate函数即可，其中的await的操作符可以看做是yield操作符的翻版。 1234567891011121314151617// use async/await and promise to syncconst fn = function () &#123; return new Promise(res =&gt; &#123; setTimeout(function () &#123; res(document.body.appendChild(div2)) &#125;, 2000) &#125;)&#125;async function _await () &#123; document.body.appendChild(div1) const f = await fn() console.log(f) document.body.appendChild(div3)&#125;_await() Observable 最近很火的rxjs也快成用来解决这个问题，详细的介绍可以去它的官网了解。 12345678// use rxjs and callback to syncconst _callbackObservable = Observable.bindCallback(_callback)const result = _callbackObservable()// result.subscribe(x =&gt; &#123;// document.body.appendChild(div3)// console.log(x)// &#125;)]]></content>
      <categories>
        <category>翻译</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当开发一周了]]></title>
    <url>%2F2016%2F10%2F14%2F%E5%BD%93%E5%BC%80%E5%8F%91%E4%B8%80%E5%91%A8%E4%BA%86%2F</url>
    <content type="text"><![CDATA[转行做前端开发正好一周了，仔细一想，是真正意义上的一周呀，因为连上了7天班了。 说到感觉如何，我只能说，那是太好了。自从来了新公司，心情一下就变好了，回想这半年来，一直因为一些事情闷闷不乐，我也是蛮能拼的。不过总体工作还是比较忙，因为正好赶上项目要发布的最后一周，而且前端组的好多工作似乎还堆积了，不过好在最后也是按时完成了任务。 &lt;!--more--&gt; 说到公司整体印象，挺好的。我本来寻思吧，估计大连没有像Liferay一样自由的公司了，然而我得到的答案是“自由最自由，只有更自由”。不过这种自由和Liferay相比还不一样，平时的时候，很自由，很轻松，工作或者解决问题的时候，大家又变得很认真、很紧张，这点不同对于我来说，其实是好的。其实原来我也一直在寻找这种感觉，就是大家为一个目标共同努力，共同工作，最后一直也没有找到。原来在Liferay的感觉是，虽然大家都在一起工作，但其实彼此的工作，联系似乎太少了，总是感觉个干个的，交流也少，整体的工作的节奏也比较慢，能解决的事情就解决，解决不了就拖着，慢慢就不了了之了。 说到工作内容，我还是有点惭愧的。我本想，作为一个新来的，代码也不熟悉，业务也不熟悉，然后就把一部分核心功能交给我做了。我只能说，对于我这种半路出家的前端开发，这是有多信任我啊，我自己都有点受宠若惊的感觉。按我的理解，一般新来还不先改改bug，熟悉熟悉业务，之后慢慢再开始做功能，先做次要的，再做主要的，再来核心的。所以导致我写代码的时候，总是有一种使命感似的，因为要对得起这份别人的信任啊。这种感觉仔细想想，似乎仅仅在两年前刚入职Liferay那会有，所以我后来就下定决心好好学习了，现在这种感觉又回来了，真好。 最后，我只想说，作为一个新的开始，只要仍然能够做到不忘初心，能够真心实意的为做一些事情而付出，开开心心的度过每一天，我就很满足了。]]></content>
      <categories>
        <category>其他</category>
        <category>心情</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[我为什么选择离开了Liferay]]></title>
    <url>%2F2016%2F09%2F26%2F%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%BB%E5%BC%80%E4%BA%86Liferay%2F</url>
    <content type="text"><![CDATA[距离离开Liferay还剩下用指头可以数出来的日子了，心中不禁感慨万千。这一个月除了做一些交接工作和下一份工作的准备意外，剩下的时间基本都在思考在Liferay的两年半时间我到底得到了什么，又留下了什么？仔细想想，好像没留下什么，至于得到的，确是很多的，毕竟这是我毕业步入社会进入的第一家公司，很多事情从未知到已知都是从这里开始。 在这里认识了不少人，我从他们身上都学到了很多很多，不经意间也帮助了我很多很多，我衷心说声谢谢，同时我也想说，对于我的离职我只想说，离别是为了下次更好的相遇。 不过写这篇的目的并不是为了怀旧，只是最近稍微熟悉点儿的人都在问我一个问题，“你为什么离职？”。这个问题，我从有离职想法的那天，到念头一点点变大，再到最后做出离职的决定，我已经问过自己无数次了。细说起来，大大小小的原因有很多，不过大体概括也就两点，一，我无法得到我想要的，二，Liferay同时也并不需要我这样的人，仅此而已，所以我选择离开。 这里直接说Liferay好像扣上了一个很大的帽子，好吧，这里只是说中国这边的Liferay，后边不特殊说明均指代Liferay CN，如果再具体些，可以指代Liferay CNQA。 &lt;!--more--&gt; 时间回到两年前，我刚刚来Liferay的时候，呆了一个星期左右，大体的感觉是，中国竟然还有这样人性化的公司？弹性制，不加班，年假长，事还少，虽然待遇差点，我心想也值得了，多给我个1000、2000的估计我也不会换其他公司，我也暗自决定，虽然闲，但是不能浪费这些时间，要好好利用空余的时间好好提升自己。事实上，我也是这么做的，这两年间我基本把所有空余的时间都投入到了学技术，学英语，学xx上。但越到后边，越觉的感觉不对，总觉的自己与公司、团队的距离越来越远了，最终不得不选择离职。 最直接的感觉是，团队的技术氛围越来越淡了，做事风格也越来越浮躁了，做很多事情只求结果。还有一些我至今也不是特别懂的事情莫名其妙就发生了，比如: 以前一个关一个ticket是很有自豪感，可以很负责任地说我关闭了它，它是没有问题的，现在我可以以各种流程为理由关闭它，但我再也不敢说它是没有问题的了。 前段时间CN这边也开始做test-fix，其实一开始我挺期待的，后边才发现确实不适合我做，我遇事但求个明白，我一直想要一个fix的技术标准，得到的标准却是as it work。 我后来抽时间给团队分享了一本有关公司测试脚本语音的学习笔记，心想水平虽然比不上某些去美国培训的人强吧，至少也是我自学这么长时间的一些心得体会，抛钻引玉而已，然后竟然被贴了一个“不尊重上级”的标签，还被越级告了一状。 再后来，我给团队写一个editor吧，也是对培养我两年之久的团队的一个证明，心想不求能极大的提高团队效率，能节省3、5分钟也是极好的，最终却令某些人嗤之以鼻，以“用工具最终出了问题谁负责”，“３、５分钟Lyon也许你觉得很重要，反正我觉得不重要”，“IDE评估了要半年才能做好这么一个东西”等理由被拒绝，最终说我态度有问题和我吵了一架，然后也没有下文了。后来我交了辞职信从别人口中得知，似乎也是尝试性地用过我做的这个editor的，之后似乎是真的没有下文了。不过对于这个editor反馈是好，还是不好，我一点都不清楚。在我看来，这更多算是一种“无声抗议”吧，你也不能说人家就是不愿意用你做的东西不是？但是人家就是不愿意。 我想说的是，和我这么多的不痛快，到底图个啥？我自以为，归根结底是因为我做很多事情，总是先斩后奏，导致别人总觉得上级领导是偏心我怎么的。据我猜测，应该是我这个人总让人产生不安全感，总让人觉的盛气凌人，总让人觉得会从别人那里抢走什么似的。那我确实不知道说什么了，毕竟这是人的问题，性格问题，处心积虑地为保全自己的地位来这么一次，我表示理解。 其实对于别人的想法，我是略委屈的，有些时候我也不知道我做这些最终图个啥？从未计较过薪酬待遇，也未曾计较过一官半职，只想尽情做自己想做的事情，为团队尽力所能及之力，改变一些事情。到头来却发现困难重重，一方面是因为团队相对别的office资源本来较少，工作中又常常处于被动的一方，没有什么话语权，另一方面则是团队大部分人本身就缺乏积极性，对于做出改变这种事情，大家大多选择安于现状，对于新鲜事毫无兴趣，少数人甚至比较排斥。 这两年来，我最大的遗憾，莫过于没有向美国证明，中国这边也是可以做技术活儿的，并不一定要依赖他们。我一直很不爽的事情，莫过于被人轻视，不过也是怪我，将这种情结也联系到了工作上面，致使我一直这么觉的，中国office是被美国轻视的，然后qa组的在中国的是被别的组的轻视的，然而最终还是证明我图样图森破，以一己之力，怎么可以带动整个团队？反过来想，现在的这样子的一个团队似乎也不能怪人家轻视。既缺乏核心技术竞争力，同时又处于工作中的被动方，人力成本又便宜，轻视你，怎么了？ 我离开Liferay只因为我做事太爱钻死理儿。逢事必问为什么，不然只能靠自己去寻找答案，却在寻找答案的过程中，碰了某些人的所谓的底线。 我离开Liferay只因为我做事不喜欢拖太久。今日事今日毕，有些时候其实并不怪我有些事情先斩后奏，实在是就算先奏，等能斩的时候黄花菜都凉了。 我离开Liferay只因为我做事脑子太“懒”，手却太“勤”，总强调一个效率。时间就是金钱我的朋友，别总和我说３分钟，５分钟不重要这种话，对于我，很重要，对于团队，也很重要。 我离开Liferay只因为我太执着，很多事情但凡投入心血，很难放下。是的，很难放下，但是我还是选择离开了，我并非薄情寡义之人，实在有苦难言，有痛难言。 不过我真心感谢我的直系经理sophia和小组组长steven还有整个fixpack组的每一个人，这两年间给予了我很多支持和鼓励，没有这些，我想我无法坚持这么久，也无法完成看起来无法完成的事情。 mark一下，从加入fixpack到离开的可计量工作（其实不是很完全和准确，因为后来做editor没太多精力了）和一些自发的全栈项目。 fixpack改为sub task后的工作量分布图: 项目: vscode-poshi easycomment testray-screenshot fixpack-workbench 最后祝Liferay越来越好，每个人工作顺利，开心。]]></content>
      <categories>
        <category>其他</category>
        <category>心情</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vscode typings配置]]></title>
    <url>%2F2016%2F09%2F21%2Fvscode-typings%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[vscode发布至今已经到1.5.2了，我是从1.1开始用的，经历了几个改动比较大的版本。总体给我的感觉还是很好的，作为一个rich editor，能够提供像webstorm之类ide的代码提示功能非常赞，但是对于这块的配置还真没折腾过，只知道它的提示是基于ts的compiler提供的，虽然是ts提供的，但是js作为ts的编译对象，同样可以享受这个compiler提供的便利。 &lt;!--more--&gt; 大体步骤分为： 配置typings 安装typings的依赖资源 进行vscode的js项目配置 配置typings 首先你需要安装nodejs环境，这里不赘述了。之后 npm i typings -g 这样全局都可以调用typings这个命令了，然后只需要在你需要提供智能提示的project的根目录执行 typings init 这样会生成一个typings.json文件，这个文件的功能和package.json类似。 安装typings的依赖资源 安装依赖就容易多了，比如你需要angular的资源，只需要执行 typings i dt~angular --save --global 这里的dt~是指资源的registry，这个可以在typings的帮助信息中查看。 如果你不确定某个资源的registry，比如你想要react的资源，你可以执行 typings search react 之后console会列出已知的所有资源的registry。 进行vscode的js项目配置 最后一步，需要为vscode指定js项目配置，这个配置文件叫做jsconfig.json，如果你只需要提供智能提示的功能话，这个文件可以为空。 这个文件的位置表示以当前位置为项目根目录。 并行的项目可以提供多个jsconfig在不同的项目中，以此来表示它们是彼此区分的。 对于嵌套的项目，配置多个jsconfig并不会区分父子关系，不是很建议这么做，因为这个智能提示功能是基于vscode extension的language server实现的，如果一个项目文件过多，可能导致解析超时而导致无法提供正确的提示信息（我遇过n次这种情况，开始还以为是vscode的bug），最好还是采用并行的方式。 效果 上图一张]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[interview record 20160822]]></title>
    <url>%2F2016%2F08%2F22%2Finterview-record-20160822%2F</url>
    <content type="text"><![CDATA[面试公司 大连云匠软件 &lt;!--more--&gt; 面试职位 Web前端开发 面试方式 电话面试 总结 问了一些列范围超级广的问题，不过我感觉大部分问题的答案，面试官还是比较满意的，有一些小问题没有答上来，我觉的并不是因为自己没有能力，其实就是所谓的“约书亚树”道理，当你不明白或者不知道一个事情的时候，如果没有机会去了解它，确实可能永远不可能了解了。就好比这次面试，如果面试官不问我，而我项目经验又比较匮乏，确实真的不知道啊。 有两个问题我特意去网上查了一下，因此这里特意记录下来，知道的就无视吧，不知道的共勉吧。 display:inline-block为默认样式的标签有哪些？ 这个问题我去网上查了一圈，最终按我的理解，这个问题答案的起点应该始于，HTML中有哪些替代标签? 那么就来查概念吧，替换标签是浏览器根据其标签的元素与属性来判断具体显示内容的标签。比如常见的input，根据type属性的值会生成不同功能及样式的标签。所以举一反三咯，a也是，img也是，textarea也是，select也是，因为这些标签本身并没有内容，它们的内容依赖于属性，因此是可&quot;替换&quot;的。 值得一提的是，替换标签均可以增加行高(line-height)，还可以调整baseline（vertical-align），废话，因为人家是inline嘛。 内容区高度值 = padding-top + padding-bottom + margin-top + margin-bottom + height 那么反过来，非替换标签就是浏览器根据其标签内容直接判断具体显示内容的标签。这个就很常见了，因为浏览器中的标签大部分都是非替换的，比如div, p等等。非替换元素添加padding-top或padding-bottom，不影响行框高度，但内容区高度会变化，margin-top，margin- bottom对行框没有任何影响。添加左右边距会影响非替换元素水平位置。要使非替换元素在父元素框内居中，可以设定line-height = 父元素框的高度。 参考: html中label宽度设置、非替换元素和替换元素 使用display:inline-block时，标签之间的空格如何解决（非margin）？ 这个问题是面试官连着上面的问题问的，当时直接就蒙逼了。后来挂了电话之后，回到电脑上试了一下，这个问题其实以前也确实遇到过，只不过没有在意罢了。 这个问题的表现类似于这样： 其中第一行中的input之间有一个小小的空格，然后呢，源码中并没有类似的的空格，然而真的没有吗，并不是的，这里的空格其实是input后跟着的那个换行符，要解决这个问题，下边的大神博客给了Ｎ种方法，我并没有挨个试，因为我没有额外的ie浏览器进行验证，只挑了几个简单易行的。 可以不写换行符，直接把元素写到一行，如果觉的可读性不行，那就把换行符写到块级注释中。 可以使用margin为负值进行调整，但是这个不推荐，因为空格宽度因浏览器不同而不同。 可以使用无闭合标签 可以对父元素使用font-size: 0; 这几个方法我亲测有效，其他方法日后有机会也试试，最后感叹句css真是博大精深，我表示除了积累应该是没有捷径了。 参考: 去除inline-block元素间间距的N种方法]]></content>
      <categories>
        <category>心情</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML is about meaning]]></title>
    <url>%2F2016%2F08%2F10%2FHTML-is-about-meaning%2F</url>
    <content type="text"><![CDATA[原文地址: http://marksheet.io/html-semantics.html HTML标签本身的意义是为了传递对于一个document元素的含义，所以再考虑使用正确的标签表达内容之前，考虑你的网页看起来怎么样为时过早，请将注意力集中到每一个你使用的HTML标签上。 你需要根据你书写的内容及本文本身的含义，来选择与之匹配的HTML标签。 &lt;!--more--&gt; Structure elements: 组织页面 你可以使用结构元素来组织页面的主要部分，这些部分通常包含其他的HTML元素。 下面是一个典型的网页需要包含的主要部分: &lt;header&gt;作为页面的第一个元素，包含logo和tagline。 &lt;nav&gt;作为跳转到其他不同的页面的超链接集合。 &lt;h1&gt;作为页面的标题。 &lt;article&gt;作为页面的内容模块，比如blog的一个post。 &lt;footer&gt;作为页面的最后一个元素，位于最底部。 Text elements: 定义内容 在结构元素中，通常需要寻找一些文本元素来达到定义内容的目的。 你将主要使用如下标签: &lt;p&gt;作为段落 &lt;ul&gt;作为无序列表 &lt;ol&gt;作为有序列表 &lt;li&gt;作为列表单元 &lt;blockquote&gt;作为引用 Inline elements: 区分文本 因为文本标签通常会很长，并且会有不同的内容，行内元素使你可以将一些关键部分从文本中区分出来。 有很多的行内元素可以使用，但是你会经常用到以下几个: &lt;strong&gt;作为关键字 &lt;em&gt;作为强调字 &lt;a&gt;作为超链接 &lt;small&gt;作为次要字 &lt;abbr&gt;作为缩写 尝试阅读下面的HTML代码，你就可以很容易的理解每一个元素的用途。 1234567891011121314151617181920212223242526&lt;article&gt; &lt;h1&gt;Main title of the page&lt;/h1&gt; &lt;h2&gt;A subtitle&lt;/h2&gt; &lt;p&gt; Something something an other stuff and some &lt;em&gt;emphasis&lt;/em&gt; and even &lt;strong&gt;important&lt;/strong&gt; words. &lt;/p&gt; &lt;p&gt; Another paragraph. &lt;/p&gt; &lt;ul&gt; &lt;li&gt;One&lt;/li&gt; &lt;li&gt;Two&lt;/li&gt; &lt;li&gt;Three&lt;/li&gt; &lt;/ul&gt; &lt;blockquote&gt; Once said &lt;/blockquote&gt;&lt;/article&gt;&lt;aside&gt; &lt;h3&gt;My latest posts&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;One&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;One&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;One&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/aside&gt; Generic elements 演变标签 当没有显而易见的具有语义的标签来匹配相关内容，但你仍然要插入一些标签来达到格式化和分组化的目的，你可以使用一到两个下面的具有演变性的标签: 我理解的演变的意思是这些标签可以通过css样式来变成不同职能的其他标签 &lt;div&gt;作为块级元素组 &lt;span&gt;作为行内元素组 尽管这些标签没有任何的实际意义，但它们与css配合使用将十分有用。 Don’t overthink semantics 不要想太多 大约有100多种语义标签供你使用。如果可以选择合适的元素来使用，那将是十分不错的选择。 但是不要花费太多的事情太考虑这件事，仅仅从现在开始，有选择地使用上面所提供的标签，你的网页将会变得更好。]]></content>
      <categories>
        <category>翻译</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[liferay-portlet-container]]></title>
    <url>%2F2016%2F07%2F26%2Fliferay-portlet-container%2F</url>
    <content type="text"><![CDATA[portlet是portal中最常用的组件了，所以也来山寨一个70版本的portlet container的UI吧。 &lt;!--more--&gt; 唯一花了我不少时间的是，这个对齐的问题，最后才发现，其实只要保证子组件的width+border等于父组件的width就可以了，唉，原谅我的数学是体育老师教的。 除了配色、左上角和右上角的图标以外，相似度应该很高了，就不截原版图啦。]]></content>
      <tags>
        <tag>liferay</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[liferay-progress-bar]]></title>
    <url>%2F2016%2F07%2F22%2Fliferay-progress-bar%2F</url>
    <content type="text"><![CDATA[上次山寨了一个smile face，最近因为一直都在测70，然后就又对70的progress bar起了兴趣。 大体上portal的progress bar就两种，一种是线性的，一种是环形的。 &lt;!--more--&gt; 先来线性的: 线性没有什么困难，值得注意的是，可以使用float属性来模拟一下先向右延伸之后又收缩的效果。 再来环状的: 环状的比线性的复杂一点，在模拟旋转效果的时候，为了使动画效果不存在偏差（虽然这种偏差十分小，正常情况下是不会被肉眼发现的），在设置transform-origin的时候需要将旋转颗粒的半径也考虑进去，因此旋转中心会变成: 1transform-origin: $r/2 50px; 就这样，完了有时间再模拟一些portal其他的动画效果。]]></content>
      <tags>
        <tag>liferay</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[liferay和proxy server那点事]]></title>
    <url>%2F2016%2F07%2F19%2Fliferay-forward-proxy%2F</url>
    <content type="text"><![CDATA[Set up a server to use as a proxy for requests from Liferay (such as Apache web server) &lt;!--more--&gt; 环境 Ubuntu 14.04 httpd(apache2 for Ubuntu) liferay 7.0 知识背景 这里的proxy server应当是指正向代理(forward proxy)。正向代理大概的意思，就是一个位于客户端和原始服务器之间的服务器，当客户端为了从原始服务器拿一些内容的时候，不向原始服务器直接发送请求而是向代理服务器发送，代理服务器转发客户端请求给原始服务器并将获得内容返还给客户端。 正向代理的意思，大体就是一个跳板，对于你不方便去的地方或者不能去的地方，它可以带你去，比如一些vpn代理，其原理就是你访问代理服务器，代理服务器访问被墙的网站，之后把内容返还给你。 既然说了正向代理，就捎带说一下反向代理。反向代理和正向代理相反，对与访问者来说，你访问一个反向代理服务器后，它同样会从原始服务器拿数据，但是这里和正向代理的区别是，访问者不需要进行额外的设置，反向代理服务器判断请求如何转发给原始服务器，之后把内容返还给客户端。 反向代理的意思，大体就是一个服务柜台，对于你不方便去的地方或者不能去的地方，有人可以帮你去，比如一些设置了防火墙的原始服务器为了提供给外网用户访问，就会使用反向代理。 步骤 配置proxy server 以ubuntu为例(windows应该会更方便)，直接用apt-get安装 1sudo apt-get install apache2 之后server的根目录是 1/etc/apache2 进入这里，会发现有一个apache2.conf的配置文件，这个文件是apache2的主要配置文件，其中包含了若干子配置文件，分别配置不同模块的配置，看注释就可以大概知道每个模块是做什么的。 我们这里需要着重看的是ports.conf和000-default.conf。 前者主要设置一些关于server监听端口的配置，它的源码如下 123456789Listen 80&lt;IfModule ssl_module&gt; Listen 443&lt;/IfModule&gt;&lt;IfModule mod_gnutls.c&gt; Listen 443&lt;/IfModule&gt; 大体的意思是 监听80端口，如果有ssl_module和mod_gnutls.c模块加载的话，同时也监听443端口。 如果你还想监听别端口，比如81，可以直接添加 1Listen 81 后者主要设置一些关于虚拟主机的配置，apache2.conf中有一行代码 1IncludeOptional sites-enabled/*.conf 意思是会在启动服务器的时候，把所有**./sites-enabled目录下的配置文件都包含进来，所以我们可以自己新建一个.conf文件，也可以直接更改默认的文件，也就是000-default.conf**。 配置VirtualHost 配置完proxy server的监听端口，该配置虚拟主机了，打开默认配置文件，添加如下代码 1234567891011121314151617181920ProxyRequests OnProxyVia On&lt;VirtualHost *:80&gt; ServerAdmin prograsliu@gmail.com ServerName www.test.com ServerAlias test.com ErrorLog &quot;logs/test.com-error.log&quot; CustomLog &quot;logs/test.com-access.log&quot; common #正向代理设置 ProxyRequests On ProxyVia On &lt;Proxy *&gt; Order deny,allow Deny from all Allow from 127.0.0.1 &lt;/Proxy&gt;&lt;/VirtualHost&gt; 开启Apache正向代理 1ProxyRequests On 之后设置控制位于代理服务器链中的代理请求的流向 1ProxyVia On 每个请求和应答都会对应当前主机得到一个&quot;Via:&quot;头。 再设置对apache监听主机的请求的匹配规则 1&lt;VirtualHost *:80&gt; 这个表示匹配所有80端口的请求，之后又由于这个标签中还有一些其他的设置，如下 1234ServerName www.test.comServerAlias test.comErrorLog &quot;logs/test.com-error.log&quot;CustomLog &quot;logs/test.com-access.log&quot; common 因此，匹配规则会变为，匹配所有请求www.test.com:80这个主机的请求，同时呢，这个主机的小名是test.com，日志文件根据事件类型按不同路径保存。 测试一下 设置到这里，proxy server已经设置完成，因此也可以来简单测试一下，比如打开ＦＦ浏览器，之后在Preference &gt; Advanced &gt; Connection中，选择manual proxy configuration，然后把代理配置填进去，比如 12HTTP proxy: www.test.comPort: 80 注意下面有一个No Proxy for的选项，因此不要拿本地的请求作测试。 然后访问www.163.com，使用f12抓包，可以发现请求的相应头(response header)中，会增加一个字段 1Via: &quot;1.1 www.test.com&quot; 大体意思就是，你打开的163的页面，并不是从网易的浏览器直接获得的，而是从你配置的叫做www.test.com的代理服务器获得的，真正访问网易服务器的是www.test.com。 配置liferay 接下来就很简单了，只需要让liferay来使用我们配置好的proxy server即可。 liferay中的system.properties有如下三个参数， 12345678910# Set the location of the HTTP proxy that the portal will use to fetch# external content.## Set http.nonProxyHosts for hosts that will not be proxied. This is useful# for proxied environments where you need direct access to internal servers.# This should follow the same semantics as the java.net package.##http.proxyHost=192.168.0.200#http.proxyPort=4480#http.nonProxyHosts=192.168.0.250 最后一个不用管，只需要配置前两个，把它改成我们配置的proxy server对应的参数即可，如下 12http.proxyHost=www.test.comhttp.proxyPort=80 之后就大功告成了。当portal从外部的server，获取资源时，会使用代理，比如使用亚马逊的s3 store云储存服务时。 参考 Apache配置正向代理与反向代理]]></content>
      <tags>
        <tag>liferay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[liferay smile face]]></title>
    <url>%2F2016%2F07%2F15%2Fliferay-smile-face%2F</url>
    <content type="text"><![CDATA[说到这个face，自从70开始改版的时候，我就一度以为这个face是歪的，后来才知道，人家就是故意歪的，并且它是一个gif图片，正好最近在学习css相关的东西，借机自己重新仿制一个山寨版的吧。 &lt;!--more--&gt; 原版是这样滴。 然后山寨的是这样滴。 除了这个相比原版的“嘴角上扬”无法破以外，其他基本一致了，如果有大神能有办法改的话，源码在jsbin中。]]></content>
      <tags>
        <tag>liferay</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始]]></title>
    <url>%2F2016%2F06%2F20%2F%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[自从毕业以来，是一直想要建一个博客的，当然我没有什么好炫耀的个人经历又或者牛叉的技术博文，仅仅是想记录一些东西。原先的习惯是，每年会在qq空间中写一篇文章，后来qq被盗了一次，还给我把以前写的东西都删掉了，后来就再写过东西了。 还记的去年还是前年的某一天，突然心血来潮又想写点东西，却发现没有地方写了。正好那段时间对nodejs感兴趣，直接买了本node高级编程就开始撸，虽然后来也没撸出什么成果来，但却可以回答一个问题，就是现在很多人总是问我，怎么学java学的好好地，怎么突然跑去学nodejs了。 &lt;!--more--&gt; 时间过的就是快，这转眼离毕业都将近3年了，其实我当初是想回太原的，结果阴差阳错大连呆了这么长时间，还进了个美国公司，按别人的话说，日子那叫一个悠闲，提前进入老年人生活节奏。要说自由，那确实是，要说悠闲，还是算了，其实有很多事情还是很麻烦的，尤其入了测试这个行业，对于我这种不拘小节的人来说真是哔了狗了。 工作以来，生活一直都是很单调。基本就是处于上班、下班、做饭、写代码、背单词、睡觉，再利用空余时间穿插着练练吉他，仅此而已。我爸总提醒我，自己的事情，是要有个规划的，然而现在我真的有点迷茫了。首先是工作上的很多事情，愉快的不愉快的，都让我改变了对一些事情的看法。 如果有人问我，说你觉你对得起你这3年的时光吗？要我说，我感觉我是浪费了。虽然也做了一些事情，比如减肥啦，看书啦什么的，也蛮有成就感。但这毕竟是生活上的，更多的成就感，依旧来源于工作。我唯一庆幸的是3年来没有因为所做的工作是测试而放弃编程的习惯，假如当初放弃了，也许现在也无法重拾了，确实要承认，这方面在工作上有很大帮助，还记得在很多论坛里，都看见有人问，做测试还需要学编程、懂代码吗？每次我都要怒答，一定要！！ 唉，扯远了，其实这篇的内容是想规划下这个博客主要记录写什么的，总不能什么乱七八糟的都往上写吧。大体想了想，记录一些技术上的分享、经验，业余时间在记录一些生活上的收货，比如弹琴、做饭方面之类的东西，剩余应该都是类似日记的东西了。 总之，这是一个崭新的开始，在这个浮躁的年纪，想要静下心来，做些事情，真的太难了。]]></content>
      <categories>
        <category>其他</category>
        <category>心情</category>
      </categories>
  </entry>
</search>
