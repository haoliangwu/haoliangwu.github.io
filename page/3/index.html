<!DOCTYPE HTML>
<html>
<head >
  <meta charset="utf-8">
  
  <title>Page 3 | Fine, thank you, and you. | 一切安好，感谢有你，与你同行。</title>

  
  <meta name="author" content="Lyon Wu">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Fine, thank you, and you."/>

  
  <meta property="og:image" content="/favicon.ico"/>
  
  <link rel="manifest" href="/manifest.json">
  <link href="/favicon.ico" rel="icon">

  <link rel="alternate" href="/atom.xml" title="Fine, thank you, and you." type="application/atom+xml">
  <link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/base/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">


</head>


  <body>
    <style>
      .loading {
        position: fixed;
        left: 0px;
        top: 0px;
        width: 100%;
        height: 100%;
        z-index: 9999;
        background: url(/images/magic_cube_loading_spinner.gif) center no-repeat #fff;
      }
    </style>
    <div class="loading"></div>
    <div class="blog">
      <div class="content">

        

    <header class="header-container" style="background-image: url('/images/blog-bg.jpg');">


<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <div class="navbar-header page-scroll">
          <button type="button" id="tglBtn" class="navbar-toggle">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">Lyon Wu</a>
        </div>
        <div id="bosenyblog-navbar">
          <div class="navbar-collapse" id="bs-example-navbar-collapse-6">
            <ul class="nav navbar-nav navbar-right">
            
              <li><a href="/">Home</a></li>
            
              <li><a href="/archives">Archives</a></li>
            
            </ul>
          </div>
        </div>

    </div>
 </nav>
 <div class="gotop-btn">

 </div>
</header>

          
            <div class="container ">
              <div class="row">
                <main class="site-main posts-loop    col-lg-8 col-lg-offset-1
                    col-md-8 col-md-offset-1
                    col-sm-12
                    col-xs-12">
                  
  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2017/04/24/es6中的混合器模式/"><span>es6中的混合器模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/04/24/es6中的混合器模式/" rel="bookmark">
        <time class="entry-date published" datetime="2017-04-24T00:48:12.000Z">
          2017-04-24
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
      
          <p>这是有关设计模式相关的第一篇文章，谈及设计模式，一般情况下呢，很多人马上就会说出很多关于它的东西，比如单例模式、策略模式等等。对于各个技术栈的工程师们，各种设计模式应该再熟悉不过，这篇文章要分享的是关于前端中的混合器模式，也可以称作装饰器模式，并分享一些在实际开发中的应用。</p>
<p>在面向对象的开发中，实际业务的描述是通过<code>类(Class)</code>来进行描述的，如果想给一个已经存在的类扩展某些行为（如增加某个方法、某个属性等），可以通过<code>类的继承</code>来实现，即将可复用、可扩展的方法抽象为父类中的方法之后继承它。</p>
<p>但是思考一下，这种做法的弊端：</p>
<ul>
<li>类的继承所扩展的方法或属性是静态的，既你无法为一个已有的类的实例扩展某些方法。</li>
<li>类的继承会继承父类中的所有可继承的方法和属性，但是你只想继承其中的某个或某几个方法。</li>
</ul>
<p>在es6中，加入了<code>装饰器(Decorator)</code>语法，提供了对于装饰器模式的原生支持。这里对于语法不再进行详细的阐述，可以点击<a href="http://es6.ruanyifeng.com/#docs/decorator#类的修饰" target="_blank" rel="noopener">这里</a>进行了解或学习。</p>
<p>在这种模式下，我们可以动态的来为一个类增加某个方法或属性，你可能会问，这样听起来似乎和继承没什么不同？你错了，它的优势体现在<code>动态</code>二字，其含义即为可以动态的为类的实例增加某种行为，也许你又会说，在js中，它本身就是动态语言，这种动态性也失去了优势了吧。</p>
<p>是的，但是在js中想要实现继承绝非易事，因为它的继承机制是通过原型链进行描述的，对于js新手的话，理解起来其实是有点晦涩的，有些时候我们仅仅想通过更清晰的手段使用另一个类中的某些方法。</p>
<p>举个例子，在SPA开发中，经常会遇到处理分页数据的需求，对于分页逻辑的处理，很显然是一块需要抽象为公共方法的逻辑，但是如果你按继承的角度去考虑，就会发现，有些时候你继承了这些处理分页逻辑的方法反而是多余了，因为并不是每个页面都需要分页，这种情况下，使用混合器模式来实现则可以更好的解决问题。</p>
<p>我们先来实现一个分页逻辑的混合器，它其实是个函数，函数的参数是一个类，之后会动态的在这个类上增加一些方法，从而达到在<strong>一个类中混入另一个类的某些方法的目的</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export const PaginationMixin = (superClass) =&gt; class extends superClass &#123;</span><br><span class="line">  nextPage (url, callback) &#123;</span><br><span class="line">    this.handlePaginationResolve(url, callback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  previousPage (url, callback) &#123;</span><br><span class="line">    this.handlePaginationResolve(url, callback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handlePaginationResolve (url, callback) &#123;</span><br><span class="line">    if (!url) return</span><br><span class="line"></span><br><span class="line">    customAPIComposer(url, &apos;get&apos;).then(callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后，只需要按如下进行代码，对需要扩展的类进行扩展，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class AttendanceManageCtrl extends PaginationMixin(MixinBase)</span><br></pre></td></tr></table></figure></p>
<p>扩展后就可以使用混合器中混入的方法了，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;oa-list-table list-data=&apos;$ctrl.listData&apos; on-next=&apos;$ctrl.nextPage($ctrl.listData.next, $ctrl.render)&apos; on-previous=&apos;$ctrl.previousPage($ctrl.listData.previous, $ctrl.render)&apos;&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样做似乎和继承没什么区别，但是不妨看看如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class PeopleCtrl extends R.compose(PaginationMixin, StateManageMixin)(MixinBase)</span><br></pre></td></tr></table></figure></p>
<p>没错，你可以对一个类同时使用多个混合器，但是你却无法使一个类同时继承与多个类，虽然你可以通过多重继承实现，但显然比前者繁琐很多。</p>
<p>尽情混入吧。</p>

      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/原创/">原创</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/js/">js</a><a href="/tags/es6/">es6</a>
    </span>
    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2017/04/24/es6中的混合器模式/"><span>more</span></a></h3>
    
  
</article>





  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2017/02/07/codereview-s8/"><span>codereview-s8</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/02/07/codereview-s8/" rel="bookmark">
        <time class="entry-date published" datetime="2017-02-07T02:02:05.000Z">
          2017-02-07
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
      
          <h2 id="当元素间存在父子关系时，留意事件冒泡机制所引发的连锁反应"><a href="#当元素间存在父子关系时，留意事件冒泡机制所引发的连锁反应" class="headerlink" title="当元素间存在父子关系时，留意事件冒泡机制所引发的连锁反应"></a>当元素间存在父子关系时，留意事件冒泡机制所引发的连锁反应</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr style=&quot;cursor: pointer;&quot; ng-repeat=&quot;row in $ctrl.efficiencyTable.bodyData&quot; ng-click=&quot;$ctrl.stepView(row)&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;td class=&quot;text-left&quot;&gt;</span><br><span class="line">        &lt;a ng-click=&quot;$ctrl.efficiencyView(row)&quot; class=&quot;hover-link&quot;&gt;查看流程&lt;/a&gt;</span><br><span class="line">    &lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>a元素的点击事件会<code>efficiencyView</code>方法，但因为事件冒泡机制，也会间接的调用<code>stepView</code>方法</p>
</blockquote>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><blockquote>
<p>angular中可以使用内置的 $event 对象来解决相应问题</p>
</blockquote>
<p>首先声明使用<code>$event</code>对象并传参<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a ng-click=&quot;$ctrl.efficiencyView(row, $event)&quot; class=&quot;hover-link&quot;&gt;查看流程&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<p>之后再<code>efficiencyView</code>方法中调用<code>stopPropagation</code>方法阻止事件冒泡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">efficiencyView (workflow, $event) &#123;</span><br><span class="line">    ...</span><br><span class="line">    $event.stopPropagation()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以对比<code>$event</code>对象中的<code>target</code>和<code>currentTarget</code>属性是否相同，因为这两个属性分别代表触发事件的dom节点与响应事件的当前节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if($event.target === $event.currentTarget) ...</span><br></pre></td></tr></table></figure></p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">EventTarget.addEventListener 方法及其参数的含义</a></li>
<li><a href="http://blog.csdn.net/luanlouis/article/details/23927347" target="_blank" rel="noopener">解析Javascript事件冒泡机制</a></li>
</ul>
<h2 id="z-index-常见问题"><a href="#z-index-常见问题" class="headerlink" title="z-index 常见问题"></a>z-index 常见问题</h2><p>关于<code>z-index</code>本身用法我是了解的，但是最近在做下拉框组件和datepicker时，踩了一些坑，如下：</p>
<ul>
<li>只有设置了<code>position</code>属性的元素的<code>z-index</code>才会生效</li>
<li>当父容器的<code>z-index</code>小于元素A时，其子容器的<code>z-index</code>无论多大都无法覆盖元素A</li>
</ul>
<h3 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>实现具有下拉菜单展开特效的组件时，一般会套用一下结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;dropdown-wrapper&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;dropdown-toggle&quot;&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;dropdown-list&quot;&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>当两个下拉菜单处于垂直布局时，如果没有设置<code>z-index</code>属性，因为<code>dropdown-toggle</code>比<code>dropdown-list</code>先出现，因此默认的图层顺序是前者高于后者，所以当上面的下拉菜单出现的时候，并不会覆盖下面的<code>toggle</code>,为了解决这个问题，必须做如下处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.dropdown-list&#123;</span><br><span class="line">    ...</span><br><span class="line">    z-index: 1000;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后附上<a href="https://jsbin.com/suyojovino/edit?html,css,output" target="_blank" rel="noopener">DEMO</a></p>
<h3 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><a href="https://css-tricks.com/almanac/properties/z/z-index/" target="_blank" rel="noopener">z-index</a></li>
</ul>
<h2 id="对表格中的单元格增加一个hover高亮效果"><a href="#对表格中的单元格增加一个hover高亮效果" class="headerlink" title="对表格中的单元格增加一个hover高亮效果"></a>对表格中的单元格增加一个hover高亮效果</h2><p>对于表格中<code>td</code>增加<code>hover</code>高亮时可能会遇到一个问题，就是当你使用常规的<code>border</code>属性对边框进行设置时，可能会发现，每个单元格的上边框和左边框都没有达到理想的效果，但是下边框和右边框却是正常的。<br>这种问题会出现在对<code>table</code>增加<code>border-collapse: collapse</code>属性或是引用一些第三方的css库，比如bootstrap，具体现象参考<a href="https://jsbin.com/hivukumosu/edit?html,css,output" target="_blank" rel="noopener">DEMO</a>。</p>
<h3 id="最佳实践-2"><a href="#最佳实践-2" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>解决方法其实很简单，就是将<code>td</code>边框的样式从<code>solid</code>改为<code>double</code>，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table tr td &#123;</span><br><span class="line">    border-style: double;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原因如下：</p>
<blockquote>
<p>Since double is “more distinct” then solid, its colour takes precedence over cells around it, and looks identical to solid anyway ;)</p>
</blockquote>
<h3 id="扩展-2"><a href="#扩展-2" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-style" target="_blank" rel="noopener">border-style各属性值及赋值语法</a></li>
</ul>
<h2 id="angular中遭遇的一个奇葩问题"><a href="#angular中遭遇的一个奇葩问题" class="headerlink" title="angular中遭遇的一个奇葩问题"></a>angular中遭遇的一个奇葩<a href="https://github.com/angular/angular.js/issues/4558" target="_blank" rel="noopener">问题</a></h2><p>这个问题是我在本期开发排班器组件时遇到的一个很奇葩的问题，大体描述就是如上面github链接中描述的一样，就是当父组件的一个数据采用双向绑定时，并且需要已事件回调的方法更新其内部的某个属性值，然后使用签名为<code>onChange</code>的<code>scope</code>属性传给子组件，比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scope:&#123;</span><br><span class="line">    ...</span><br><span class="line">    onChange: &apos;&amp;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么这个<code>onChange</code>的调用在父组件进行更新某条以双向绑定方式进行绑定的属性时，会先于子组件的更新前自动调用，这么说有点抽象，大体的问题我简单描述下。</p>
<p>本来<code>onChange</code>的调用时机应当是自下而上的，也就是当子组件发生更新时，调用父组件通过<code>onChange</code>属性传递的事件回调方法，这个方法会更具子组件的当前状态来对父组件进行更新，这就是理想中的单向数据流子组件通知父组件进行更新的机制。但是在angular中遇到的奇葩现象现象就是，在父组件进行更新时，不知道是因为签名的缘故还是双向绑定的缘故，这个<code>onChange</code>都会先于子组件运行一次，那么问题来了，这个方法本来的调用时机是子组件更新后需要通知父组件进行相应更新时调用的，然而现在子组件还未更新则先调用了该方法，那么回调函数中的参数必为空，除非<code>onChange</code>中加入了空校验代码，不然就会报错，其实加了空校验也没有什么意义，因为这个方法都会调用的，但是却不会进行任何的改变，相当于浪费了一部分性能。</p>
<h3 id="最佳实践-3"><a href="#最佳实践-3" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>解决方法在<a href="http://plnkr.co/edit/fs7S6yX1a5aeo1Ese522?p=preview" target="_blank" rel="noopener">这里</a>，这种解决方法算是一种<code>workaround</code>，即在组件中使用另一个对象来储存父组件需要更新的那个值，算是做了一种类似中间件的处理，之后因为双向绑定自动更新机制对于对象的更新时更具<code>reference</code>来进行的，那么在父组件或子组件中对于这一个数据的引用均是相同的，而不会像基本数据类型存在一个新旧值的差异，不过这终究是一个<code>workaround</code>。</p>
<h2 id="限制上传文件的类型"><a href="#限制上传文件的类型" class="headerlink" title="限制上传文件的类型"></a>限制上传文件的类型</h2><p>现在通过<code>type</code>为文件类型的<code>input</code>上传文件已经很普遍了，并且对于表单的校验，通常我们会在提交时进行，文件类型的表单也不例外，一般校验的内容有文件大小、文件类型（扩展名）等等。今天遇到一个需求很有意思，大体意思是想在用户进行文件上传时，就有偏向性的屏蔽掉一些不支持的文件格式，比如上传图片，那么在文件选择对话框就不要出现文本类型的文件。</p>
<p>这个问题我一开始是不知道怎么解决的，因为浏览器对于操作系统是一个沙盒，因此对于文件显示的控制应当没有权限控制，去网上google了下，答案也是这样的，没有方式可以实现百分之百屏蔽某种文件类型的方式。但是却发现了另一个很有意思的属性，也可以达到类型的效果。</p>
<p>这个属性就是<code>input</code>标签的<code>accept</code>属性：</p>
<blockquote>
<p>If the value of the type attribute is file, then this attribute will indicate the types of files that the server accepts, otherwise it will be ignored. The value must be a comma-separated list of unique content type specifiers:</p>
</blockquote>
<p>它可以接受的值的描述：</p>
<ul>
<li>A file extension starting with the STOP character (U+002E). (e.g. .jpg, .png, .doc).</li>
<li>A valid MIME type with no extensions.</li>
<li>audio/* representing sound files. HTML5</li>
<li>video/* representing video files. HTML5</li>
<li>image/* representing image files. HTML5</li>
</ul>
<h3 id="最佳实践-4"><a href="#最佳实践-4" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>比如我们想要限制上传文件类型为excel文件类型，只需要创建如下标签:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;file&quot; accept=&quot;.xls,.xlsx&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样这个文件表单对话框被激活时，默认会选取以.xls和.xlsx结尾的文件。</p>
<p>虽然这个属性可以达到类似的效果，但是是无法完全替代对于文件扩展名的校验的。因为只要用户想要上传别的类型的文件，通过切换文件对话框中的选取文件类型选项（比如显示全部文件类型），就可以选取别的类型的文件了，因此在提交时，也别忘了添加校验逻辑，防止因为上传了一些不支持的类型造成服务器内部错误。</p>
<h3 id="扩展-3"><a href="#扩展-3" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input" target="_blank" rel="noopener">input</a></li>
</ul>

      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/js/">js</a>
    </span>
    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2017/02/07/codereview-s8/"><span>more</span></a></h3>
    
  
</article>





  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2016/11/28/async-for-js/"><span>async-for-js</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/11/28/async-for-js/" rel="bookmark">
        <time class="entry-date published" datetime="2016-11-28T01:16:51.000Z">
          2016-11-28
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
      
          <p>介绍关于js开发中所涉及的主流异步编程解决方案</p>
<blockquote>
<p>repo: <a href="https://github.com/haoliangwu/todoMVCs/tree/master/async-for-js" target="_blank" rel="noopener">async-for-js</a></p>
</blockquote>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>插入3个div元素，其中第二个div元素使用<code>setTimeout</code>模拟异步操作，理想的插入顺序为div1 div2 div3，但这里的代码的插入顺序为div1 div3 div2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// async way</span><br><span class="line">function _async() &#123;</span><br><span class="line">  document.body.appendChild(div1)</span><br><span class="line"></span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    document.body.appendChild(div2)</span><br><span class="line">  &#125;, 2000)</span><br><span class="line"></span><br><span class="line">  document.body.appendChild(div3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_async()</span><br></pre></td></tr></table></figure></p>
<h2 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h2><p>最常用的方法是利用<code>callback</code>(回调函数)的方式，因为js中函数也是作为对象存在的，因此可以被当做参数传入另一个函数中，只需要在异步操作执行代码后调用回调函数即可。</p>
<p>但是使用回调函数有很明显的局限性，一方面体现在需要自己对异步操作进行控制，另一方面还很容易陷入”回调地狱”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// use plain callback to sync</span><br><span class="line">function _callback(cb) &#123;</span><br><span class="line">  document.body.appendChild(div1)</span><br><span class="line"></span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    document.body.appendChild(div2)</span><br><span class="line">    cb(&apos;done&apos;)</span><br><span class="line">  &#125;, 2000)</span><br><span class="line"></span><br><span class="line">  return &apos;done&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_callback(function () &#123;</span><br><span class="line">  document.body.appendChild(div3)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>因为回调地狱的问题，后来聪明的人使用将回调延迟执行的思想，从而发明了promise库，调用者可以根据异步流程随心所欲的resolve或reject某个值给之后的操作，从而解决了毁掉地狱的问题。</p>
<p>不过使用promise仍然有问题，就是当代码逻辑很长的时候，总需要带着大片大片的<code>then</code>方法，可读性仍然不够清晰。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// use promise to sync</span><br><span class="line">function _promise() &#123;</span><br><span class="line">  document.body.appendChild(div1)</span><br><span class="line"></span><br><span class="line">  return new Promise(res =&gt; &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      document.body.appendChild(div2)</span><br><span class="line">      res(&apos;done&apos;)</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_promise().then(data =&gt; &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">  document.body.appendChild(div3)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="Generate"><a href="#Generate" class="headerlink" title="Generate"></a>Generate</h2><p>后来promise加入了es6标准，同时推出了新的异步解决方案，叫做generate函数，大体讲是提供了一个具有状态机功能的函数，每次执行会停止在实现者声明的某个状态，下次调用会继续从这个状态开始执行。</p>
<p>generate的出现，使必须依靠<code>callback</code>实现异步操作的代码风格，可以使用同步代码风格实现，是一颗非常甜的语法糖。</p>
<p>但是它仍有有一些缺点，就是它作为状态机，无法自执行，必须借助实现一个run函数或使用第三方库(如<code>co</code>)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// use generate to sync</span><br><span class="line">function* _generate() &#123;</span><br><span class="line">  document.body.appendChild(div1)</span><br><span class="line"></span><br><span class="line">  yield function (cb) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      document.body.appendChild(div2)</span><br><span class="line">      cb()</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  document.body.appendChild(div3)</span><br><span class="line"></span><br><span class="line">  return &apos;done&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function run(fn) &#123;</span><br><span class="line">  var gen = fn()</span><br><span class="line"></span><br><span class="line">  function next(data) &#123;</span><br><span class="line">    var result = gen.next(data)</span><br><span class="line"></span><br><span class="line">    console.log(result.value)</span><br><span class="line"></span><br><span class="line">    if (result.done) return</span><br><span class="line"></span><br><span class="line">    result.value(next)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(_generate)</span><br></pre></td></tr></table></figure>
<h2 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h2><p>为了解决generate的缺点，es7很快发布了继generate更强大的一个东西，叫做async函数。简单说，它并没有什么新特性，把它看做是可以自执行的generate函数即可，其中的await的操作符可以看做是yield操作符的翻版。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// use async/await and promise to sync</span><br><span class="line">const fn = function () &#123;</span><br><span class="line">  return new Promise(res =&gt; &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      res(document.body.appendChild(div2))</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function _await () &#123;</span><br><span class="line">  document.body.appendChild(div1)</span><br><span class="line">  const f = await fn()</span><br><span class="line">  console.log(f)</span><br><span class="line">  document.body.appendChild(div3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_await()</span><br></pre></td></tr></table></figure>
<h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><p>最近很火的rxjs也快成用来解决这个问题，详细的介绍可以去它的<a href="http://reactivex.io/rxjs/manual/overview.html" target="_blank" rel="noopener">官网</a>了解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// use rxjs and callback to sync</span><br><span class="line">const _callbackObservable = Observable.bindCallback(_callback)</span><br><span class="line">const result = _callbackObservable()</span><br><span class="line"></span><br><span class="line">// result.subscribe(x =&gt; &#123;</span><br><span class="line">//   document.body.appendChild(div3)</span><br><span class="line">//   console.log(x)</span><br><span class="line">// &#125;)</span><br></pre></td></tr></table></figure>
      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/翻译/">翻译</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/js/">js</a>
    </span>
    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2016/11/28/async-for-js/"><span>more</span></a></h3>
    
  
</article>





  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2016/10/14/当开发一周了/"><span>当开发一周了</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/10/14/当开发一周了/" rel="bookmark">
        <time class="entry-date published" datetime="2016-10-14T07:00:09.000Z">
          2016-10-14
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
         
        <p>转行做前端开发正好一周了，仔细一想，是真正意义上的一周呀，因为连上了7天班了。</p>
<p>说到感觉如何，我只能说，那是太好了。自从来了新公司，心情一下就变好了，回想这半年来，一直因为一些事情闷闷不乐，我也是蛮能拼的。不过总体工作还是比较忙，因为正好赶上项目要发布的最后一周，而且前端组的好多工作似乎还堆积了，不过好在最后也是按时完成了任务。</p>
      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/心情/">心情</a>
    </span>
    

    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2016/10/14/当开发一周了/"><span>more</span></a></h3>
    
  
</article>





  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2016/09/26/我为什么离开了Liferay/"><span>我为什么选择离开了Liferay</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/09/26/我为什么离开了Liferay/" rel="bookmark">
        <time class="entry-date published" datetime="2016-09-26T06:21:15.000Z">
          2016-09-26
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
         
        <p>距离离开Liferay还剩下用指头可以数出来的日子了，心中不禁感慨万千。这一个月除了做一些交接工作和下一份工作的准备意外，剩下的时间基本都在思考在Liferay的两年半时间我到底得到了什么，又留下了什么？仔细想想，好像没留下什么，至于得到的，确是很多的，毕竟这是我毕业步入社会进入的第一家公司，很多事情从未知到已知都是从这里开始。</p>
<p>在这里认识了不少人，我从他们身上都学到了很多很多，不经意间也帮助了我很多很多，我衷心说声谢谢，同时我也想说，对于我的离职我只想说，离别是为了下次更好的相遇。</p>
<p>不过写这篇的目的并不是为了怀旧，只是最近稍微熟悉点儿的人都在问我一个问题，“你为什么离职？”。这个问题，我从有离职想法的那天，到念头一点点变大，再到最后做出离职的决定，我已经问过自己无数次了。细说起来，大大小小的原因有很多，不过大体概括也就两点，一，我无法得到我想要的，二，Liferay同时也并不需要我这样的人，仅此而已，所以我选择离开。</p>
<p>这里直接说Liferay好像扣上了一个很大的帽子，好吧，这里只是说中国这边的Liferay，后边不特殊说明均指代Liferay CN，如果再具体些，可以指代Liferay CNQA。</p>
      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/心情/">心情</a>
    </span>
    

    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2016/09/26/我为什么离开了Liferay/"><span>more</span></a></h3>
    
  
</article>





  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2016/09/21/vscode-typings配置/"><span>vscode typings配置</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/09/21/vscode-typings配置/" rel="bookmark">
        <time class="entry-date published" datetime="2016-09-21T07:33:31.000Z">
          2016-09-21
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
         
        <p>vscode发布至今已经到1.5.2了，我是从1.1开始用的，经历了几个改动比较大的版本。总体给我的感觉还是很好的，作为一个rich editor，能够提供像webstorm之类ide的代码提示功能非常赞，但是对于这块的配置还真没折腾过，只知道它的提示是基于ts的compiler提供的，虽然是ts提供的，但是js作为ts的编译对象，同样可以享受这个compiler提供的便利。</p>
      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/原创/">原创</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/js/">js</a>
    </span>
    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2016/09/21/vscode-typings配置/"><span>more</span></a></h3>
    
  
</article>





  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2016/08/22/interview-record-20160822/"><span>interview record 20160822</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/08/22/interview-record-20160822/" rel="bookmark">
        <time class="entry-date published" datetime="2016-08-22T09:12:41.000Z">
          2016-08-22
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
         
        <h2 id="面试公司"><a href="#面试公司" class="headerlink" title="面试公司"></a>面试公司</h2><p>大连云匠软件</p>
      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/心情/">心情</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/html/">html</a><a href="/tags/interview/">interview</a><a href="/tags/css/">css</a>
    </span>
    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2016/08/22/interview-record-20160822/"><span>more</span></a></h3>
    
  
</article>





  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2016/08/10/HTML-is-about-meaning/"><span>HTML is about meaning</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/08/10/HTML-is-about-meaning/" rel="bookmark">
        <time class="entry-date published" datetime="2016-08-10T05:05:39.000Z">
          2016-08-10
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
         
        <blockquote>
<p>原文地址: <a href="http://marksheet.io/html-semantics.html" target="_blank" rel="noopener">http://marksheet.io/html-semantics.html</a></p>
</blockquote>
<p>HTML标签本身的意义是为了传递对于一个document元素的含义，所以再考虑使用正确的标签表达内容之前，考虑你的网页看起来怎么样为时过早，请将注意力集中到每一个你使用的HTML标签上。</p>
<p>你需要根据你书写的内容及本文本身的含义，来选择与之匹配的HTML标签。</p>
      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/翻译/">翻译</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/html/">html</a>
    </span>
    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2016/08/10/HTML-is-about-meaning/"><span>more</span></a></h3>
    
  
</article>





  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2016/07/26/liferay-portlet-container/"><span>liferay-portlet-container</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/07/26/liferay-portlet-container/" rel="bookmark">
        <time class="entry-date published" datetime="2016-07-26T09:44:46.000Z">
          2016-07-26
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
         
        <p>portlet是portal中最常用的组件了，所以也来山寨一个70版本的portlet container的UI吧。</p>
      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/css/">css</a><a href="/tags/liferay/">liferay</a>
    </span>
    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2016/07/26/liferay-portlet-container/"><span>more</span></a></h3>
    
  
</article>





  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2016/07/22/liferay-progress-bar/"><span>liferay-progress-bar</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/07/22/liferay-progress-bar/" rel="bookmark">
        <time class="entry-date published" datetime="2016-07-22T08:44:55.000Z">
          2016-07-22
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
         
        <p>上次山寨了一个smile face，最近因为一直都在测70，然后就又对70的progress bar起了兴趣。</p>
<p>大体上portal的progress bar就两种，一种是线性的，一种是环形的。</p>
      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/css/">css</a><a href="/tags/liferay/">liferay</a>
    </span>
    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2016/07/22/liferay-progress-bar/"><span>more</span></a></h3>
    
  
</article>






<nav class="pagination">
  
  <a href="/page/2/" class="pagination-prev">Prev</a>
  
  
  <a href="/page/4/" class="pagination-next">Next</a>
  
</nav>
                </main>
                <div class="sidebar
                    col-lg-3 col-lg-offset-0
                    col-md-3 col-md-offset-0
                    col-sm-12
                    col-xs-12
                    sidebar-container
                ">

                  <div class="sidebar-container">



<div class="search-container">
<form class="site-search-form">
    <span class="glyphicon glyphicon-search"></span><input type="text" id="local-search-input" class="st-search-input" placeholder="Search..." />
</form>
<div id="local-search-result" class="local-search-result-cls"></div>
</div>
<script type="text/javascript" id="local.search.active">
var inputArea       = document.querySelector("#local-search-input");
inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script>




    <div class="categories-container" style="margin-top:40px;">
        <p>归档:</p>
            
                <a href="/categories/原创/" title="原创" rel="7">原创</a>
            
                <a href="/categories/心情/" title="心情" rel="4">心情</a>
            
                <a href="/categories/源码分析/" title="源码分析" rel="1">源码分析</a>
            
                <a href="/categories/翻译/" title="翻译" rel="15">翻译</a>
            
    </div>




    <div class="social-container" style="margin-top:40px;">
        <p>Links:</p>
            
                
                    <li class="social-item"><i class="fa fa-fw fa-github"></i><a href="https://github.com/haoliangwu">GitHub</a></li>
                
            
                
                    <li class="social-item"><i class=" fa fa-fw zhihu-icon"></i><a href="https://www.zhihu.com/people/wu-hao-liang-81/activities">知乎</a></li>
                
            
                
                    <li class="social-item"><i class="fa fa-fw fa-sf"></i><a href="https://segmentfault.com/u/littlelyon">SegmentFault</a></li>
                
            
    </div>

</div>
                </div>
              </div>
            </div>
            





                <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/BosenY/Lap" target="_blank">Lap</a>
    <br/><span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>
    </br>
    
      
        &copy; 2018 Lyon Wu
      
    
  </p>
</footer>
                  
      </div>

    </div>
    <script>
      window.onload = function () {
        document.querySelector('.loading').remove()
      }
    </script>
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <script src="https://cdn.bootcss.com/vue/2.5.13/vue.min.js"></script>
    <script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
    <script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
      crossorigin="anonymous"></script>
    <script src="/js/index.js"></script>
    <script src="/js/search.js"></script>

  </body>

</html>