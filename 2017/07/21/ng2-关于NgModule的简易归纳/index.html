<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 从ng1看ng2 关于NgModule的简易归纳 · Fine, thank you, and you.</title><meta name="description" content="从ng1看ng2 关于NgModule的简易归纳 - Lyon Wu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><link rel="stylesheet" href="/css/apollo.css"><script src="//cdn.bootcss.com/html5shiv/r29/html5.js"></script></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.ico"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/pages/" target="_self" class="nav-list-link"><i class="fa fa-bookmark">&nbsp;</i>Pages</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link"><i class="fa fa-folder-open-o">&nbsp;</i>Archive</a></li><li class="nav-list-item"><a href="https://github.com/haoliangwu" target="_self" class="nav-list-link"><i class="fa fa-github-alt">&nbsp;</i>GitHub</a></li><li class="nav-list-item"><a href="http://littlelyon.com/resume/" target="_self" class="nav-list-link"><i class="fa fa-info">&nbsp;</i>About</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">从ng1看ng2 关于NgModule的简易归纳</h1><div class="post-info">Jul 21, 2017</div><div class="post-content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近开始折腾<a href="https://angular.io/" target="_blank" rel="external">ng2</a>，其实说是ng2，到目前为止，它已经发布了4.3版，就是这么的高产，高产似<em>*，我连2都还木有完整的看完它竟然发布了4.</em>的版本（鄙视脸）。</p>
<p>不过话说回来，之前工作不忙的时候，想看看ng2的东西，我的天，又是ts，又是observable的，吓的我硬是没有上来就直接去看它的入门文档，而是买了本typescript的入门开始看，后来书看了一半，工作又忙了，就想着可否重构历史代码加顺带学习rxjs的姿势去做需求，后来我也是这么做的，庆幸的是，这么做效果是挺好的，不仅实际开发效率高了不少，同时也入门了rxjs。</p>
<p>最近工作又闲了下来，就想着赶紧带着半吊子的ts和rxjs水平看看ng2的文档吧，虽然ng2在国内似乎热度不如react和vue流行，但是在全世界还是劲头还是比较强劲的，毕竟有谷歌爸爸和微软爸爸做东，强强联合。</p>
<p>而且我是个遵守规则的人，一向喜欢大而全的东西，ng这种框架我觉的真的是很对我的胃口。不过这ng2的文档不看不要紧，一看真的是有些蛋疼，随便看个啥，连码代码加理解，估计一下午也就能看一个简单的概念，就比如今天想归纳的<code>NgModule</code>这部分东西，前后大概有30几页的东西，所以我觉的如果不写点东西总结一下，必然是看了就忘，忘了再看的节奏。</p>
<h2 id="ng1中的module回顾"><a href="#ng1中的module回顾" class="headerlink" title="ng1中的module回顾"></a>ng1中的module回顾</h2><p>其实熟悉ng1的话，对于这ng2中的module的理解是很有帮助的。从ng1开始，就一直再提倡一个module的概念，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">angular.module(&apos;baz&apos;, [])</div><div class="line">angular.module(&apos;bar&apos;, [])</div><div class="line">angular.module(&apos;foo&apos;, [&apos;bar&apos;, &apos;baz&apos;])</div><div class="line">       .factory(&apos;fooFactory&apos;, function()&#123; ... &#125;)</div><div class="line">       .service(&apos;fooService&apos;, function()&#123; ... &#125;)</div><div class="line">       .component(&apos;fooComponent1&apos;, &#123; ... &#125;)</div><div class="line">       .directive(&apos;fooDirective&apos;, function()&#123; ... &#125;)</div></pre></td></tr></table></figure></p>
<p>这么的我就分别声明了<code>foo</code>、<code>bar</code>和<code>baz</code>的module，同时<code>foo</code>依赖于<code>baz</code>和<code>bar</code>，然后就没有然后了，之后你就可以在这个这些module中做一切你想做的任何事情。通过这种module的划分，我们可以在各个维度中，抽象我们的代码，比如从业务上、从代码类别上等等。</p>
<h2 id="ng2中的module简述"><a href="#ng2中的module简述" class="headerlink" title="ng2中的module简述"></a>ng2中的module简述</h2><p>ng2将这种概念更推进了一步，虽然我们可以使用module的方法来改变我们编程的思维，但是代码本身并不具有module的含义，这么说可能有点难理解，举个例子，就上面的例子，对于<code>bar</code>和<code>baz</code>模块，我们很难简单的从代码层面来区分它们分别的职能是什么。因此ng2改用了以<a href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841#.x5c2ndtx0" target="_blank" rel="external">Decorator</a>的方式来使代码具有语意性，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@NgModule(&#123;</div><div class="line">  imports:      [ ... ],</div><div class="line">  declarations: [ ... ],</div><div class="line">  providers:    [ ... ],</div><div class="line">  exports:      [ ... ]</div><div class="line">&#125;)</div><div class="line">export class FooModule &#123; &#125;</div></pre></td></tr></table></figure></p>
<p>通过<code>NgModule</code>这个装饰器来对一个class进行描述。如果直接和ng1对比的话，装饰器的参数对象中的几个属性分别对应ng1中的：</p>
<ul>
<li><code>imports</code>: 对应ng1声明中的模块依赖数组<code>[&#39;bar&#39;, &#39;baz&#39;]</code>，进行一些依赖模块的声明</li>
<li><code>declarations</code>: 对应ng1中的<code>.component(&#39;fooComponent1&#39;, { ... })</code>和<code>.directive(&#39;fooDirective&#39;, function(){ ... })</code>，进行一些声明式类的声明</li>
<li><code>providers</code>: 对应ng1中的<code>.service(&#39;fooService&#39;, function(){ ... })</code>和<code>.factory(&#39;fooFactory&#39;, function(){ ... })</code>，进行一些服务类的声明</li>
<li><code>exports</code>: ng1中没有独立的exports语法，因此不做对比，在ng1中只有依赖模块中提供的服务、模块，加载模块均可使用。</li>
</ul>
<h2 id="ng2中module分类"><a href="#ng2中module分类" class="headerlink" title="ng2中module分类"></a>ng2中module分类</h2><p>ng2对不同的module提供了不同的语意性描述方式，可以通过装饰器属性来描述它们。</p>
<h3 id="root-module（根模块）"><a href="#root-module（根模块）" class="headerlink" title="root-module（根模块）"></a>root-module（根模块）</h3><p>所谓根模块，即一个应用的最上层的模块，即应用的入口模块，有时候也会称作app-module（这也是文档中指出的最佳实践）。这个概念在ng1中同样有，但是和上面指出的问题一样，就是没有代码层面的语意性描述，为了更好的描述它，ng2中的root-module会提供额外的装饰器属性来修饰它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@NgModule(&#123;</div><div class="line">  ...,</div><div class="line">  bootstrap:      [ ... ]</div><div class="line">&#125;)</div><div class="line">export class AppModule &#123; &#125;</div></pre></td></tr></table></figure></p>
<p>这个<code>bootstrap</code>代表这个模块会在应用初始化阶段被引导和加载，一般来讲，ng2都会有一个独立的<code>main.ts</code>文件来引导加载根模块，这个过程对于根模块是透明的，因为它并不知道它如何被加载，有可能是在浏览器加载，有可能是在移动端加载等等，有可能使用JIT做动态加载，有可能提前编译好做静态加载，这些都是未知的，它仅仅需要表达的是，这个模块是可被引导加载的。通常情况下，一个应用只有一个root-module（这不是废话吗），但是在一些大型的应用中，可能会存在多个独立的子项目，那么就有可能存在多个root-module。</p>
<h3 id="sub-module（子模块）"><a href="#sub-module（子模块）" class="headerlink" title="sub-module（子模块）"></a>sub-module（子模块）</h3><p>所谓子模块，即一个应用从属于根模块的模块，即应用按各个维度划分形成的颗粒，比如从功能划分、代码架构划分等等，有时候也会称作feature-module（这也是文档中指出的最佳实践），ng1同样无法在代码层面进行语意性描述。</p>
<p>一般来讲，只要符合<strong>ng2中的module简述</strong>中的模块声明方式声明的模块，就是一个feature-module，它具有什么样的feature，完全取决于它提供什么样的声明式组件和服务。对于不同的feature，如服务、指令和组件会以其他的装饰器进行修饰和声明，这不是本篇文章的内容，我们只需要知道，一个feature-module负责声明和管理它提供的服务和声明式组件。值得一提的是，和ng1不同，ng2中的feature-module可以声明一些私有的组件和服务，这一点在ng1中时做不到的。</p>
<h3 id="core-module（核心模块）"><a href="#core-module（核心模块）" class="headerlink" title="core-module（核心模块）"></a>core-module（核心模块）</h3><p>核心模块其实本质上讲，即是feature-module，只不过它提供的声明式组件和服务，是基于app本身构建的。言外之意，就是它必须是单例的，比如像登录验证这种服务，就是一种全局性的、app级别的服务，再入导航、顶部条等组件，也是app级别的组件，这些东西应该归并到core-module中，并在app-module中加载它，而坚决不要在feature-module中加载它。</p>
<h3 id="share-module（共享模块）"><a href="#share-module（共享模块）" class="headerlink" title="share-module（共享模块）"></a>share-module（共享模块）</h3><p>共享模块也是feature-module，只不过它提供的声明式组件和服务，是从各个feature-module中提取出的公共组件和服务，在官方的例子中，高亮这个指令，就是一个公用的指令，并不依赖于任何独立的业务逻辑。这些东西应该归并到share-module中，并在各个feature-module中加载它，从而使得我们的代码尽可能的保持简洁。</p>
<h3 id="lazy-load-module（懒加载模块）"><a href="#lazy-load-module（懒加载模块）" class="headerlink" title="lazy-load-module（懒加载模块）"></a>lazy-load-module（懒加载模块）</h3><p>对于SPA来讲，路由是必不可少的东西。那么对于一些未使用页面所加载的模块，我们没有必要从一开始就加载它们，很自然的，它们就成为了懒加载模块，这些模块本质上讲均是feature-module，因为core-module和share-module从职能来讲，在整个的应用生命周期，尤其初始化必不可少，因此它们很少成为懒加载模块。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2017/12/18/多维数组取值问题/" class="prev">PREV</a><a href="/2017/05/31/在-redux-中集成-angular-di-机制/" class="next">NEXT</a></div><div data-thread-key="2017/07/21/ng2-关于NgModule的简易归纳/" data-title="从ng1看ng2 关于NgModule的简易归纳" data-url="http://yoursite.com/2017/07/21/ng2-关于NgModule的简易归纳/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"littlelyno"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 - 2017 <a href="https://github.com/haoliangwu">Lyon Wu</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script async src="//littlelyon.com/js/index.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-83849508-1",'auto');ga('send','pageview');</script></body></html>