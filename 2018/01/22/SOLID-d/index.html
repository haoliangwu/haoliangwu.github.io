<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 译 · Fine, thank you, and you.</title><meta name="description" content="译 - Lyon Wu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><link rel="stylesheet" href="/css/apollo.css"><script src="//cdn.bootcss.com/html5shiv/r29/html5.js"></script></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.ico"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/pages/" target="_self" class="nav-list-link"><i class="fa fa-bookmark">&nbsp;</i>Pages</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link"><i class="fa fa-folder-open-o">&nbsp;</i>Archive</a></li><li class="nav-list-item"><a href="https://github.com/haoliangwu" target="_self" class="nav-list-link"><i class="fa fa-github-alt">&nbsp;</i>GitHub</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">译</h1><div class="post-info">Jan 22, 2018</div><div class="post-content"><h1 id="Understanding-SOLID-Principles-Dependency-Inversion"><a href="#Understanding-SOLID-Principles-Dependency-Inversion" class="headerlink" title="Understanding SOLID Principles: Dependency Inversion"></a><a href="https://codeburst.io/understanding-solid-principles-dependency-injection-d570c15560ab" target="_blank" rel="external">Understanding SOLID Principles: Dependency Inversion</a></h1><blockquote>
<p>这是理解<code>SOLID</code>原则中，关于<strong>依赖倒置</strong>原则如何帮助我们编写低耦合和可测试代码的第一篇文章。</p>
</blockquote>
<h2 id="写在前头"><a href="#写在前头" class="headerlink" title="写在前头"></a>写在前头</h2><p>当我们在读书，或者在和一些别的开发者聊天的时候，可能会谈及或者听到术语<code>SOILD</code>。在这些讨论中，一些人会提及它的重要性，以及一个理想中的系统，应当包含它所包含的5条原则的特性。</p>
<p>我们在每次的工作中，你可能没有那么多时间思考关于<strong>架构</strong>这个比较大的概念，或者在有限的时间内或督促下，你也没有办法实践一些好的设计理念。</p>
<p>但是，这些原则存在的意义不是让我们“跳过”它们。软件工程师应当将这些原则应用到他们的开发工作中。所以，在你每一次敲代码的时候，如何能够正确的将这些原则付诸于行，才是真正的问题所在。如果可以那样的话，你的代码会变得更优雅。</p>
<p><code>SOLID</code>原则是由5个基本的原则构成的。这些概念会帮助创造更好（或者说更健壮）的软件架构。这些原则包含（<code>SOLID</code>是这5个原则的开头字母组成的缩略词）：</p>
<ul>
<li>S stands for SRP (Single responsibility principle)：单一职能原则</li>
<li>O stands for OCP (Open closed principle)：开闭原则</li>
<li>L stands for LSP (Liskov substitution principle)：里氏替换原则</li>
<li>I stand for ISP ( Interface segregation principle)：接口隔离原则</li>
<li>D stands for DIP ( Dependency inversion principle)：依赖倒置原则</li>
</ul>
<p>起初这些原则是<a href="https://en.wikipedia.org/wiki/Robert_Cecil_Martin" target="_blank" rel="external">Robert C. Martin</a>在1990年提出的，遵循这些原则可以帮助我们更好的构建，低耦合、高内聚的软件架构，同时能够真正的对现实中的业务逻辑进行恰到好处的封装。</p>
<p>不过这些原则并不会使一个差劲的程序员转变为一个优秀的程序员。这些法则取决于你如何应用它们，如果你是很随意的应用它们，那等同于你并没有使用它们一样。</p>
<p>关于原则和模式的知识能够帮助你决定在何时何地正确的使用它们。尽管这些原则仅仅是启示性的，它们是常见问题的常规解决方案。实践中，这些原则的正确性已经被证实了很多次，所以它们应当成为一种常识。</p>
<h2 id="依赖倒置原则是什么"><a href="#依赖倒置原则是什么" class="headerlink" title="依赖倒置原则是什么"></a>依赖倒置原则是什么</h2><ul>
<li>高级模块不应当依赖于低级模块。它们都应当依赖于抽象。</li>
<li>抽象不应当依赖于实现，实现应当依赖于抽象。</li>
</ul>
<p>这两句话的意思是什么呢？</p>
<p>一方面，你会抽象一些东西。在软件工程和计算机科学中，抽象是一种关于规划计算机系统中的复杂性的技术。它的工作原理一般是在一个人与系统交互的复杂环境中，隐藏当前级别下的更复杂的实现细节，同时它的范围很广，常常会覆盖多个子系统。这样，当我们在与一个以高级层面作为抽象的系统协作时，我们仅仅需要在意，我们能做什么，而不是我们<strong>如何</strong>做。</p>
<p>另外，你会针对你的抽象，有一写低级别的模块或者具体实现逻辑。这些东西与抽象是相反的。它们是被用于解决某些特定问题所编写的代码。它们的作用域仅仅在某个单元和子系统中。比如，建立一个与MySQL数据库的连接就是一个低级别的实现逻辑，因为它与某个特定的技术领域所绑定。</p>
<p>现在仔细读这两句话，我们能够得到什么暗示呢？</p>
<p>依赖倒置原则存在的真正意义是指，我们需要将一些对象解耦，它们的耦合关系需要达到当一个对象依赖的对象作出改变时，对象本身不需要更改任何代码。</p>
<p>这样的架构可以实现一种松耦合的状态的系统，因为系统中所有的组件，彼此之间都了解很少或者不需要了解系统中其余组件的具体定义和实现细节。它同时实现了一种可测试和可替换的系统架构，因为在松耦合的系统中，任何组件都可以被提供相同服务的组件所替换。</p>
<p>但是相反的，依赖倒置也有一些缺点，就是你需要一个用于处理依赖倒置逻辑的容器，同时，你还需要配置它。容器通常需要具备能够在系统中注入服务，这些服务需要具备正确的作用域和参数，还应当被注入正确的执行上下文中。</p>
<h2 id="以提供Websocket连接服务为例子"><a href="#以提供Websocket连接服务为例子" class="headerlink" title="以提供Websocket连接服务为例子"></a>以提供Websocket连接服务为例子</h2><p>举个例子，我们可以在这个例子中学到更多关于依赖倒置的知识，我们将使用<code>Inversify.js</code>作为依赖倒置的容器，通过这个依赖倒置容器，我们可以看看如何针对提供<code>Websocket</code>连接服务的业务场景，提供服务。</p>
<p>比如，我们有一个web服务器提供<code>WebSockets</code>连接服务，同时客户端想要连接服务器，同时接受更新的通知。当前我们有若干种解决方案来提供一个WebSocket服务，比如说<code>Socket.io</code>、<code>Socks</code>或者使用浏览器提供的关于原生的<code>WebSocket</code>接口。每一套解决方案，都提供不同的接口和方法供我们调用，那么问题来了，我们是否可以在一个接口中，将所有的解决方案都抽象成一个提供<code>WebSocket</code>连接服务的提供者？这样，我们就可以根据我们的实际需求，使用不同的WebSocket服务提供者。</p>
<p>首先，我们来定义我们的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">export interface WebSocketConfiguration &#123;</div><div class="line">  uri: string;</div><div class="line">  options?: Object;</div><div class="line">&#125;</div><div class="line">export interface SocketFactory &#123;</div><div class="line">  createSocket(configuration: WebSocketConfiguration): any;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意在接口中，我们没有提供任何的实现细节，因此它既是我们所拥有的<strong>抽象</strong>。</p>
<p>接下来，如果我们想要一个提供<code>Socket.io</code>服务工厂：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import &#123;Manager&#125; from &apos;socket.io-client&apos;;</div><div class="line"></div><div class="line">class SocketIOFactory implements SocketFactory &#123;</div><div class="line">  createSocket(configuration: WebSocketConfiguration): any &#123;</div><div class="line">    return new Manager(configuration.uri, configuration.opts);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里已经包含了一些具体的实现细节，因此它不再是抽象，因为它声明了一个从<code>Socket.io</code>库中导入的<code>Manager</code>对象，它是我们的具体实现细节。</p>
<p>我们可以通过实现<code>SocketFactory</code>接口，来增加若干工厂类，只要我们实现这个接口即可。</p>
<p>我们在提供一个关于客户端连接实例的抽象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">export interface SocketClient &#123;</div><div class="line">  connect(configuration: WebSocketConfiguration): Promise&lt;any&gt;;</div><div class="line">  close(): Promise&lt;any&gt;;</div><div class="line">  emit(event: string, ...args: any[]): Promise&lt;any&gt;;</div><div class="line">  on(event: string, fn: Function): Promise&lt;any&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后再提供一些实现细节：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">class WebSocketClient implements SocketClient &#123;</div><div class="line">  private socketFactory: SocketFactory;</div><div class="line">  private socket: any;</div><div class="line">  public constructor(webSocketFactory: SocketFactory) &#123;</div><div class="line">    this.socketFactory = webSocketFactory;</div><div class="line">  &#125;</div><div class="line">  public connect(config: WebSocketConfiguration): Promise&lt;any&gt; &#123;</div><div class="line">    if (!this.socket) &#123;</div><div class="line">      this.socket = this.socketFactory.createSocket(config);</div><div class="line">    &#125;</div><div class="line">    return new Promise&lt;any&gt;((resolve, reject) =&gt; &#123;</div><div class="line">      this.socket.on(&apos;connect&apos;, () =&gt; resolve());</div><div class="line">      this.socket.on(&apos;connect_error&apos;, (error: Error) =&gt; reject(error));</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  public emit(event: string, ...args: any[]): Promise&lt;any&gt; &#123;</div><div class="line">    return new Promise&lt;string | Object&gt;((resolve, reject) =&gt; &#123;</div><div class="line">      if (!this.socket) &#123;</div><div class="line">        return reject(&apos;No socket connection.&apos;);</div><div class="line">      &#125;</div><div class="line">      return this.socket.emit(event, args, (response: any) =&gt; &#123;</div><div class="line">        if (response.error) &#123;</div><div class="line">          return reject(response.error);</div><div class="line">        &#125;</div><div class="line">        return resolve();</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  public on(event: string, fn: Function): Promise&lt;any&gt; &#123;</div><div class="line">    return new Promise&lt;any&gt;((resolve, reject) =&gt; &#123;</div><div class="line">      if (!this.socket) &#123;</div><div class="line">        return reject(&apos;No socket connection.&apos;);</div><div class="line">      &#125;</div><div class="line">      this.socket.on(event, fn);</div><div class="line">      resolve();</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  public close(): Promise&lt;any&gt; &#123;</div><div class="line">    return new Promise&lt;any&gt;((resolve) =&gt; &#123;</div><div class="line">      this.socket.close(() =&gt; &#123;</div><div class="line">        this.socket = null;</div><div class="line">        resolve();</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>值得注意的是，这里我们在构造函数中，传入了一个类型是<code>SocketFactory</code>的参数，这是为了满足关于依赖倒置原则的第一条规则。对于第二条规则，我们需要一种方式来提供这个不需要了解内部实现细节的、可替换的、易于配置的参数。</p>
<p>这也是为什么我们要使用<code>Inversify</code>这个库的原因，我们来加入一些额外的代码和注解（装饰器）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import &#123;injectable&#125; from &apos;inversify&apos;;</div><div class="line">const webSocketFactoryType: symbol = Symbol(&apos;WebSocketFactory&apos;);</div><div class="line">const webSocketClientType: symbol = Symbol(&apos;WebSocketClient&apos;);</div><div class="line">let TYPES: any = &#123;</div><div class="line">    WebSocketFactory: webSocketFactoryType,</div><div class="line">    WebSocketClient: webSocketClientType</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@injectable()</div><div class="line">class SocketIOFactory implements SocketFactory &#123;...&#125;</div><div class="line">...</div><div class="line">@injectable()</div><div class="line">class WebSocketClient implements SocketClient &#123;</div><div class="line">public constructor(@inject(TYPES.WebSocketFactory) webSocketFactory: SocketFactory) &#123;</div><div class="line">  this.socketFactory = webSocketFactory;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这些注释（装饰器）仅仅会在代码运行时，在如何提供这些组件实例时，提供一些元数据，接下来我们仅仅需要创建一个依赖倒置容器，并将所有的对象按正确的类型绑定起来，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import &#123;Container&#125; from &apos;inversify&apos;;</div><div class="line">import &apos;reflect-metadata&apos;;</div><div class="line">import &#123;TYPES, SocketClient, SocketFactory, SocketIOFactory, WebSocketClient&#125; from &apos;@web/app&apos;;</div><div class="line">const provider = new Container(&#123;defaultScope: &apos;Singleton&apos;&#125;);</div><div class="line">// Bindings</div><div class="line">provider.bind&lt;SocketClient&gt;(TYPES.WebSocketClient).to(WebSocketClient);</div><div class="line">provider.bind&lt;SocketFactory&gt;(TYPES.WebSocketFactory).to(SocketIOFactory);</div><div class="line">export default provider;</div></pre></td></tr></table></figure></p>
<p>让我们来看看我们如何使用我们提供连接服务的客户端实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var socketClient = provider.get&lt;SocketClient&gt;(TYPES.WebSocketClient);</div></pre></td></tr></table></figure></p>
<p>当然，使用<code>Inversify</code>可以提供一些更简单易用的绑定，可以通过浏览它的网站来了解。</p>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>一般说到依赖倒置原则，往往第一个想到的术语即是<code>依赖注入</code>，这种在各个技术栈都有应用，之后又会马上想到<code>spring</code>、<code>ng</code>等前后端框架。</p>
<p>我们确实是通过使用这些框架熟知这个概念的，但是如果你仔细想想的话，是否还有其他的一些场景也使用了类似的概念呢？</p>
<p>比如：</p>
<ul>
<li>一些使用插件和中间件的框架，如<code>express</code>、<code>redux</code></li>
<li>js中this的动态绑定</li>
<li>js中的回调函数</li>
</ul>
<p>也许有的人会不同意我的观点，会说依赖注入一般都是面向类和接口来讲的，这确实有一定的道理，但是我认为没有必要局限在一种固定的模式中去理解依赖倒置，毕竟它是一种思想，一种模式，在js中，所有的东西都是动态的，函数是一等公民，是对象，那么把这些与依赖倒置原则联系起来，完全也讲的通。我们真正关心的是核心问题是如何<strong>解耦</strong>，把更多的注意力投入的真正的业务逻辑中去。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2018/01/16/workerize/" class="next">NEXT</a></div><div data-thread-key="2018/01/22/SOLID-d/" data-title="译" data-url="http://yoursite.com/2018/01/22/SOLID-d/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"littlelyno"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 - 2018 <a href="https://github.com/haoliangwu">Lyon Wu</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script async src="//littlelyon.com/js/index.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-83849508-1",'auto');ga('send','pageview');</script></body></html>