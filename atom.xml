<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fine, thank you, and you.</title>
  
  <subtitle>一切安好，感谢有你，与你同行。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://littlelyon.com/"/>
  <updated>2018-04-04T11:46:03.000Z</updated>
  <id>http://littlelyon.com/</id>
  
  <author>
    <name>Lyon Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>30分钟理解GraphQL核心概念</title>
    <link href="http://littlelyon.com/2018/04/02/30-minutes-graphql/"/>
    <id>http://littlelyon.com/2018/04/02/30-minutes-graphql/</id>
    <published>2018-04-02T04:13:29.000Z</published>
    <updated>2018-04-04T11:46:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2>写在前面</h2><p>在上一篇文章<a href="http://littlelyon.com/2018/03/24/rpc-reset-graphql/">RPC vs REST vs GraphQL</a>中，对于这三者的优缺点进行了比较宏观的对比，而且我们也会发现，一般比较简单的项目其实并不需要GraphQL，但是我们仍然需要对新的技术有一定的了解和掌握，在新技术普及时才不会措手不及。</p><p>这篇文章主要介绍一些我接触GraphQL的这段时间，觉得需要了解的比较核心的概念，比较适合一下人群：</p><ul><li>听说过GraphQL的读者，想深入了解一下</li><li>想系统地学习GraphQL的读者</li><li>正在调研GraphQL技术的读者</li></ul><p>这些概念并不局限于服务端或者是客户端，如果你熟悉这些概念，在接触任意使用GraphQL作为技术背景的库或者框架时，都可以通过文档很快的上手。</p><p>如果你已经GraphQL应用于了实际项目中，那么这篇文章可能不适合你，因为其中并没有包含一些实践中的总结和经验，关于实践的东西我会在之后再单另写一篇文章总结。</p><h2>什么是GraphQL</h2><p>介绍GraphQL是什么的文章网上一搜一大把，篇幅有长有短，但是从最核心上讲，它是一种查询语言，再进一步说，是一种API查询语言。</p><p>这里可能有的人就会说，什么？API还能查？API不是用来调用的吗？是的，这正是GraphQL的强大之处，引用官方文档的一句话：</p><blockquote><p>ask what exactly you want.</p></blockquote><p>我们在使用REST接口时，接口返回的数据格式、数据类型都是后端预先定义好的，如果返回的数据格式并不是调用者所期望的，作为前端的我们可以通过以下两种方式来解决问题：</p><ul><li>和后端沟通，改接口（更改数据源）</li><li>自己做一些适配工作（处理数据源）</li></ul><p>一般如果是个人项目，改后端接口这种事情可以随意搞，但是如果是公司项目，改后端接口往往是一件比较敏感的事情，尤其是对于三端（web、andriod、ios）公用同一套后端接口的情况。大部分情况下，均是按第二种方式来解决问题的。</p><p>因此如果接口的返回值，可以通过某种手段，从静态变为动态，即调用者来声明接口返回什么数据，很大程度上可以进一步解耦前后端的关联。</p><p>在GraphQL中，我们通过预先定义一张<code>Schema</code>和声明一些<code>Type</code>来达到上面提及的效果，我们需要知道：</p><ul><li>对于数据模型的抽象是通过Type来描述的</li><li>对于接口获取数据的逻辑是通过Schema来描述的</li></ul><p>这么说可能比较抽象，我们一个一个来说明。</p><h2>Type</h2><p>对于数据模型的抽象是通过Type来描述的，每一个Type有若干Field组成，每个Field又分别指向某个Type。</p><p>GraphQL的Type简单可以分为两种，一种叫做<code>Scalar Type(标量类型)</code>，另一种叫做<code>Object Type(对象类型)</code>。</p><h3>Scalar Type</h3><p>GraphQL中的内建的标量包含，<code>String</code>、<code>Int</code>、<code>Float</code>、<code>Boolean</code>、<code>Enum</code>，对于熟悉编程语言的人来说，这些都应该很好理解。</p><p>值得注意的是，GraphQL中可以通过<code>Scalar</code>声明一个新的标量，比如：</p><ul><li>prisma（一个使用GraphQL来抽象数据库操作的库）中，还有<code>DateTime</code>和<code>ID</code>这两个标量分别代表日期格式和主键</li><li>在使用GraphQL实现文件上传接口时，需要声明一个<code>Upload</code>标量来代表要上传的文件</li></ul><p>总之，我们只需要记住，标量是GraphQL类型系统中最小的颗粒，关于它在GraphQL解析查询结果时，我们还会再提及它。</p><h3>Object Type</h3><p>仅有标量是不够的抽象一些复杂的数据模型的，这时候我们需要使用对象类型，举个例子(先忽略语法，仅从字面上看)：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Article &#123;</span><br><span class="line">  id: ID</span><br><span class="line">  text: String</span><br><span class="line">  isPublished: Boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码，就声明了一个<code>Article</code>类型，它有3个Field，分别是<code>ID</code>类型的id，<code>String</code>类型的text和<code>Boolean</code>类型的isPublished。</p><p>对于对象类型的Field的声明，我们一般使用标量，但是我们也可以使用另外一个对象类型，比如如果我们再声明一个新的<code>User</code>类型，如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type User &#123;</span><br><span class="line">  id: ID</span><br><span class="line">  name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时我们就可以稍微的更改一下关于<code>Article</code>类型的声明代码，如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Article &#123;</span><br><span class="line">  id: ID</span><br><span class="line">  text: String</span><br><span class="line">  isPublished: Boolean</span><br><span class="line">  author: User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Article</code>新增的<code>author</code>的Field是<code>User</code>类型, 代表这篇文章的作者。</p><p>总之，我们通过对象模型来构建GraphQL中关于一个数据模型的形状，同时还可以声明各个模型之间的内在关联（一对多、一对一或多对多）。</p><h3>Type Modifier</h3><p>关于类型，还有一个较重要的概念，即类型修饰符，当前的类型修饰符有两种，分别是<code>List</code>和<code>Required</code>，它们的语法分别为<code>[Type]</code>和<code>Type!</code>, 同时这两者可以互相组合，比如<code>[Type]!</code>或者<code>[Type!]</code>或者<code>[Type!]!</code>(请仔细看这里<code>!</code>的位置)，它们的含义分别为：</p><ul><li>列表本身为必填项，但其内部元素可以为空</li><li>列表本身可以为空，但是其内部元素为必填</li><li>列表本身和内部元素均为必填</li></ul><p>我们进一步来更改上面的例子，假如我们又声明了一个新的<code>Comment</code>类型，如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Comment &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  desc: String,</span><br><span class="line">  author: User!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你会发现这里的<code>ID</code>有一个<code>!</code>，它代表这个Field是必填的，再来更新<code>Article</code>对象，如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Article &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  text: String</span><br><span class="line">  isPublished: Boolean</span><br><span class="line">  author: User!</span><br><span class="line">  comments: [Comment!]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们这里的作出的更改如下：</p><ul><li>id字段改为必填</li><li>author字段改为必填</li><li>新增了comments字段，它的类型是一个元素为Comment类型的List类型</li></ul><p>最终的<code>Article</code>类型，就是GraphQL中关于文章这个数据模型，一个比较简单的类型声明。</p><h2>Schema</h2><p>现在我们开始介绍<code>Schema</code>，我们之前简单描述了它的作用，即它是用来描述<code>对于接口获取数据逻辑</code>的，但这样描述仍然是有些抽象的，我们其实不妨把它当做REST架构中每个独立资源的<code>uri</code>来理解它，只不过在GraphQL中，我们用Query来描述资源的获取方式。因此，我们可以将<code>Schema</code>理解为多个Query组成的一张表。</p><p>这里又涉及一个新的概念<code>Query</code>，GraphQL中使用<code>Query</code>来抽象数据的查询逻辑，当前标准下，有三种查询类型，分别是<em>query（查询）</em>、<em>mutation（更改）<em>和</em>subscription（订阅）</em>。</p><p>Note: 为了方便区分，<code>Query</code>特指GraphQL中的查询（包含三种类型），<code>query</code>指GraphQL中的查询类型（仅指查询类型）</p><h3>Query</h3><p>上面所提及的3中基本查询类型是作为<code>Root Query（根查询）</code>存在的，对于传统的CRUD项目，我们只需要前两种类型就足够了，第三种是针对当前日趋流行的<code>real-time</code>应用提出的。</p><p>我们按照字面意思来理解它们就好，如下：</p><ul><li>query（查询）：当获取数据时，应当选取Query类型</li><li>mutation（更改）：当尝试修改数据时，应当使用mutation类型</li><li>subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型</li></ul><p>仍然以一个例子来说明。</p><p>首先，我们分别以REST和GraphQL的角度，以<code>Article</code>为数据模型，编写一系列CRUD的接口，如下：</p><p>Rest 接口</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/articles/</span><br><span class="line">GET /api/v1/article/:id/</span><br><span class="line">POST /api/v1/article/</span><br><span class="line">DELETE /api/v1/article/:id/</span><br><span class="line">PATCH /api/v1/article/:id/</span><br></pre></td></tr></table></figure></p><p>GraphQL Query</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Query &#123;</span><br><span class="line">  articles(): [Article!]!</span><br><span class="line">  article(id: Int): Article!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutation &#123;</span><br><span class="line">  createArticle(): Article!</span><br><span class="line">  updateArticle(id: Int): Article!</span><br><span class="line">  deleteArticle(id: Int): Article!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对比我们较熟悉的REST的接口我们可以发现，GraphQL中是按根查询的类型来划分Query职能的，同时还会明确的声明每个Query所返回的数据类型，这里的关于类型的语法和上一章节中是一样的。需要注意的是，我们所声明的任何<code>Query</code>都必须是<code>Root Query</code>的子集，这和GraphQL内部的运行机制有关。</p><p>例子中我们仅仅声明了Query类型和Mutation类型，如果我们的应用中对于评论列表有<code>real-time</code>的需求的话，在REST中，我们可能会直接通过长连接或者通过提供一些带验证的获取长连接url的接口，比如：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /api/v1/messages/</span><br></pre></td></tr></table></figure></p><p>之后长连接会将新的数据推送给我们，在GraphQL中，我们则会以更加声明式的方式进行声明，如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">subscription &#123;</span><br><span class="line">  updatedArticle() &#123;</span><br><span class="line">    mutation</span><br><span class="line">    node &#123;</span><br><span class="line">    comments: [Comment!]!</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们不必纠结于这里的语法，因为这篇文章的目的不是让你在30分钟内学会GraphQL的语法，而是理解的它的一些核心概念，比如这里，我们就声明了一个订阅Query，这个Query会在有新的Article被创建或者更新时，推送新的数据对象。当然，在实际运行中，其内部实现仍然是建立于长连接之上的，但是我们能够以更加声明式的方式来进行声明它。</p><h3>Resolver</h3><p>如果我们仅仅在Schema中声明了若干Query，那么我们只进行了一半的工作，因为我们并没有提供相关Query所返回数据的逻辑。为了能够使GraphQL正常工作，我们还需要再了解一个核心概念，<code>Resolver（解析函数）</code>。</p><p>GraphQL中，我们会有这样一个约定，Query和与之对应的Resolver是同名的，这样在GraphQL才能把它们对应起来，举个例子，比如关于<code>articles(): [Article!]!</code>这个Query, 它的Resolver的名字必然叫做<code>articles</code>。</p><p>在介绍Resolver之前，是时候从整体上了解下GraphQL的内部工作机制了，假设现在我们要对使用我们已经声明的<code>articles</code>的Query，我们可能会写以下查询语句（同样暂时忽略语法）：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Query &#123;</span><br><span class="line">  articles &#123;</span><br><span class="line">   id</span><br><span class="line">   author &#123;</span><br><span class="line">   name</span><br><span class="line">   &#125;</span><br><span class="line">   comments &#123;</span><br><span class="line">      id</span><br><span class="line">      desc</span><br><span class="line">      author</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>GraphQL在解析这段查询语句时会按如下步骤（简略版）：</p><ul><li>首先进行第一层解析，当前<code>Query</code>的<code>Root Query</code>类型是<code>query</code>，同时需要它的名字是<code>articles</code></li><li>之后会尝试使用<code>articles</code>的<code>Resolver</code>获取解析数据，第一层解析完毕</li><li>之后对第一层解析的返回值，进行第二层解析，当前<code>articles</code>还包含三个子<code>Query</code>，分别是<code>id</code>、<code>author</code>和<code>comments</code><ul><li>id在Author类型中为标量类型，解析结束</li><li>author在Author类型中为对象类型User，尝试使用<code>User</code>的<code>Resolver</code>获取数据，当前field解析完毕</li><li>之后对第二层解析的返回值，进行第三层解析，当前<code>author</code>还包含一个<code>Query</code>, <code>name</code>，由于它是标量类型，解析结束</li><li>comments同上...</li></ul></li></ul><p>我们可以发现，GraphQL大体的解析流程就是遇到一个Query之后，尝试使用它的Resolver取值，之后再对返回值进行解析，这个过程是递归的，直到所解析Field的类型是<code>Scalar Type（标量类型）</code>为止。解析的整个过程我们可以把它想象成一个很长的Resolver Chain（解析链）。</p><p>这里对于GraphQL的解析过程只是很简单的概括，其内部运行机制远比这个复杂，当然这些对于使用者是黑盒的，我们只需要大概了解它的过程即可。</p><p>Resolver本身的声明在各个语言中是不一样的，因为它代表数据获取的具体逻辑。它的函数签名(以js为例子)如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function(parent, args, ctx, info) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中的参数的意义如下：</p><ul><li>parent: 当前上一个Resolver的返回值</li><li>args: 传入某个Query中的函数（比如上面例子中<code>article(id: Int)</code>中的<code>id</code>）</li><li>ctx: 在Resolver解析链中不断传递的中间变量（类似中间件架构中的context）</li><li>info: 当前Query的AST对象</li></ul><p>值得注意的是，Resolver内部实现对于GraphQL完全是黑盒状态。这意味着Resolver如何返回数据、返回什么样的数据、从哪返回数据，完全取决于Resolver本身，基于这一点，在实际中，很多人往往把GraphQL作为一个中间层来使用，数据的获取通过Resolver来封装，内部数据获取的实现可能基于RPC、REST、WS、SQL等多种不同的方式。同时，基于这一点，当你在对一些未使用GraphQL的系统进行迁移时（比如REST），可以很好的进行增量式迁移。</p><h2>总结</h2><p>大概就这么多，首先感谢你耐心的读到这里，虽然题目是30分钟熟悉GraphQL核心概念，但是可能已经超时了，不过我相信你对GraphQL中的核心概念已经比较熟悉了。但是它本身所涉及的东西远远比这个丰富，同时它还处于飞速的发展中。</p><p>最后我尝试根据这段时间的学习GraphQL的经验，提供一些进一步学习和了解GraphQL的方向和建议，仅供参考：</p><h3>想进一步了解GraphQL本身</h3><p>我建议再仔细去官网，读一下官方文档，如果有兴趣的话，看看GraphQL的spec也是极好的。这篇文章虽然介绍了核心概念，但是其他一些概念没有涉及，比如Union、Interface、Fragment等等，这些概念均是基于核心概念之上的，在了解核心概念后，应当会很容易理解。</p><h3>偏向服务端</h3><p>偏向服务端方向的话，除了需要进一步了解GraphQL在某个语言的具体生态外，还需要了解一些关于缓存、上传文件等特定方向的东西。如果是想做系统迁移，还需要对特定的框架做一些调研，比如graphene-django。</p><p>如果是想使用GraphQL本身做系统开发，这里推荐了解一个叫做<a href="https://www.prisma.io/docs/" target="_blank" rel="noopener">prisma</a>的框架，它本身是在GraphQL的基础上构建的，并且与一些GraphQL的生态框架兼容性也较好，在各大编程语言也均有适配，它本身可以当做一个ORM来使用，也可以当做一个与数据库交互的中间层来使用。</p><h3>偏向客户端</h3><p>偏向客户端方向的话，需要进一步了解关于graphql-client的相关知识，我这段时间了解的是apollo，一个开源的grapql-client框架，并且与各个主流前端技术栈如Angular、React等均有适配版本，使用感觉良好。</p><p>同时，还需要了解一些额外的查询概念，比如分页查询中涉及的Connection、Edge等。</p><p>大概就这么多，如有错误，还望指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;在上一篇文章&lt;a href=&quot;http://littlelyon.com/2018/03/24/rpc-reset-graphql/&quot;&gt;RPC vs REST vs GraphQL&lt;/a&gt;中，对于这三者的优缺点进行了比较宏观的对比，而且我们也会发
      
    
    </summary>
    
      <category term="原创" scheme="http://littlelyon.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="graphql" scheme="http://littlelyon.com/tags/graphql/"/>
    
      <category term="api" scheme="http://littlelyon.com/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>RPC vs REST vs GraphQL</title>
    <link href="http://littlelyon.com/2018/03/24/rpc-reset-graphql/"/>
    <id>http://littlelyon.com/2018/03/24/rpc-reset-graphql/</id>
    <published>2018-03-24T10:03:27.000Z</published>
    <updated>2018-04-04T11:58:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2>写在前面</h2><p>最近2周的时间由于工作不忙，一直在看有关<code>GraphQL</code>的东西，前后端均有涉及，由于我之前做过后端开发，当时实现的接口的大体是符合<code>RPC</code>风格的接口。后来转做了前端开发，从实现接口者变成了调用接口者，接触最多的当属<code>REST</code>风格的接口。因此在这段学习<code>GraphQL</code>的过程中，并且也尝试使用它以全栈的角度做了一个小项目，在这个过程中，一直在思考它对比前两者在<code>API</code>设计的整体架构体系中的各个指标上，孰优孰劣。</p><p>其实在使用和学习的过程中，有很多文章都对比过它们的异同，但是大部分文章并没有从一个相对客观的角度来对比，更多是为了突显一个的优点而刻意指出另外一个的缺点。这让我想到一句话，脱离业务情景谈技术就是耍流氓。</p><p>昨天订阅的<code>GraphQL Weekly</code>中推送的一个视频正好是讲关于它们这三者的，于是就点进去看了看，发现质量还是不错的，于是就想整理出来，分享给大家。</p><p>原视频地址(油管地址，自备梯子)：<a href="https://www.youtube.com/watch?v=IvsANO0qZEg" target="_blank" rel="noopener">这里</a></p><p>如果没有梯子的话直接看我整理的东西也可以，我觉的应该都覆盖到视频中所讲的重点内容了。</p><p>当然，这些内容如果分开来讲，每一块内容所涉及的东西都够写一本书了，这里仅仅是简单归纳和整理，从宏观的角度来对比它们的异同，从而能够在日后面临技术选型时，有一个更佳明确的决策方向。</p><h2>RPC</h2><p>先简单介绍下<code>RPC</code>，它是<code>Remote Procedure Call(远程过程调用)</code>的简称。一般基于<code>RPC</code>协议所设计的接口，是基于网络采用客户端/服务端的模式完成调用接口的。</p><h3>优点</h3><ul><li>简单并且易于理解（面向开发者）</li><li>轻量级的数据载体</li><li>高性能</li></ul><h3>缺点</h3><ul><li>对于系统本身耦合性高</li><li>因为RPC本身很简单、轻量，因此很容易造成 <code>function explosion</code></li></ul><p>关于<code>RPC</code>的优点其实很好理解，就是因为它性能高同时又很简单，但是我认为这是对于接口提供者来讲的（因为它的高耦合性）。</p><p>但是如果从接口调用者的角度来看，高耦合性就变成了缺点，因为高耦合意味着调用者必须要足够了解系统本身的实现才能够完成调用，比如：</p><ul><li>调用者需要知道所调用接口的函数名、参数格式、参数顺序、参数名称等等</li><li>如果接口提供者(server)要对接口做出一些改变，很容易对接口调用者(client)造成<code>breaking change</code>（违背开闭原则)</li><li>一般<code>RPC</code>所暴露接口仅仅会暴露函数的名称和参数等信息，对于函数之间的调用关系无法提供，这意味着调用者必须足够了解系统，从能够知道如何正确的调用这些接口，但是对于接口调用者往往不需要了解过多系统内部实现细节</li></ul><p>关于上面的第二点，为了减少<code>breaking change</code>，我之前实现接口的时候一般都会引入版本的概念，就是在暴露接口的方法名中加入版本号，一开始效果确实不错，但是随后就不知不觉的形成了<code>function explosion</code>，和视频中主讲人所举例的例子差不多，贴一下视频中的截图感受一波：</p><p><img src="/img/func_explosion.png"></p><h1>REST</h1><p>当前REST风格的API架构方式已经成了主流解决方案了，相比较RPC，它的主要不同之处在于，它是对于资源(Resource)的模型化而非步骤(Procedure)。</p><h3>优点</h3><ul><li>对于系统本身耦合性低，调用者不再需要了解接口内部处理和实现细节</li><li>重复使用了一些 http 协议中的已定义好的部分状态动词，增强语义表现力</li><li>API可以随着时间而不断演进</li></ul><h3>缺点</h3><ul><li>缺少约束，缺少简单、统一的规范</li><li>有时候 payload 会变的冗余(overload)，有时候调用api会比较繁琐(chattiness)</li><li>有时候需要发送多条请求已获取数据，在网络带宽较低的场景，往往会造成不好的影响</li></ul><p>REST的优点基本解决了RPC中存在的问题，就是解耦，从而使得前后端分离成为可能。接口提供者在修改接口时，不容易造成breaking-change，接口调用者在调用接口时，往往面向数据模型编程，而省去了了解接口本身的时间成本。</p><p>但是，我认为REST当前最大的问题在于虽然它利用<code>http</code>的动词约束了接口的暴露方式，同时增强了语义，但是却没有约束接口如何返回数据的最佳实践，总让人感觉只要是返回json格式的接口都可以称作REST。</p><p>我在实际工作中，经常会遇到第二条缺点所指出的问题，就是接口返回的数据冗余度很高，但是却缺少我真正需要的数据，因此不得已只能调用其他接口或者直接和后端商议修改接口，并且这种问题会在web端和移动端共用一套接口中被放大。</p><p>当前比较好的解决方案就是规范化返回数据的格式，比如json-schema或者自己制定的规范。</p><h1>GraphQL</h1><p>GraphQL是近来比较热门的一个技术话题，相比REST和RPC，它汲取了两者的优点，即不面向资源，也不面向过程，而是面向数据查询(ask for exactly what you want)。</p><p>同时GraphQL本身需要使用强类型的Schema来对数据模型进行定义，因此相比REST它的约束性更强。</p><h3>优点</h3><ul><li>网络开销低，可以在单一请求中获取REST中使用多条请求获取的资源</li><li>强类型Schema（约束意味着可以根据规范形成文档、IDE、错误提示等生态工具）</li><li>特别适合<em>图</em>状数据结构的业务场景（比如好友、流程、组织架构等系统）</li></ul><h3>缺点</h3><ul><li>本身的语法相比较REST和RPC均复杂一些</li><li>实现方面需要配套 Caching 以解决性能瓶颈</li><li>对于 API 的版本控制当前没有完善解决方案（社区的建议是不要使API版本化）</li><li>仍然是新鲜事物，很多技术细节仍然处于待验证状态</li></ul><p>鉴于GraphQL这两个星期我也仅仅是做了一些简单地使用和了解，仅仅说一下感受。</p><p>首先值得肯定的是，在某些程度上确实解决了REST的缺点所带来的问题，同时配套社区建议的各种工具和库，相比使用REST风格，全栈开发体验上升一个台阶。</p><p>但是这个看起来很好的东西为什么没有火起来呢？我觉的最主要的原因是因为GraphQL所带来的好处，大部分是对于接口调用者而言的，但是实现这部分的工作却需要接口提供者来完成。</p><p>同时GraphQL的最佳实践场景应当是类似像Facebook这样的网站，业务逻辑模型是图状数据结构，比如社交。如果在一些业务逻辑模型相对简单的场景，使用GraphQL确实不如使用REST来得简单明了、直截了当。</p><p>另外一方面是GraphQL的使用场景相当灵活，在我自己的调研项目中，我是把它当做一个类似ORM的框架来使用的，在别人的一些文章中，会把它当做一个中间层来做渐进式开发和系统升级。这应当算是另外一个优点。</p><h3>到底用哪个</h3><p>下面根据要设计的API类型给予一些技术选型建议。</p><p>如果是<code>Management API</code>，这类API的特点如下：</p><ul><li>关注于对象与资源</li><li>会有多种不同的客户端</li><li>需要良好的可发现性和文档</li></ul><p>这种情景使用<code>REST + JSON API</code>可能会更好。</p><p>如果是<code>Command or Action API</code>，这类API的特点如下：</p><ul><li>面向动作或者指令</li><li>仅需要简单的交互</li></ul><p>这种情况使用<code>RPC</code>就足够了。</p><p>如果是<code>Internal Micro Services API</code>，这类API的特点如下：</p><ul><li>消息密集型</li><li>对系统性能有较高要求</li></ul><p>这种情景仍然建议使用<code>RPC</code>。</p><p>如果是<code>Micro Services API</code>，这类API的特点如下：</p><ul><li>消息密集型</li><li>期望系统开销较低</li></ul><p>这种情景使用<code>RPC</code>或者<code>REST</code>均可。</p><p>如果是<code>Data or Mobile API</code>，这类API的特点是：</p><ul><li>数据类型是具有图状的特点</li><li>希望对于高延迟场景可以有更好的优化</li></ul><p>这种场景无疑<code>GraphQL</code>是最好的选择。</p><h3>写在最后</h3><p>提供一张表格来总览它们之间在不同指标下的表现：</p><table><thead><tr><th></th><th style="text-align:center">耦合性</th><th style="text-align:center">约束性</th><th style="text-align:center">复杂度</th><th style="text-align:center">缓存</th><th style="text-align:center">可发现性</th><th style="text-align:center">版本控制</th></tr></thead><tbody><tr><td>RPC(Function)</td><td style="text-align:center">high</td><td style="text-align:center">medium</td><td style="text-align:center">low</td><td style="text-align:center">custom</td><td style="text-align:center">bad</td><td style="text-align:center">hard</td></tr><tr><td>REST(Resource)</td><td style="text-align:center">low</td><td style="text-align:center">low</td><td style="text-align:center">low</td><td style="text-align:center">http</td><td style="text-align:center">good</td><td style="text-align:center">easy</td></tr><tr><td>GraphQL(Query)</td><td style="text-align:center">medium</td><td style="text-align:center">high</td><td style="text-align:center">medium</td><td style="text-align:center">custom</td><td style="text-align:center">good</td><td style="text-align:center">???</td></tr></tbody></table><p>最后引用人月神话中的观点<code>no silver bullet</code>，在技术选型时需要具体情况具体分析，不过鉴于GraphQL的灵活性，把它与RPC和REST配置使用，也是不错的选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;最近2周的时间由于工作不忙，一直在看有关&lt;code&gt;GraphQL&lt;/code&gt;的东西，前后端均有涉及，由于我之前做过后端开发，当时实现的接口的大体是符合&lt;code&gt;RPC&lt;/code&gt;风格的接口。后来转做了前端开发，从实现接口者变成了调用接口者
      
    
    </summary>
    
      <category term="原创" scheme="http://littlelyon.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="graphql" scheme="http://littlelyon.com/tags/graphql/"/>
    
      <category term="api" scheme="http://littlelyon.com/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>高级 Angular 组件模式 (4)</title>
    <link href="http://littlelyon.com/2018/02/17/aacp-4/"/>
    <id>http://littlelyon.com/2018/02/17/aacp-4/</id>
    <published>2018-02-17T11:08:26.000Z</published>
    <updated>2018-04-04T11:53:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2>04 Avoid Namespace Clashes with Directives</h2><blockquote><p>原文: <a href="https://blog.angularindepth.com/avoid-namespace-clashes-with-directives-1f00d62de445" target="_blank" rel="noopener">Avoid Namespace Clashes with Directives</a></p></blockquote><h2>提示</h2><p>在同一个<code>html</code>元素上绑定多个指令可能会造成命名冲突。</p><p>命名冲突不仅存在于指令的选择器之间，同时也会存在于指令的<code>Inputs</code>和<code>Outputs</code>属性，当这些属性名一样时，Angular并不会进行提示，它会按原本的逻辑正常工作。这种情况有时候是我们希望看到的，有些时候却不是。</p><h2>目标</h2><p>避免存在于绑定在相同元素上的多个指令上的命名冲突。</p><h2>实现</h2><p>因为<code>toggle</code>和<code>withToggle</code>指令都绑定于<code>&lt;toggle&gt;</code>元素，我们将通过为它们增加一个<code>label</code>属性来说明问题。</p><p>首先我们设置一个<code>label</code>属性，比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;toggle label=&quot;some label&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>这个<code>label</code>属性的值会同时绑定在每个指令上，如果想要为其中的某个指令单独绑定，只能通过使用<code>prefix(前缀)</code>来实现。</p><p>Angular官方提供的规范指南也警示了这一点，当你在使用<code>prefix</code>修饰指令的名称时，也需要注意使用<code>prefix</code>来修饰<code>Input</code>和<code>Output</code>属性的名称。</p><p>Note: 当使用<code>Output</code>属性重写原生<code>DOM</code>元素的事件和使用<code>Input</code>属性重写原生元素的属性时，请额外注意，没有任何方式可以获知别人在他们编写的应用或者库中使用的命名，但是你可以很轻易的知道的具体命名的大体规则是什么，并且不要重写它们，除非你有意为之。</p><p>增加<code>prefix</code>的一种方式是在每个指令的<code>label</code>属性的装饰器内增加一个字符串参数，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// In withToggle.directive.ts</span><br><span class="line">@Input(&apos;withToggleLabel&apos;) label;</span><br><span class="line"></span><br><span class="line">// In toggle.directive.ts</span><br><span class="line">@Input(&apos;toggleLabel&apos;) label;</span><br></pre></td></tr></table></figure></p><p>但是这种解决方案的前提时，你至少能够更改存在命名冲突中的一个或多个指令的源码。如果在两个第三方库中存在命名冲突，这种情况是最棘手的，我们不在这里讨论它们。</p><h2>成果</h2><p>https://stackblitz.com/edit/adv-ng-patterns-04-namespace-clashes</p><h2>译者注</h2><p>原文中关于最后一段提出的关于在多个第三方库中存在的命名冲突的场景，作者提供做出具体的解决方案，我在这里简单分享一下自己对于这种情况的解决方案：</p><p>通常这种情况比较少见，但是万一存在这种情况，我们可以通过创建一个新的<code>wrapper</code>指令来封装第三方指令，<code>wrapper</code>指令提供与第三方指令一样的接口属性，但是因为我们对于<code>wrapper</code>指令有绝对的控制权，我们可以提供统一的<code>prefix</code>来修饰这些接口属性，从而达到解决冲突的效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;04 Avoid Namespace Clashes with Directives&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;原文: &lt;a href=&quot;https://blog.angularindepth.com/avoid-namespace-clashes-wit
      
    
    </summary>
    
      <category term="翻译" scheme="http://littlelyon.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="js" scheme="http://littlelyon.com/tags/js/"/>
    
      <category term="angular" scheme="http://littlelyon.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>高级 Angular 组件模式 (5)</title>
    <link href="http://littlelyon.com/2018/02/17/aacp-5/"/>
    <id>http://littlelyon.com/2018/02/17/aacp-5/</id>
    <published>2018-02-17T11:07:14.000Z</published>
    <updated>2018-04-04T11:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2>05 Handle Template Reference Variables with Directives</h2><blockquote><p>原文: <a href="https://blog.angularindepth.com/handle-template-reference-variables-with-directives-223081bc70c2" target="_blank" rel="noopener">Handle Template Reference Variables with Directives</a></p></blockquote><p>在之前的例子中，已经出现多次使用<code>template reference variable（模板引用变量）</code>的场景，现在让我们来深入研究如何通过使用模板引用变量来关联某个具体指令。</p><h2>目标</h2><p>在视图模板内，获取一个指令的引用。</p><h2>实现</h2><p>模板引用变量是获取某个元素、组件或者指令引用的一种方式，这个引用可以在当前的视图模板中的任何地方使用。它们通常是以<code>#baseToggle</code>或者<code>#myToggle=&quot;toggle&quot;</code>的语法声明的。一旦声明，在视图模板的任何地方就可以使用它。</p><p>Note: 请注意作用域的问题，如果你使用<code>&lt;ng-template&gt;</code>或者是一个结构性指令，比如<code>*ngIf</code>或者<code>*ngFor</code>，它会在这个模板上创建一个新的作用域，之后在其内部声明的模板引用变量无法在该模板作用域以外使用。</p><p>模板引用变量的解析顺序通常为：</p><ol><li>一个指令或者组件通过它自身的<code>exportAs</code>属性，比如<code>#myToggle=&quot;toggle&quot;</code></li><li>声明于以自定义标签存在的组件，比如<code>&lt;toggle-on #toggleOn&gt;&lt;/toggle-on&gt;</code></li><li>原生html元素，并且没有任何组件绑定与它，比如<code>&lt;div #someDiv&gt;&lt;/div&gt;</code></li></ol><p>之后我们来分别看3个例子。</p><h3>指令与<code>exportAs</code></h3><p>指令可以在它的元数据中声明<code>exportAs</code>属性，这个属性表示它被这个模板引用变量所标识，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// toggle.directive.ts</span><br><span class="line">@Directive(&#123;</span><br><span class="line">  selector: &apos;[toggle]&apos;,</span><br><span class="line">  exportAs: &apos;toggle&apos;,</span><br><span class="line">&#125;)</span><br><span class="line">export class ToggleDirective &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>之后我们可以在视图模板中直接使用<code>toggle</code>来获取指令的引用，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// app.component.html</span><br><span class="line">&lt;div toggle #myTemplateRefVar=&quot;toggle&quot;&gt;&lt;/div&gt;</span><br><span class="line">// myTemplateRefVar is the ToggleDirective</span><br></pre></td></tr></table></figure></p><h3>组件</h3><p>对于每一个<code>html</code>元素，只会有一个组件与之对应。当一个组件绑定于一个元素时，那么声明的模板引用变量将会被解析为当前元素上所绑定的组件，比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// app.component.html</span><br><span class="line">&lt;toggle-on #toggleOn&gt;&lt;/toggle-on&gt;</span><br><span class="line">// toggleOn is the ToggleOnComponent</span><br></pre></td></tr></table></figure></p><h3>HTML元素</h3><p>如果没有组件与元素绑定，模板引用变量会指向当前这个<code>html</code>元素。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// app.component.html</span><br><span class="line">&lt;div #someDiv&gt;&lt;/div&gt;</span><br><span class="line">// someDiv is an HTMLDivElement</span><br></pre></td></tr></table></figure></p><h3>成果</h3><p>Note: 在<code>stackblitz</code>中，我通过打印模板引用变量所指向的类的名字（constructor.name）来演示它所代表的引用。</p><p>https://stackblitz.com/edit/adv-ng-patterns-05-template-ref-variables</p><h2>译者注</h2><p>这篇文章作者关于模板引用变量，仅仅介绍了关于如何声明和在视图模板中如何使用，我在这里再补充一些，如何在组件或者指令类的内部使用。</p><p>在类内部获取模板引用变量所指向的引用是通过使用<code>ViewChild</code>装饰器完成的，比如上述文章中的第二个例子:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;my-app&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;div #myDiv&gt;&lt;/div&gt;</span><br><span class="line">  `,</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent &#123;</span><br><span class="line">  @ViewChild(&apos;myDiv&apos;)</span><br><span class="line">  myDiv: ElementRef;</span><br><span class="line"></span><br><span class="line">  ngAfterViewInit() &#123;</span><br><span class="line">    console.log(this.myDiv);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的<code>myDiv</code>即指向当前模板引用变量所指向的html元素。</p><p>Note: 在类中获取模板引用变量所指向的引用时，请格外注意你期望获取的引用类型，在例子中，我们期望获取html元素，因此这里的引用类型是<code>ElementRef</code>，如果是指令或者组件，则分别要对应其类型的<code>Type</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;05 Handle Template Reference Variables with Directives&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;原文: &lt;a href=&quot;https://blog.angularindepth.com/handle-template
      
    
    </summary>
    
      <category term="翻译" scheme="http://littlelyon.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="js" scheme="http://littlelyon.com/tags/js/"/>
    
      <category term="angular" scheme="http://littlelyon.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>javascript原型链-review</title>
    <link href="http://littlelyon.com/2018/02/08/javascript%E5%8E%9F%E5%9E%8B%E9%93%BEreview/"/>
    <id>http://littlelyon.com/2018/02/08/javascript原型链review/</id>
    <published>2018-02-08T09:28:48.000Z</published>
    <updated>2018-04-04T11:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2>写在前面</h2><p>虽然现在es8都已经在预发布阶段了，但是无论发布到es几，其本身的运作原理都是一样的。</p><p>首先祭上一张图, 这张图主要描述了以下的关系，如果觉的这里的说明过于复杂可以直接看<a href="#%E6%80%BB%E7%BB%93">最后一段</a>。<img src="/img/e83bca5f1d1e6bf359d1f75727968c11_hd.jpg"></p><h2>简单说明</h2><p>关于<code>function(class)A</code>和它的原型之间的关系</p><blockquote><p><code>A.prototype.constructor</code>与<code>A</code>等价</p></blockquote><p>关于<code>function(class)A</code>的实例<code>a</code>与它的原型之间的关系</p><blockquote><p><code>a.__proto__</code>与<code>A.prototype</code>等价</p></blockquote><p>在上面两个等价条件的基础上，就可以很容易得到</p><blockquote><p><code>a.__proto__.prototype.constructor</code>与<code>A</code>等价</p></blockquote><p>这是一般的类和对象实例之间的原型继承关系。</p><p>在此基础上，对于<code>Object</code>和<code>Function</code>还有一些特殊的关系。</p><p>关于<code>function(class)A</code>和<code>Function</code>之间的关系</p><blockquote><p><code>A.__proto__</code>与<code>Function.prototype</code>等价</p></blockquote><p>关于<code>function(class)A</code>的原型和<code>Object</code>之间的关系</p><blockquote><p><code>A.prototype.__proto__</code>与<code>Object.prototype</code>等价</p></blockquote><p>关于<code>Function</code>的原型和<code>Object</code>之间的关系</p><blockquote><p><code>Function.prototype.__proto__</code>与<code>Object.prototype</code>等价</p></blockquote><p>所以也可以很容易知道</p><blockquote><p><code>A.__proto__.__proto__</code>与<code>Object.prototype</code>等价</p></blockquote><p><code>Object</code>对象比较特殊，因为它是所有对象的根，所以约定它的原型所指向的原型对象为空</p><blockquote><p><code>Object.prototype.__proto__</code>与<code>null</code>等价</p></blockquote><p>同时javascript中一切皆为对象，但<code>Object</code>本身是一个构造函数，因此它本身的原型对象指向<code>Function.prototype</code></p><blockquote><p><code>Object.__proto__</code>与<code>Function.prototype</code></p></blockquote><h2>总结</h2><p>所以无论是es5风格的继承还是es6风格的继承语法，原型链的形成是都是通过<code>__proto__</code>和<code>prototype</code>描述的，举个例子，这里使用<code>es6</code>, 即:</p><p>如果有:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class B extends A &#123;&#125;</span><br><span class="line">const a = new B()</span><br></pre></td></tr></table></figure></p><p>则有：</p><ul><li><code>a.__proto__ === B.prototype</code></li><li><code>B.prototype.constructor.__proto__ === B.__proto__</code></li><li><code>B.__proto__ === A</code></li><li><code>A.prototype.constructor.__proto === A.__proto__</code></li><li><code>A.__proto__ === Function.prototype</code></li><li><code>Function.prototype.__proto__ === Object.prototype</code></li><li><code>Object.prototype.__proto__ === null</code></li></ul><p>其他的以此类推。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;虽然现在es8都已经在预发布阶段了，但是无论发布到es几，其本身的运作原理都是一样的。&lt;/p&gt;
&lt;p&gt;首先祭上一张图, 这张图主要描述了以下的关系，如果觉的这里的说明过于复杂可以直接看&lt;a href=&quot;#%E6%80%BB%E7%BB%93&quot;&gt;最
      
    
    </summary>
    
      <category term="原创" scheme="http://littlelyon.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="js" scheme="http://littlelyon.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>【译】Understanding SOLID Principles - Liskov Substitution Principle</title>
    <link href="http://littlelyon.com/2018/02/08/SOLID-l/"/>
    <id>http://littlelyon.com/2018/02/08/SOLID-l/</id>
    <published>2018-02-08T03:16:57.000Z</published>
    <updated>2018-04-04T11:53:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://codeburst.io/understanding-solid-principles-liskov-substitution-principle-e7f35277d8d5" target="_blank" rel="noopener">Understanding SOLID Principles: Liskov Substitution Principle</a></h1><blockquote><p>这是理解<code>SOLID</code>原则，关于<strong>里氏替换原则</strong>为什么提倡我们面向抽象层编程而不是具体实现层，以及为什么这样可以使代码更具维护性和复用性。</p></blockquote><h2>什么是里氏替换原则</h2><blockquote><p>Objects should be replaceable with instances of their subtypes without altering the correctness of that program.</p></blockquote><blockquote><p>某个对象实例的子类实例应当可以在不影响程序正确性的基础上替换它们。</p></blockquote><p>这句话的意思是说，当我们在传递一个父抽象的子类型时，你需要保证你不会修改任何关于这个父抽象的行为和状态语义。</p><p>如果你不遵循里氏替换原则，那么你可能会面临以下问题：</p><ul><li>类继承会变得很混乱，因此奇怪的行为会发生</li><li>对于父类的单元测试对于子类是无效的，因此会降低代码的可测试性和验证程度</li></ul><p>通常打破这条原则的情况发生在修改父类中在其他方法中使用的，与当前子类无关联的内部或者私有变量。这通常算得上是一种对于类本身的一次潜在攻击，而且这种攻击可能是你在不经意间自己发起的，而且不仅在子类中。</p><h2>反面例子</h2><p>让我们通过一个<strong>反面例子</strong>来演示这种修改行为和它所产生的后果。比如，我们有一个关于<code>Store</code>的抽象类和它的实现类<code>BasicStore</code>，这个类会储存一些消息在内存中，直到储存的个数超过每个上限。客户端代码的实现也很简单明了，它期望通过调用<code>retrieveMessages</code>就可以获取到所有储存的消息。</p><p>代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">interface Store &#123;</span><br><span class="line">    store(message: string);</span><br><span class="line">    retrieveMessages(): string[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const STORE_LIMIT = 5;</span><br><span class="line"></span><br><span class="line">class BasicStore implements Store &#123;</span><br><span class="line">   protected stash: string[] = [];</span><br><span class="line">   protected storeLimit: number = STORE_LIMIT;</span><br><span class="line">  </span><br><span class="line">   store(message: string) &#123;</span><br><span class="line">     if (this.storeLimit === this.stash.length) &#123;</span><br><span class="line">         this.makeMoreRoomForStore();</span><br><span class="line">      &#125;</span><br><span class="line">      this.stash.push(message);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    retrieveMessages(): string[] &#123;</span><br><span class="line">      return this.stash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    makeMoreRoomForStore(): void &#123;</span><br><span class="line">       this.storeLimit += 5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后通过继承<code>BasicStore</code>，我们又创建了一个新的<code>RotatingStore</code>实现类，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class RotatingStore extends BasicStore &#123;</span><br><span class="line">    makeMoreRoomForStore() &#123;</span><br><span class="line">        this.stash = this.stash.slice(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意<code>RotatingStore</code>中覆盖父类<code>makeMoreRoomForStore</code>方法的代码以及它是如何隐蔽地改变了父类<code>BasicStore</code>关于<code>stash</code>的状态语义的。它不仅修改了<code>stash</code>变量，还销毁了在程序进程中已储存的消息已为将来的消息提供额外的空间。</p><p>在使用<code>RotatingStore</code>的过程中，我们会遇到一些奇怪的现象，这正式由于<code>RotatingStore</code>本身产生的，如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const st: Store = new RotatingStore()</span><br><span class="line"></span><br><span class="line">st.store(&quot;hello&quot;)</span><br><span class="line">st.store(&quot;world&quot;)</span><br><span class="line">st.store(&quot;how&quot;)</span><br><span class="line">st.store(&quot;are&quot;)</span><br><span class="line">st.store(&quot;you&quot;)</span><br><span class="line">st.store(&quot;today&quot;)</span><br><span class="line">st.store(&quot;sir?&quot;)</span><br><span class="line"></span><br><span class="line">st.retrieveMessages() // 一些消息丢失了</span><br></pre></td></tr></table></figure></p><p>一些消息会无故消失，当前这个类的表现逻辑与所有消息均可以被取出的基本需求不一致。</p><h2>如何实践里氏替换原则</h2><p>为了避免这种奇怪现象的发生，里氏替换原则推荐我们通过在子类中调用父类的公有方法来获取一些内部状态变量，而不是直接使用它。这样我们就可以保证父类抽象中正确的状态语义，从而避免了副作用和非法的状态转变。</p><p>它也推荐我们应当尽可能的使基本抽象保持简单和最小化，因为对于子类来说，有助于提供父类的扩展性。如果一个父类是比较复杂的，那么子类在覆盖它的时候，在不影响父类状态语义的情况下进行扩展绝非易事。</p><p>对于内部系统做可行的后置条件检查也是一个不错的方式，这种检查通常会验证是否子类会搅乱一些关键代码的运行路径（译者注：也可以理解为状态语义），但是我本身对这个实践并没有太多的经验，所以无法给予具体的例子。</p><p>代码评论也可以一定程度上给予好的帮助。当你在开发一些你可能无意间做出一些对已有系统的破坏，但是你的同事可能会很容易地发现这些（当局者迷旁观者清）。软件设计保持一致性是一件十分重要的事情，因此应当尽早、尽可能多地查明那些对对象继承链作出潜在修改的代码。</p><p>最后，在<strong>单一职责原则</strong>中，我们曾提及，考虑使用<strong>组合模式</strong>来替换<strong>继承模式</strong>。</p><h2>总结</h2><p>正如你所看到的，在开发软件时，我们往往需要额外花一些努力和精力来使它变得更好。将这些原则牢记于心，理解它们所存在的意义以及它们想要解决的问题，这样会使你的工作变得更加容易、更具条理性，但是同时记住，这并不是一件容易的事，相反，你应当在构思软件时，花相当多的事件思考如何更好地实践这些原则。</p><p>试着让自己设计的软件系统具备可适应性，这种适应性可以抵御各种不利的变化以及潜在的错误，这样自然而然地可以使你少加班和早回家（译者注：看来加班是每个程序员都要面临的问题啊）</p><h2>译者注</h2><p>这是<strong>SOLID</strong>原则中我所接触和了解较少的一个原则，但经过仔细思考后，发现其实我们还是经常会在实际工作中运用它的。</p><p>在许多面向相对的编程语言中，关于对象的继承机制中，都会提供一些内部变量和状态的修饰符，比如<code>public（公有）</code>、<code>protect（保护）</code>和<code>private（私有）</code>，关于这些修饰符本身的异同这里不再赘述，我想说的是，这些修饰符存在必然有它存在的意义，一定要在实际工作中，使用它们。之前做java后端时，经常在公司的项目的历史代码中发现，很少使用<code>protect</code>和<code>private</code>对类内部的方法和变量做约束，可见当时的编写者并没有对类本身的职能有一个清晰的认识，又或者是随着时间一步步迭代出来的结果。</p><p>那么问题来了，一些静态语言有这些修饰符，但是像<code>javascript</code>这种鸭子类型语言怎么办呢？其实没有必要担心，最早开始学前端的时候，这个问题我就问过自己无数次，<code>javascript</code>虽然没有这些修饰符，但是我们可以通过别的方式来达到类似的效果，或者使用<code>typescript</code>。</p><p>除了在编程语言层面，在前端实际工作中，你可能会听到一个叫作<code>immutable</code>的概念，这个概念我认为也是里氏替换原则的一直延伸。因为当前的前端框架一般提倡的理念均是<code>f(state) =&gt; view</code>，即数据状态代表视图，而数据状态本身由于<code>javascript</code>动态语言的特性，很容易会在不经意间被修改，一旦存在这种修改，视图中便会产生一些意想不到的问题，因此<code>immutable</code>和<code>函数式</code>的概念才会在前段时间火起来。</p><h2>写在最后</h2><p>经过这五篇文章，我们来分别总结一下这五条基本原则以及它们带来的好处：</p><ul><li>单一职责原则：提高代码实现层的内聚度，降低实现单元彼此之间的耦合度</li><li>开闭原则：提高代码实现层的可扩展性，提高面临改变的可适应性，降低修改代码的冗余度</li><li>里氏替换原则：提高代码抽象层的可维护性，提高实现层代码与抽象层的一致性</li><li>接口隔离原则：提高代码抽象层的内聚度，降低代码实现层与抽象层的耦合度，降低代码实现层的冗余度</li><li>依赖倒置原则：降低代码实现层由依赖关系产生的耦合度，提高代码实现层的可测试性</li></ul><p>可以注意到我这里刻意使用了<code>降低/提高 + 实现层/抽象层 + 特性/程度（耦合度、内聚度、扩展性、冗余度、可维护性，可测试性）</code>这样的句式，之所以这么做是因为在软件工作中，我们理想中的软件应当具备的特点是, 高内聚、低耦合、可扩展、少冗余、可维护、易于测试，而这五个原则也按正确的方向，将我们的软件系统向我们理想中的标准推进。</p><p>为了便于对比，特别绘制了下面的表格，希望大家从真正意义上做到将这些原则牢记于心，并付诸于行。</p><table><thead><tr><th>原则</th><th>耦合度</th><th>内聚度</th><th>扩展性</th><th>冗余度</th><th>维护性</th><th>测试性</th><th>适应性</th><th>一致性</th></tr></thead><tbody><tr><td>单一职责原则</td><td>-</td><td>+</td><td>o</td><td>o</td><td>+</td><td>+</td><td>o</td><td>o</td></tr><tr><td>开闭原则</td><td>o</td><td>o</td><td>+</td><td>-</td><td>+</td><td>o</td><td>+</td><td>o</td></tr><tr><td>里氏替换原则</td><td>-</td><td>o</td><td>o</td><td>o</td><td>+</td><td>o</td><td>o</td><td>+</td></tr><tr><td>接口隔离原则</td><td>-</td><td>+</td><td>o</td><td>-</td><td>o</td><td>o</td><td>+</td><td>o</td></tr><tr><td>依赖倒置原则</td><td>-</td><td>o</td><td>o</td><td>-</td><td>o</td><td>+</td><td>+</td><td>o</td></tr></tbody></table><p>Note: <code>+</code>代表增加, <code>-</code>代表降低, <code>o</code>代表持平</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;a href=&quot;https://codeburst.io/understanding-solid-principles-liskov-substitution-principle-e7f35277d8d5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
      <category term="翻译" scheme="http://littlelyon.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="principle" scheme="http://littlelyon.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>【译】Understanding SOLID Principles - Interface Segregation Principle</title>
    <link href="http://littlelyon.com/2018/02/08/SOLID-i/"/>
    <id>http://littlelyon.com/2018/02/08/SOLID-i/</id>
    <published>2018-02-08T01:40:33.000Z</published>
    <updated>2018-04-04T11:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://codeburst.io/understanding-solid-principles-interface-segregation-principle-b2d57026cf6c" target="_blank" rel="noopener">Understanding SOLID Principles: Interface Segregation Principle</a></h1><blockquote><p>这是理解<code>SOLID</code>原则，关于<strong>接口隔离</strong>原则如何帮助我们创建简单的抽象接口，并使客户端代与接口之间存在的更少的依赖关系。</p></blockquote><h2>接口隔离原则是什么</h2><blockquote><p>Clients should not be forced to depend on methods that they do not use.</p></blockquote><blockquote><p>客户端代码不应当被迫依赖于它们不需要的方法。</p></blockquote><p>这个原则本身与单一职责原则关系十分紧密，它意味着当你在定义你的抽象层代码时，不应当在客户端代码在实现抽象逻辑时，暴露一些客户端代码不需要使用或者关心的方法。</p><p>进一步说明的话，就是当你有意地在抽象层中暴露的方法时，这意味着所有实现这些抽象逻辑的客户端代码都必须要实现所有的抽象方法，尽管这些方法并不一定都对客户端代码有意义。</p><p>将你的接口的保持精简和小颗粒度，并且不要在它们中间增加无用的抽象方法，当你在对新的抽象接口进行命名时，你就会拥有更好的选择，因为你已有了若干小颗粒的命名类型。这样做的意义在于当你在需要提供一个更加大颗粒度的抽象接口时，你可以拥有足够的灵活性来将已有的小颗粒度接口进行组合。</p><h2>如何实践接口隔离原则</h2><p>这个例子是关于一个ATM用户界面的抽象接口，这个接口会处理诸如存款请求、取款请求等逻辑，从这个例子中我们会了解到，我们如何对这个接口进行隔离，使其进一步划分为多个独立的、更加具体的若干接口。</p><p>首先我们应当有一个工具函数库接口，这个接口会描述我们想要暴露的关于<code>byte</code>操作逻辑的方法，让我们创建这样一个接口，如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type ByteUtils interface &#123;</span><br><span class="line">    Read(b []byte) (n int, err error) // Read into buffer</span><br><span class="line">    Write(b []byte)(n int, err error) // Write into buffer</span><br><span class="line">    Trim(b []byte, exclusions string)[]byte // Trim buffer by removing bytes from the exclusion chars</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它可以正常工作一段时间，但是很快我们就会发现以下两个问题：</p><ul><li>它的命名<code>ByteUtils</code>太过于通用，如果我们仅通过命名本身，基本无法获取任何具体的信息</li><li>当使用它时，会有一些古怪的感觉，因为当你根据不同的优化场景来按不同逻辑实现<code>trim</code>方法时，你所实现的<code>read</code>和<code>write</code>几乎没什么差别，但是你却需要重复地实现它们，同时在某些不需要读或者写的场景，仍然需要实现它们。</li></ul><p>所以它虽然能够正常工作，但是却不够好。</p><p>我们可以通过创建三个更精简、更具体的接口来替代原先通用的接口：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Reader interface &#123;</span><br><span class="line">    Read(b []byte) (n int, err error) </span><br><span class="line">&#125;</span><br><span class="line">type Writer interface &#123;</span><br><span class="line">    Write(b []byte)(n int, err error) </span><br><span class="line">&#125;</span><br><span class="line">type Trimmer interface &#123;</span><br><span class="line">    Trim(b []byte, exclusions string)[]byte </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种颗粒度比较细的接口也可以称为<strong>角色接口</strong>，因为它们更易于重构和改变，甚至对于已经定义好的角色和目的也可以很容易的进行重新部署和定义。</p><p>在这三个基础上，我们可以通过组合它们来获取一个更有关联性的接口列表，比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type ReadWriter interface &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer </span><br><span class="line">&#125;</span><br><span class="line">type TrimReader interface &#123;</span><br><span class="line">    Trimmer</span><br><span class="line">    Reader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这意味客户端代码拥有了可以根据它们各自的需求来组合抽象层接口的灵活性，这样就会避免在实现抽象接口时不必要的麻烦（比如必须要实现某些无用的方法），比如上面的<code>TrimReader</code>的实现并未包含多余的<code>Write</code>方法的声明。</p><h2>总结</h2><p>正如你所看到的，通用的接口往往会无意识的将自己和类的实现耦合在了一起，所以你应当尽量的避免这种情况的发生。在设计接口时，你应当时刻提醒自己，我是否需要使用所有在接口中声明的方法呢？如果不是的话，将接口细分为更多个更精简、更具体的接口。</p><p>正如甘地曾经说过：</p><blockquote><p>你的行动决定你的习惯，你的习惯决定你的价值，你的价值会决定你的命运。</p></blockquote><p>如果在架构中，你每次都会经过仔细思考，会按照好的模式来进行设计，它将会成为一种习惯，自然慢慢会转变为你的价值或者原则，最终则会成为你的命运，比如成为了一个始终给予完善解决方案的软件架构师。</p><p>我的观点是，始终通过挑战自己来变的更好，在某些时刻，你可能会遇到问题，但是往往你可能已经拥有了答案。</p><p>Happy coding!</p><h2>译者注</h2><p>对于接口隔离原则的理解，我一直觉的它本身其实是单一职责原则的一个扩展，但是它们之间也有细微的不同：</p><ul><li>单一职责原则往往面向实现层，比如具体的类或者某个方法</li><li>接口隔离原则往往面向抽象层，比如一些抽象类或者抽象方法</li></ul><p>所以将两个原则结合起来看的话，可以很容器得到当时提出这两个原则的人的意图，那就是一定要时刻<code>保持简单</code>。</p><p>在实际工作中，我深知<strong>保持简单</strong>是一件十分困难的事情，因为工程师本身的使命便是解决问题，而问题往往充满了未知性，而未知性往往代表着改变，这还没有考虑到在项目实施过程中，产品经理天马行空的设计思路，客户们五花八门的需求等等。在这些外界条件下，我们的代码往往会变得复杂无比，充满了各种反模式和冗余代码，最终会使自己陷入无尽的bug修复和维护工作中，怎么还会有时间进行自我提升呢？</p><p>所以，为了能够按时下班，为了能够及早回家，为了能够让我们的拥有更多的时间来提升自己和陪伴家人，在软件设计之初，尽可能地针对将来所面临的改变，在设计层面降低软件抽象模块间的耦合程度，在项目实施时，提高每个具体实现模块内部的内聚程度，同时使它们保持简单，这样便是一个好的开始。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;a href=&quot;https://codeburst.io/understanding-solid-principles-interface-segregation-principle-b2d57026cf6c&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
      <category term="翻译" scheme="http://littlelyon.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="principle" scheme="http://littlelyon.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>【译】Understanding SOLID Principles - Open Closed Principle</title>
    <link href="http://littlelyon.com/2018/02/04/SOLID-o/"/>
    <id>http://littlelyon.com/2018/02/04/SOLID-o/</id>
    <published>2018-02-04T01:34:48.000Z</published>
    <updated>2018-04-04T11:54:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://codeburst.io/understanding-solid-principles-open-closed-principle-e2b588b6491f" target="_blank" rel="noopener">Understanding SOLID Principles: Open Closed Principle</a></h1><blockquote><p>这是理解<code>SOLID</code>原则，介绍什么是<strong>开闭原则</strong>以及它为什么能够在对已有的软件系统或者模块提供新功能时，避免不必要的更改（重复劳动）。</p></blockquote><h2>开闭原则是什么</h2><blockquote><p>Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.</p></blockquote><blockquote><p>软件实体（类、模块、函数等）都应当对扩展具有开放性，但是对于修改具有封闭性。</p></blockquote><p>首先，我们假设在代码中，我们已经有了若干抽象层代码，比如类、模块、高阶函数，它们都仅做一件事（还记得单一职责原则吗？），并且都做的十分出色，所以我们想让它们始终处于简洁、高内聚并且好用的状态。</p><p>但是另一方面，我们还是会面临改变，这些改变包含范围（译者注：应当是指抽象模块的职责范围）的改变，新功能的增加请求还有新的业务逻辑需求。</p><p>所以对于上面我们所拥有的抽象层代码，在长期想让它处于一成不变的状态是不现实的，你不可避免的会针对以上的需要作出改变的需求，增加更多的功能，增加更多的逻辑和交互。在上一篇文章，我们知道，改变会使系统复杂，复杂会促使模块间的耦合性上升，所以我们迫切地需要寻找一种方法能够使我们的抽象模块不仅可以扩大它的职责范围，同时还能够保持当前良好的状态（简洁、高内聚、好用）。</p><p>这便是<strong>开闭原则</strong>存在的意义，它能够帮助我们完美地实现这一切。</p><h2>如何实践开闭原则</h2><p>当你需要对已有代码作出一些修改时，请切记以下两点：</p><ul><li>保持函数、类、模块当前它们本身的状态，或者是近似于它们一般情况下的状态（即不可修改性）</li><li>使用组合的方式（避免使用继承方式）来扩展现有的类，函数或模块，以使它们可能以不同的名称来暴露新的特性或功能</li></ul><p>这里关于继承，我们特意增加了一个注释，在这种情况下使用继承可能会使模块之间耦合在一起，同时这种耦合是可避免的，我们通常在一些预先有着良好定义的结构上使用继承。（译者注：这里应该是指，对于我们预先设计好的功能，推荐使用继承方式，对于后续新增的变更需求，推荐使用组合方式）</p><p>举个例子（译者注：我对这里的例子做了一些修改，原文中并没有详细的说明）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface IRunner &#123;</span><br><span class="line">  run: () =&gt; void;</span><br><span class="line">&#125;</span><br><span class="line">class Runner implements IRunner &#123;</span><br><span class="line">  run(): void &#123;</span><br><span class="line">    console.log(&quot;9.78s&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IJumper &#123;</span><br><span class="line">  jump: () =&gt; void;</span><br><span class="line">&#125;</span><br><span class="line">class Jumper implements IJumper &#123;</span><br><span class="line">  jump(): void &#123;</span><br><span class="line">    console.log(&quot;8.95,&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例子中，我们首先声明了一个<code>IRunner</code>接口，之后又声明了<code>IJumper</code>，并分别实现了它们，并且实现类的职能都是单一的。</p><p>假如现在我们需要提供一个既会跑又会跳的对象，如果我们使用继承的方式，可以这么写<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class RunnerAndJumper extends Runner &#123;</span><br><span class="line">  jump: () =&gt; void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class RunnerAndJumper extends Jumper &#123;</span><br><span class="line">  run: () =&gt; void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是使用继承的方式会使这个<code>RunnerAndJumper</code>与<code>Runner</code>（或者<code>Jumper</code>）耦合在一起（耦合在一起的原因是因为它的职责不再单一），我们再来用组合的方式试试看，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class RunnerAndJumper &#123;</span><br><span class="line">  private runnerClass: IRunner;</span><br><span class="line">  private jumperClass: IJumper;</span><br><span class="line">  constructor(runner: IRunner, jumper: IJumper) &#123;</span><br><span class="line">    this.runnerClass = new runner();</span><br><span class="line">    this.jumperClass = new jumper();</span><br><span class="line">  &#125;</span><br><span class="line">  run() &#123;</span><br><span class="line">    this.runnerClass.run();</span><br><span class="line">  &#125;</span><br><span class="line">  jump() &#123;</span><br><span class="line">    this.jumperClass.jump();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在<code>RunnerAndJumper</code>的构造函数中声明两个依赖，一个是<code>IRunner</code>类型，一个是<code>IJumper</code>类型。</p><p>最终的代码其实和<strong>依赖倒置原则</strong>中的例子很像，而且你会发现，<code>RunnerAndJumper</code>类本身并没有与任何别的类耦合在一起，它的职能同样是单一的，它是对一个即会跑又会跳的实体的抽象，并且这里我们还可以使用<code>DI（依赖注入）</code>技术进一步的优化我们的代码，降低它的耦合度。</p><h2>反思</h2><p><strong>开闭原则</strong>所带来最有用的好处就是，当我们在实现我们的抽象层代码时，我们就可以对未来可能需要作出改变的地方拥有一个比较完整的设想，这样当我们真正面临改变时，我们所对原有代码的修改，更贴近于改变本身，而不是一味的修改我们已有的抽象代码。</p><p>在这种情况下，由于我们节省了不必要的劳动和时间，我们就可以将更多的精力投入到关于更加长远的事宜计划上面，而且可以针对这些事宜需要作出的改变，提前和团队沟通，最终给予一套更加健壮、更符合系统模块本身的解决方案。</p><p>在整个软件开发周期中（比如一个敏捷开发周期），你对于整个周期中的事情了解的越透彻、越多，则越好。身为一个工程师，在一个开发冲刺中，为了在冲刺截止日期结束前，实现一个高效的、可靠的系统，你不会期望作出太多的改变，因此往往你可能会“偷工减料”。</p><p>从另一个角度来讲，我们也应当致力于在每一次面临需求变更的情况下，不需要一而再，再而三的更改我们已有的代码。所有新的功能都应当通过增加一个新的组合类或方法实现，或者通过复用已有的代码来实现。</p><h2>插件与中间件</h2><p>充分贯彻开闭原则的另一个例子，便是<strong>插件与中间件</strong>架构，我们可以从三个角度来简单分析这种架构是如何运作的：</p><ul><li>内核或者容器：往往是核心功能的实现的前提，一般会成为整个系统最核心的部分</li><li>插件：在实现容器的基础上，往往一些核心功能都是以内置的插件实现的，并且，通过实现一套通用的网关类接口，我们可以使插件具有可插拔性，这样在需要新增特性和功能时，只需要实现新的插件并添加到容器即可，比如支持插件扩展功能的浏览器<code>Chrome</code>。</li><li>中间件：中间件我们可以通过一个例子来说明，比如我们拥有一个请求 - 响应周期，我们可以通过中间件，在周期中添加中间业务逻辑，以便为应用程序提供额外的服务或横切关注点，比如<code>Redux</code>、<code>express</code>还有很多框架都支持这样的功能。</li></ul><h2>总结</h2><p>希望这篇文章能够帮助你学会如何应用<strong>开闭原则</strong>并且从中收益。设计一个具有可组合性的系统，同时提供具有良好定义的扩展接口，是一种非常有用的技术，这种技术最关键的地方在于，它使我们的系统能够在保持强健的同时，提供新功能、新特性，但是却不会影响它当前的状态。</p><h2>译者注</h2><p>开闭原则是面向对象编程中最重要的原则之一，有多重要呢？这么说吧，很多的设计原则和设计模式所希望达成的最终状态，往往符合开闭原则，因此需要原则也都作为实现开闭原则的一种手段，在原文的例子中，我们可以很明显的体会到，在实现开闭原则所提倡的理念的过程中，我们不经意地使用之前两篇文章中涉及的原则，比如：</p><ul><li>保持对象的单一性（单一职责）</li><li>实现依赖于抽象（依赖倒置原则）</li></ul><p>我之前一直是做后端相关工作的，所以对于开闭原则接触较早，这两年转行做了前端，随着<code>nodejs</code>的发展，框架技术日新月异，但是其中脱颖而出的优秀框架往往是充分贯彻了开闭原则，比如<code>express</code>、<code>webpack</code>还有状态管理容器<code>redux</code>，它们均是开闭原则的最佳实践。</p><p>另外一方面，在这两年的工作也感受到，适当的使用函数式编程的思想，往往是贯彻开闭原则一个比较好的开始，因为函数式的编程中的核心概念之一便是<code>compose（组合）</code>。以函数式描述业务往往是原子级的指令，之后在需要描述更复杂的业务时，我们复用并组合之前已经存在的指令以达到目的，这恰恰符合开闭原则所提倡的可组合性。</p><p>最后在分享一些前端中，经常需要使用开闭原则的最佳业务场景，</p><ul><li>UI组件的表单组件：对于表单本身以容器来实现，表单项以插件来实现，这样对于表单项如何渲染、如何加载、如何布局等功能，均会封闭与表单容器中，而对于表单项如何校验、如何取值、如何格式化等功能，则会开放与表单项容器中。</li><li>API服务：一般我们可能会在项目中提供自定义修改请求头部的工具方法，并在需要的时候调用。但这其实是一种比较笨的方法，如果可能的话，建议使用拦截器来完成这项任务，不仅会提供代码的可读性，同时还会使发接口的业务层代码保持封闭。</li><li>事件驱动模型：对于一些复杂的事件驱动模型，比如拖拽，往往使用开闭原则会达到意想不到的效果。最近有一个比较火的拖拽库<a href="https://github.com/Shopify/draggable" target="_blank" rel="noopener">draggable</a>，提供的拖拽体验相比其他同类型的库简直不是一个级别。我前段时间去读它的源码，发现它之所以强大，是因为在它内部，针对多种拖拽事件，封装了独立的事件发射器（其内部称作<code>Sensor</code>），之后根据这些发射器指定了一套独立的抽象事件驱动模型，在这个模型基础上，针对不同的业务场景提供不同的插件，比如：<ul><li>原生拖拽(Draggable)</li><li>拖拽排序(Sortable)</li><li>拖拽放置(Droppable)</li><li>拖拽交换(Swappable)</li></ul></li></ul><p>还有若干提高用户体验的其他插件，这一切均是以开闭原则而实现的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;a href=&quot;https://codeburst.io/understanding-solid-principles-open-closed-principle-e2b588b6491f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Understa
      
    
    </summary>
    
      <category term="翻译" scheme="http://littlelyon.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="principle" scheme="http://littlelyon.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>【译】Understanding SOLID Principles - Single Responsibility</title>
    <link href="http://littlelyon.com/2018/02/02/SOLID-s/"/>
    <id>http://littlelyon.com/2018/02/02/SOLID-s/</id>
    <published>2018-02-02T07:28:46.000Z</published>
    <updated>2018-04-04T11:54:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://codeburst.io/understanding-solid-principles-single-responsibility-b7c7ec0bf80" target="_blank" rel="noopener">Understanding SOLID Principles: Single Responsibility</a></h1><blockquote><p>这是理解<code>SOLID</code>原则中，关于<strong>单一职责原则</strong>如何帮助我们编写低耦合和高内聚的第二篇文章。</p></blockquote><h2>单一职责原则是什么</h2><p>之前的第一篇文章阐述了**依赖倒置原则（DIP）**能够使我们编写的代码变得低耦合，同时具有很好的可测试性，接下来我们来简单了解下单一职责原则的基本概念：</p><blockquote><p>Every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class.</p></blockquote><blockquote><p>每一个模块或者类所对应的职责，应对应系统若干功能中的某个单一部分，同时关于该职责的封装都应当通过这个类来完成。</p></blockquote><p>往简单来讲：</p><blockquote><p>A class or module should have one, and only one, reason to be changed.</p></blockquote><blockquote><p>一个类或者模块应当用于单一的，并且唯一的<strong>缘由</strong>被更改。</p></blockquote><p>如果仅仅通过这两句话去理解, 一个类或者模块如果如果越简单（具有单一职责），那么这个类或者模块就越容易被更改是有一些困难的。为了便于我们理解整个概念，我们将分别从三个不同的角度来分析这句话，这三个角度是：</p><ul><li>Single: 单一</li><li>Responsibility: 职责</li><li>Change: 改变</li></ul><h2>什么是<code>单一</code></h2><blockquote><p>Only one; not one of several.</p></blockquote><blockquote><p>唯一的，而不是多个中的某个。</p></blockquote><blockquote><p>Synonyms: one, one only, sole, lone, solitary, isolated, by itself.</p></blockquote><blockquote><p>同义词：一，仅有的一个，唯一，独个，独自存在的，孤立的，仅自己。</p></blockquote><p><strong>单一</strong>意味着某些工作是独立的。比如，在类中，类方法仅完成某家独立的事情，而不是两件，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class UserComponent &#123; </span><br><span class="line">  // 这是第一件事情，获取用户详情数据</span><br><span class="line">  getUserInfo(id) &#123;</span><br><span class="line">    this.api.getUserInfo(id).then(saveToState)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 这是第二件事情，渲染视图的逻辑</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; userInfo &#125; = this.state;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;Name: &#123; userInfo.name &#125;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;Surname: &#123; userInfo.surname &#125;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;Email: &#123; userInfo.email &#125;&lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看了上面的代码，你可能很快就会联想到，这些代码基本存在于所有的<code>React</code>组件中。</p><p>确实，对于一些小型的项目或者演示型项目，这样编写代码不会产生太大的问题。但是如果在大型或者复杂度很高的项目中，仍然按照这样的风格，则是一件比较糟糕的事情，因为一个组件往往做了它本不应当做的事情（承担了过多的职责）。</p><p>这样会带来什么坏处呢？比如对于以上的<code>api</code>服务，在将来的某天你做出了一些修改，增加了一些额外的逻辑，那么为了使代码能够正常工作，你至少需要修改项目中的两个地方以适应这个修改，一处修改是在<code>API</code>服务中，而另一处则在你的组件中。如果进一步思考的，我们会发现，修改次数与在项目直接使用<code>API</code>服务的次数成正比，如果项目足够复杂，足够大，一处简单的逻辑修改，就需要做出一次贯穿整个系统的适配工作。</p><p>那么我们如果避免这种情况的发生呢？很简单，我们仅仅需要将<strong>关于用户详情数据</strong>的逻辑提升到调用层，在上面的例子中，我们应当使用<code>React.component.prop</code>来接受用户详情数据。这样，<code>UserComponent</code>组件的工作不再与如何获取用户详情数据的逻辑耦合，从而变得<strong>单一</strong>。</p><p>对于鉴别什么是单一，什么不是单一，有很多不同的方式。一般来说，只需要牢记，让你的代码尽可能的少的去了解它已经做的工作。（译者注：我理解意思应当是，应当尽可能的让已有的类或者方法变得简单、轻量，不需要所有事情都亲自为之）</p><p>总之，不要让你的对象成为<strong>上帝对象</strong>。</p><blockquote><p>A God Object aka an Object that knows everything and does everything.</p></blockquote><blockquote><p>上帝对象，一个知道一切事情，完成一切事情的对象。</p></blockquote><blockquote><p>In object-oriented programming, a God object is an object that knows too much or does too much. The God object is an example of an anti-pattern.</p></blockquote><blockquote><p>在面向对象编程中，上帝对象指一个了解太情或者做太多事情的对象。上帝对象是反模式的一个典型。</p></blockquote><h2>什么是<code>职责</code></h2><p>职责指软件系统中，每一个指派给特定方法、类、包和模块所完成的工作或者动作。</p><blockquote><p>Too much responsibility leads to coupling.</p></blockquote><blockquote><p>太多的职责导致耦合。</p></blockquote><p><strong>耦合性</strong>代表一个系统中某个部分对系统中另一个部分的了解程度。举个例子，如果一段客户端代码在调用<code>class A</code>的过程中，必须要先了解有关<code>class B</code>的细节，那么我们说<code>A</code>和<code>B</code>耦合在了一起。通常来说，这是一件糟糕的事情。因为它会使针对系统本身的变更复杂化，同时会在长期越来越糟。</p><p>为了使一个系统到达适当的耦合度，我们需要在以下三个方面做出调整</p><ul><li>组件的内聚性</li><li>如何测量每个组件的预期任务</li><li>组件如何专注于任务本身</li></ul><p>低内聚性的组件在完成任务时，和它们本身的职责关联并不紧密。比如，我们现在有一个<code>User</code>类，这个类中我们保存了一些基本信息：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  public age;  </span><br><span class="line">  public name;</span><br><span class="line">  public slug;</span><br><span class="line">  public email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于属性本身，如果对于每个属性声明一些<code>getter</code>或者<code>setter</code>方法是没什么问题的。但是如果我们加一些别的方法，比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  public age;  </span><br><span class="line">  public name;</span><br><span class="line">  public slug;</span><br><span class="line">  public email;</span><br><span class="line">  // 我们为什么要有以下这些方法？</span><br><span class="line">  checkAge();</span><br><span class="line">  validateEmail();</span><br><span class="line">  slugifyName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于<code>checkAge</code>、<code>validateEmail</code>、<code>slugifyName</code>的职责，与<code>User</code>class本身关系并不紧密，因此就会这些方法就会使<code>User</code>的内聚性变低。</p><p>仔细思考的话，这些方法的职责和校验和格式化用户信息的关系更紧密，因此，它们应当从<code>User</code>中被抽离出来，放入到另一个独立的<code>UserFieldValidation</code>类中，比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  public age;  </span><br><span class="line">  public name;</span><br><span class="line">  public slug;</span><br><span class="line">  public email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class UserFieldValidation &#123;</span><br><span class="line">  checkAge();</span><br><span class="line">  validateEmail();</span><br><span class="line">  slugifyName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>什么是<code>变更</code></h2><p>变更指对于已存在代码的修改或者改变。</p><p>那么问题来了，什么原因迫使我们需要对源码进行变更？从众多过期的软件系统的历史数据的研究来看，大体有三方面原因促使我们需要作出变更：</p><ul><li>增加新功能</li><li>修复缺陷或者bug</li><li>重构代码以适配将来作出的变更</li></ul><p>做为一个程序员，我们天天不都在做这三件事情吗？让我们来用一个例子完整的看一下什么是变更，比方说我们完成了一个组件，现在这个组件性能非常好，而且可读性也非常好，也许是你整个职业生涯中写的最好的一个组件了，所以我们给它一个炫酷的名字叫作<code>SuperDuper</code>（译者注：这个名字的意思是<strong>超级大骗子</strong>）</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SuperDuper &#123;</span><br><span class="line">  makeThingsFastAndEasy() &#123;</span><br><span class="line">    // Super readable and efficient code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后过了一段时间，在某一天，你的经理要求你增加一个新功能，比如说去调用别的<code>class</code>中的每个函数，从而可以使当前这个组件完成更多的工作。你决定将这个类以参数的形式传入构造方法，并在你的方法调用它。</p><p>这个需求很简单，只需要增加一行调用的代码即可，然后你做了以下<strong>变更(增加新功能)</strong>：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class SuperDuper &#123;</span><br><span class="line">  constructor(notDuper: NotSoDuper) &#123;</span><br><span class="line">    this.notDuper = notDuper</span><br><span class="line">  &#125;</span><br><span class="line">  makeThingsFastAndEasy() &#123;</span><br><span class="line">     // Super readable and efficient code</span><br><span class="line">    this.notDuper.invokeSomeMethod()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了，之后你针对你做的变更代码运行了单元测试，然后你突然发现这条简单的代码使<code>100</code>多条的测试用例失败了。具体原因是因为在调用<code>notDuper</code>方法之前，你需要针对一些额外的业务逻辑增加条件判断来决定是否调用它。</p><p>于是你针对这个问题又进行了一次<strong>变更(修复缺陷或者bug)</strong>，或许还会针对一些别的边界条件进行一些额外的修复和改动：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class SuperDuper &#123;</span><br><span class="line">  constructor(notDuper: NotSoDuper) &#123;</span><br><span class="line">    this.notDuper = notDuper</span><br><span class="line">  &#125;</span><br><span class="line">  makeThingsFastAndEasy() &#123;</span><br><span class="line">     // Super readable and efficient code</span><br><span class="line">    </span><br><span class="line">    if (someCondition) &#123;</span><br><span class="line">      this.notDuper.invokeSomeMethod()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.callInternalMethod()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>又过了一段时间，因为这个<code>SuperDuper</code>毕竟是你职业生涯完成的最棒的类，但是当前调用<code>noDuper</code>的方法实在是有点不够逼格，于是你决定引入事件驱动的理念来达到不在<code>SuperDuper</code>内部直接调用<code>noDuper</code>方法的目的。</p><p>这次实际是对已经代码的一次重构工作，你引入了事件驱动模型，并对已有的代码做出了<strong>变更(重构代码以适配将来作出的变更)</strong>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class SuperDuper &#123;</span><br><span class="line"> </span><br><span class="line">  makeThingsFastAndEasy() &#123;</span><br><span class="line">     // Super readable and efficient code</span><br><span class="line">     ...</span><br><span class="line">     dispatcher.send(actionForTheNotDuper(payload)) // Send a signal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在再来看我们的<code>SuperDuper</code>类，已经和最原始的样子完全不一样了，因为你必须针对新的需求、存在的缺陷和bug或者适配新的软件架构而做出变更。</p><p>因此为了便于我们做出变更，在代码的组织方式上，我们需要用心，这样才会使我们在做出变更时更加容易。</p><h2>如何才能使代码贴近这些原则</h2><p>很简单，只需要牢记，使代码保持足够简单。</p><blockquote><p>Gather together the things that change for the same reasons. Separate those things that change for different reasons.</p></blockquote><blockquote><p>将由于相同原因而做出改变的东西聚集在一起，将由于不同原因而做出改变的东西彼此分离。</p></blockquote><h3>孤立变化</h3><p>对于所编写的做出变更的代码，你需要仔细的检查它们，无论是从整体检查，还是有逻辑的分而治之，都可以达到孤立变化的目的。你需要更多的了解你所编写的代码，比如，为什么这样写，代码到底做了什么等等，并且，对于一些特别长的方法和类要格外关注。</p><blockquote><p>Big is bad, small is good…</p></blockquote><blockquote><p>大即是坏，小即是好。</p></blockquote><h3>追踪依赖</h3><p>对于一个类，检查它的构造方法是否包含了太多的参数，因为每一个参数都作为这个类的依赖存在，同时这些参数也拥有自身的依赖。如果可能的话，使用<code>DI</code>机制来动态的注入它们。</p><blockquote><p>Use Dependency Injection</p></blockquote><blockquote><p>使用依赖注入</p></blockquote><h3>追踪方法参数</h3><p>对于一个方法，检查它是否包含了太多参数，一般来讲，一个方法的参数个数往往代表了其内部所实现的职能。</p><p>同时，在方法命名上也投入一精力，尽可能地使方法名保持简单，它将帮助你在重构代码时，更好的达到单一职责。长的函数名称往往意味着其内部有糟糕的味道。</p><blockquote><p>Name things descriptively</p></blockquote><blockquote><p>描述性命名。</p></blockquote><h3>尽早重构</h3><p>尽可能早的重构代码，当你看到一些代码可以以更简明的方式进行时，重构它。这将帮助你在项目进行的整个周期不断的整理代码以便于更好的重构。</p><blockquote><p>Refactor to Design Patterns</p></blockquote><blockquote><p>按设计模式重构代码</p></blockquote><h3>善于做出改变</h3><p>最后，在需要做出改变时，果断地去做。当然这些改变会使系统的耦合性更低，内聚性更高，而不是往相反的方向，这样你的代码会一直建立在这些原则之上。</p><blockquote><p>Introduce change where it matters. Keep things simple but not simpler.</p></blockquote><blockquote><p>在重要的地方介绍改变。保持事情的简单性，但不是一味追求简单。</p></blockquote><h2>译者注</h2><p>单一职责原则其实在我们日常工作中经常会接触到，比方说</p><ul><li>我们经常会听到<code>DIY（dont repeat yourself）</code>原则，其本身就是单一职责的一个缩影，为了达到<code>DIY</code>，对于代码中的一些通用方法，我们经常会抽离到独立的<code>utils</code>目录甚至编写为独立的工具函数库, 比如<code>lodash</code>和<code>ramda</code>等等</li><li><code>OAOO</code>, 指<code>Once And Only Once</code>, 原则本身的含义可以自行搜索，实际工作中我们对于相同只能模块的代码应当尽可能去在抽象层合并它们，提供抽象类，之后通过继承的方式来满足不同的需求</li><li>我们都会很熟悉<code>单例模式</code>这个模式，但在使用时一定要小心，因为本质上单例模式与单一职责原则相悖，在实践中一定要具体情况具体分析。同时也不要过度优化，就如同文章中最后一部分提及的，我们要保证一件事情的简单性，但不是一味地为了简单而简单。</li><li>前端的技术栈中，redux对于数据流层的架构思想，便充分体现了单一职责原则的重要性，<code>action</code>作为对具体行为的抽象, <code>store</code>用来描述应用的状态，<code>reducer</code>作为针对不同行为如何对store作出修改的抽象。</li><li>react中经常提及的<code>木偶组件(dump component)</code>其实和文章中第一部分的例子如出一辙</li><li><code>工厂模式</code>和<code>命令模式</code>也一定程度体现了单一职责原则，前者对于作为生产者存在并不需要关心消费者如何消费对象实例，后者以命令的方式封装功能本身就是单一职责原则的体现。</li></ul><p>我能够想到的就这么多，写的比较乱，抛砖引玉，如有错误，还望指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;a href=&quot;https://codeburst.io/understanding-solid-principles-single-responsibility-b7c7ec0bf80&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Understan
      
    
    </summary>
    
      <category term="翻译" scheme="http://littlelyon.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="principle" scheme="http://littlelyon.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>【译】Understanding SOLID Principles - Dependency Inversion</title>
    <link href="http://littlelyon.com/2018/01/22/SOLID-d/"/>
    <id>http://littlelyon.com/2018/01/22/SOLID-d/</id>
    <published>2018-01-22T02:21:35.000Z</published>
    <updated>2018-04-04T11:53:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://codeburst.io/understanding-solid-principles-dependency-injection-d570c15560ab" target="_blank" rel="noopener">Understanding SOLID Principles: Dependency Inversion</a></h1><blockquote><p>这是理解<code>SOLID</code>原则中，关于<strong>依赖倒置</strong>原则如何帮助我们编写低耦合和可测试代码的第一篇文章。</p></blockquote><h2>写在前头</h2><p>当我们在读书，或者在和一些别的开发者聊天的时候，可能会谈及或者听到术语<code>SOILD</code>。在这些讨论中，一些人会提及它的重要性，以及一个理想中的系统，应当包含它所包含的5条原则的特性。</p><p>我们在每次的工作中，你可能没有那么多时间思考关于<strong>架构</strong>这个比较大的概念，或者在有限的时间内或督促下，你也没有办法实践一些好的设计理念。</p><p>但是，这些原则存在的意义不是让我们“跳过”它们。软件工程师应当将这些原则应用到他们的开发工作中。所以，在你每一次敲代码的时候，如何能够正确的将这些原则付诸于行，才是真正的问题所在。如果可以那样的话，你的代码会变得更优雅。</p><p><code>SOLID</code>原则是由5个基本的原则构成的。这些概念会帮助创造更好（或者说更健壮）的软件架构。这些原则包含（<code>SOLID</code>是这5个原则的开头字母组成的缩略词）：</p><ul><li>S stands for SRP (Single responsibility principle)：单一职能原则</li><li>O stands for OCP (Open closed principle)：开闭原则</li><li>L stands for LSP (Liskov substitution principle)：里氏替换原则</li><li>I stand for ISP ( Interface segregation principle)：接口隔离原则</li><li>D stands for DIP ( Dependency inversion principle)：依赖倒置原则</li></ul><p>起初这些原则是<a href="https://en.wikipedia.org/wiki/Robert_Cecil_Martin" target="_blank" rel="noopener">Robert C. Martin</a>在1990年提出的，遵循这些原则可以帮助我们更好的构建，低耦合、高内聚的软件架构，同时能够真正的对现实中的业务逻辑进行恰到好处的封装。</p><p>不过这些原则并不会使一个差劲的程序员转变为一个优秀的程序员。这些法则取决于你如何应用它们，如果你是很随意的应用它们，那等同于你并没有使用它们一样。</p><p>关于原则和模式的知识能够帮助你决定在何时何地正确的使用它们。尽管这些原则仅仅是启示性的，它们是常见问题的常规解决方案。实践中，这些原则的正确性已经被证实了很多次，所以它们应当成为一种常识。</p><h2>依赖倒置原则是什么</h2><ul><li>高级模块不应当依赖于低级模块。它们都应当依赖于抽象。</li><li>抽象不应当依赖于实现，实现应当依赖于抽象。</li></ul><p>这两句话的意思是什么呢？</p><p>一方面，你会抽象一些东西。在软件工程和计算机科学中，抽象是一种关于规划计算机系统中的复杂性的技术。它的工作原理一般是在一个人与系统交互的复杂环境中，隐藏当前级别下的更复杂的实现细节，同时它的范围很广，常常会覆盖多个子系统。这样，当我们在与一个以高级层面作为抽象的系统协作时，我们仅仅需要在意，我们能做什么，而不是我们<strong>如何</strong>做。</p><p>另外，你会针对你的抽象，有一写低级别的模块或者具体实现逻辑。这些东西与抽象是相反的。它们是被用于解决某些特定问题所编写的代码。它们的作用域仅仅在某个单元和子系统中。比如，建立一个与MySQL数据库的连接就是一个低级别的实现逻辑，因为它与某个特定的技术领域所绑定。</p><p>现在仔细读这两句话，我们能够得到什么暗示呢？</p><p>依赖倒置原则存在的真正意义是指，我们需要将一些对象解耦，它们的耦合关系需要达到当一个对象依赖的对象作出改变时，对象本身不需要更改任何代码。</p><p>这样的架构可以实现一种松耦合的状态的系统，因为系统中所有的组件，彼此之间都了解很少或者不需要了解系统中其余组件的具体定义和实现细节。它同时实现了一种可测试和可替换的系统架构，因为在松耦合的系统中，任何组件都可以被提供相同服务的组件所替换。</p><p>但是相反的，依赖倒置也有一些缺点，就是你需要一个用于处理依赖倒置逻辑的容器，同时，你还需要配置它。容器通常需要具备能够在系统中注入服务，这些服务需要具备正确的作用域和参数，还应当被注入正确的执行上下文中。</p><h2>以提供Websocket连接服务为例子</h2><p>举个例子，我们可以在这个例子中学到更多关于依赖倒置的知识，我们将使用<code>Inversify.js</code>作为依赖倒置的容器，通过这个依赖倒置容器，我们可以看看如何针对提供<code>Websocket</code>连接服务的业务场景，提供服务。</p><p>比如，我们有一个web服务器提供<code>WebSockets</code>连接服务，同时客户端想要连接服务器，同时接受更新的通知。当前我们有若干种解决方案来提供一个WebSocket服务，比如说<code>Socket.io</code>、<code>Socks</code>或者使用浏览器提供的关于原生的<code>WebSocket</code>接口。每一套解决方案，都提供不同的接口和方法供我们调用，那么问题来了，我们是否可以在一个接口中，将所有的解决方案都抽象成一个提供<code>WebSocket</code>连接服务的提供者？这样，我们就可以根据我们的实际需求，使用不同的WebSocket服务提供者。</p><p>首先，我们来定义我们的接口：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export interface WebSocketConfiguration &#123;</span><br><span class="line">  uri: string;</span><br><span class="line">  options?: Object;</span><br><span class="line">&#125;</span><br><span class="line">export interface SocketFactory &#123;</span><br><span class="line">  createSocket(configuration: WebSocketConfiguration): any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意在接口中，我们没有提供任何的实现细节，因此它既是我们所拥有的<strong>抽象</strong>。</p><p>接下来，如果我们想要一个提供<code>Socket.io</code>服务工厂：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Manager&#125; from &apos;socket.io-client&apos;;</span><br><span class="line"></span><br><span class="line">class SocketIOFactory implements SocketFactory &#123;</span><br><span class="line">  createSocket(configuration: WebSocketConfiguration): any &#123;</span><br><span class="line">    return new Manager(configuration.uri, configuration.opts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里已经包含了一些具体的实现细节，因此它不再是抽象，因为它声明了一个从<code>Socket.io</code>库中导入的<code>Manager</code>对象，它是我们的具体实现细节。</p><p>我们可以通过实现<code>SocketFactory</code>接口，来增加若干工厂类，只要我们实现这个接口即可。</p><p>我们在提供一个关于客户端连接实例的抽象：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export interface SocketClient &#123;</span><br><span class="line">  connect(configuration: WebSocketConfiguration): Promise&lt;any&gt;;</span><br><span class="line">  close(): Promise&lt;any&gt;;</span><br><span class="line">  emit(event: string, ...args: any[]): Promise&lt;any&gt;;</span><br><span class="line">  on(event: string, fn: Function): Promise&lt;any&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后再提供一些实现细节：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class WebSocketClient implements SocketClient &#123;</span><br><span class="line">  private socketFactory: SocketFactory;</span><br><span class="line">  private socket: any;</span><br><span class="line">  public constructor(webSocketFactory: SocketFactory) &#123;</span><br><span class="line">    this.socketFactory = webSocketFactory;</span><br><span class="line">  &#125;</span><br><span class="line">  public connect(config: WebSocketConfiguration): Promise&lt;any&gt; &#123;</span><br><span class="line">    if (!this.socket) &#123;</span><br><span class="line">      this.socket = this.socketFactory.createSocket(config);</span><br><span class="line">    &#125;</span><br><span class="line">    return new Promise&lt;any&gt;((resolve, reject) =&gt; &#123;</span><br><span class="line">      this.socket.on(&apos;connect&apos;, () =&gt; resolve());</span><br><span class="line">      this.socket.on(&apos;connect_error&apos;, (error: Error) =&gt; reject(error));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  public emit(event: string, ...args: any[]): Promise&lt;any&gt; &#123;</span><br><span class="line">    return new Promise&lt;string | Object&gt;((resolve, reject) =&gt; &#123;</span><br><span class="line">      if (!this.socket) &#123;</span><br><span class="line">        return reject(&apos;No socket connection.&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">      return this.socket.emit(event, args, (response: any) =&gt; &#123;</span><br><span class="line">        if (response.error) &#123;</span><br><span class="line">          return reject(response.error);</span><br><span class="line">        &#125;</span><br><span class="line">        return resolve();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  public on(event: string, fn: Function): Promise&lt;any&gt; &#123;</span><br><span class="line">    return new Promise&lt;any&gt;((resolve, reject) =&gt; &#123;</span><br><span class="line">      if (!this.socket) &#123;</span><br><span class="line">        return reject(&apos;No socket connection.&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.socket.on(event, fn);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  public close(): Promise&lt;any&gt; &#123;</span><br><span class="line">    return new Promise&lt;any&gt;((resolve) =&gt; &#123;</span><br><span class="line">      this.socket.close(() =&gt; &#123;</span><br><span class="line">        this.socket = null;</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>值得注意的是，这里我们在构造函数中，传入了一个类型是<code>SocketFactory</code>的参数，这是为了满足关于依赖倒置原则的第一条规则。对于第二条规则，我们需要一种方式来提供这个不需要了解内部实现细节的、可替换的、易于配置的参数。</p><p>这也是为什么我们要使用<code>Inversify</code>这个库的原因，我们来加入一些额外的代码和注解（装饰器）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123;injectable&#125; from &apos;inversify&apos;;</span><br><span class="line">const webSocketFactoryType: symbol = Symbol(&apos;WebSocketFactory&apos;);</span><br><span class="line">const webSocketClientType: symbol = Symbol(&apos;WebSocketClient&apos;);</span><br><span class="line">let TYPES: any = &#123;</span><br><span class="line">    WebSocketFactory: webSocketFactoryType,</span><br><span class="line">    WebSocketClient: webSocketClientType</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@injectable()</span><br><span class="line">class SocketIOFactory implements SocketFactory &#123;...&#125;</span><br><span class="line">...</span><br><span class="line">@injectable()</span><br><span class="line">class WebSocketClient implements SocketClient &#123;</span><br><span class="line">public constructor(@inject(TYPES.WebSocketFactory) webSocketFactory: SocketFactory) &#123;</span><br><span class="line">  this.socketFactory = webSocketFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这些注释（装饰器）仅仅会在代码运行时，在如何提供这些组件实例时，提供一些元数据，接下来我们仅仅需要创建一个依赖倒置容器，并将所有的对象按正确的类型绑定起来，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Container&#125; from &apos;inversify&apos;;</span><br><span class="line">import &apos;reflect-metadata&apos;;</span><br><span class="line">import &#123;TYPES, SocketClient, SocketFactory, SocketIOFactory, WebSocketClient&#125; from &apos;@web/app&apos;;</span><br><span class="line">const provider = new Container(&#123;defaultScope: &apos;Singleton&apos;&#125;);</span><br><span class="line">// Bindings</span><br><span class="line">provider.bind&lt;SocketClient&gt;(TYPES.WebSocketClient).to(WebSocketClient);</span><br><span class="line">provider.bind&lt;SocketFactory&gt;(TYPES.WebSocketFactory).to(SocketIOFactory);</span><br><span class="line">export default provider;</span><br></pre></td></tr></table></figure></p><p>让我们来看看我们如何使用我们提供连接服务的客户端实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var socketClient = provider.get&lt;SocketClient&gt;(TYPES.WebSocketClient);</span><br></pre></td></tr></table></figure></p><p>当然，使用<code>Inversify</code>可以提供一些更简单易用的绑定，可以通过浏览它的网站来了解。</p><h2>译者注</h2><p>一般说到依赖倒置原则，往往第一个想到的术语即是<code>依赖注入</code>，这种在各个技术栈都有应用，之后又会马上想到<code>spring</code>、<code>ng</code>等前后端框架。</p><p>我们确实是通过使用这些框架熟知这个概念的，但是如果你仔细想想的话，是否还有其他的一些场景也使用了类似的概念呢？</p><p>比如：</p><ul><li>一些使用插件和中间件的框架，如<code>express</code>、<code>redux</code></li><li>js中this的动态绑定</li><li>js中的回调函数</li></ul><p>也许有的人会不同意我的观点，会说依赖注入一般都是面向类和接口来讲的，这确实有一定的道理，但是我认为没有必要局限在一种固定的模式中去理解依赖倒置，毕竟它是一种思想，一种模式，在js中，所有的东西都是动态的，函数是一等公民，是对象，那么把这些与依赖倒置原则联系起来，完全也讲的通。我们真正关心的是核心问题是如何<strong>解耦</strong>，把更多的注意力投入的真正的业务逻辑中去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;a href=&quot;https://codeburst.io/understanding-solid-principles-dependency-injection-d570c15560ab&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Understan
      
    
    </summary>
    
      <category term="翻译" scheme="http://littlelyon.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="principle" scheme="http://littlelyon.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>尝鲜 workerize 源码</title>
    <link href="http://littlelyon.com/2018/01/16/workerize/"/>
    <id>http://littlelyon.com/2018/01/16/workerize/</id>
    <published>2018-01-16T02:11:31.000Z</published>
    <updated>2018-04-04T11:48:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2>写在前面</h2><p>最近正好在看web worker相关的东西，今天无意中就看到了github一周最热项目的推送中，有这么一个项目<a href="https://github.com/developit/workerize" target="_blank" rel="noopener">workerize</a>，repo里的文档的描述如下：</p><blockquote><p>Moves a module into a Web Worker, automatically reflecting exported functions as asynchronous proxies.</p></blockquote><h2>例子</h2><p>关于README很简单，包含一个类似hello world的例子就没其他什么了。但是从例子本身可以看出这个库要解决的问题，是想通过模块化的方式编写运行在web worker中的脚本，因为通常情况下，web worker每加载一个脚本文件是需要通过一个符合同源策略的URL的，这样会对服务端发送一个额外的请求。同时对于web worker本身加载的js文件的执行环境，与主线程是隔离的（这也是它在进行复杂运算时不会阻塞主线程的原因），与主线程的通讯靠<code>postMessage</code>api和<code>onmessage</code>回调事件来通讯，这样我们在编写一些通信代码时，需要同时在两个不同的环境中分别编写发送消息和接受消息的逻辑，比较繁琐，同时这些代码也不能以模块化的形式存在。</p><p>如果存在一种方式，我们可以以模块化的方式来编写代码，注入web worker，之后还能通过类似Promsie机制来处理等异步，那便是极好的。</p><p>先来看看例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import workerize from &apos;workerize&apos;</span><br><span class="line"></span><br><span class="line">let worker1 = workerize(`</span><br><span class="line">export function add(a, b) &#123;</span><br><span class="line">let start = Date.now();</span><br><span class="line">while (Date.now()-start &lt; 500);</span><br><span class="line">return a + b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  export default function minus(a, b)&#123;</span><br><span class="line">    let start = Date.now();</span><br><span class="line">while (Date.now()-start &lt; 500);</span><br><span class="line">    return a - b</span><br><span class="line">  &#125;</span><br><span class="line">`)</span><br><span class="line"></span><br><span class="line">let worker2 = workerize(function (m) &#123;</span><br><span class="line">  m.add = function (a, b) &#123;</span><br><span class="line">    let start = Date.now()</span><br><span class="line">    while (Date.now() - start &lt; 500);</span><br><span class="line">    return a + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">  console.log(&apos;1 + 2 = &apos;, await worker1.add(1, 2))</span><br><span class="line">  console.log(&apos;3 + 9 = &apos;, await worker2.call(&apos;add&apos;, [3, 9]))</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>worker1和worker2是两种不同的使用方式，一种是以字符串的形式声明模块，一种以函数的形式声明模块。但是无论哪种，最后的结果都是一样的，我们可以通过worker实例显示的调用我们想要调用的方法，每个方法的调用结果均是一个Promise，因此它还可以完美的适配async/await语法。</p><h2>源码</h2><p>那么问题来了，这种模块的加载机制和调用方式是怎样实现的呢？我在运行demo代码的时候心中也默默想到，我去，看了好几天的web worker原来还能这么玩，所以一定要研究研究它的源码和它的实现原理。</p><p>打开源代码才发现其实并没有多少代码，官文文档也通过一句话强调了这一点：</p><blockquote><p>Just 900 bytes of gzipped ES3</p></blockquote><p>所以对其中主要的两点进行简单说明：</p><ul><li>如何实现按内容模块化加载脚本而不是通过URL</li><li>如何通过Promise来代理主线程与worker线程的通讯过程</li></ul><h3>使用Blob动态生成加载脚本资源</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let blob = new Blob([code], &#123;</span><br><span class="line">      type: &apos;application/javascript&apos;</span><br><span class="line">    &#125;),</span><br><span class="line">    url = URL.createObjectURL(blob),</span><br><span class="line">    worker = new Worker(url)</span><br></pre></td></tr></table></figure></p><p>这其实不是什么新鲜的东西，就是将代码的内容转化为Blob对象，之后再通过<code>URL.createObjectURL</code>将Blob对象转化为URL的形式，之后再用worker加载它，仅此而已。但是这里的问题是，这个<code>code</code>是哪里从哪里来的呢？</p><h3>将加载代码模块化</h3><p>在加载代码之前，还有重要的一步，就是需要将加载的代码转变为模块，模板本身只对外暴露统一的接口，这样不论对于主线程还是worker线程，就有了统一的约束条件。源码中作者把上一步中的<code>code</code>转化为了类似commonjs的形式，主要涉及的代码有:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let exportsObjName = `__EXPORTS_$&#123;Math.random().toString().substring(2)&#125;__`</span><br><span class="line">  if (typeof code === &apos;function&apos;) code = `($&#123;toCode(code)&#125;)($&#123;exportsObjName&#125;)`</span><br><span class="line">  code = toCjs(code, exportsObjName, exports)</span><br><span class="line">  code += `\n($&#123;toCode(setup)&#125;)(self, $&#123;exportsObjName&#125;, &#123;&#125;)`</span><br></pre></td></tr></table></figure></p><p>和<code>toCjs</code>方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function toCjs (code, exportsObjName, exports) &#123;</span><br><span class="line">  exportsObjName = exportsObjName || &apos;exports&apos;</span><br><span class="line">  exports = exports || &#123;&#125;</span><br><span class="line">  code = code.replace(/^(\s*)export\s+default\s+/m, (s, before) =&gt; &#123;</span><br><span class="line">    exports.default = true</span><br><span class="line">    return `$&#123;before&#125;$&#123;exportsObjName&#125;.default = `</span><br><span class="line">  &#125;)</span><br><span class="line">  code = code.replace(/^(\s*)export\s+(function|const|let|var)(\s+)([a-zA-Z$_][a-zA-Z0-9$_]*)/m, (s, before, type, ws, name) =&gt; &#123;</span><br><span class="line">    exports[name] = true</span><br><span class="line">    return `$&#123;before&#125;$&#123;exportsObjName&#125;.$&#123;name&#125; = $&#123;type&#125;$&#123;ws&#125;$&#123;name&#125;`</span><br><span class="line">  &#125;)</span><br><span class="line">  return `var $&#123;exportsObjName&#125; = &#123;&#125;;\n$&#123;code&#125;\n$&#123;exportsObjName&#125;;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于toCjs方法，如果你的正则知识比较扎实的话，可以发现，它做了一件事，就是将字符串类型的code中的所有导出方法的声明，使用commonjs的导出语法替换掉(中间会涉及一些具体的语法规则)，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 如果 exportsObjName 使用默认值 exports, ...代表省略代码</span><br><span class="line">export function foo()&#123; ... &#125; =&gt; exports.foo = function foo()&#123; ... &#125;</span><br><span class="line">export default ... =&gt; exports.default = ...</span><br></pre></td></tr></table></figure></p><p>如果code是函数类型，则首先使用<code>toCode</code>函数将code转化为string类型，之后再将它转化为IIFE的形式，如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 如果 exportsObjName 使用默认值 exports, ...代表省略代码</span><br><span class="line">// 传入的code是如下形式：</span><br><span class="line">function( m )&#123; </span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br><span class="line">// 转化为</span><br><span class="line">(function( m )&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)(exports)</span><br></pre></td></tr></table></figure></p><p>这里的<code>exportsObjName</code>代表模块的名字，默认值是<code>exports</code>(联想commonjs)，不过这里会在一开始就随机生成一个模块名字，生成代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let exportsObjName = `__EXPORTS_$&#123;Math.random().toString().substring(2)&#125;__`</span><br></pre></td></tr></table></figure></p><p>这样只有我们按照约定的语法来编写web worker加载的代码，它便会加载了一个符合同样约定的commonjs模块。</p><h3>使用 Promise 来做异步代理</h3><p>经过上面两步，web worker加载到了模块化的代码，但是worker线程与主线程进行通讯则是仍然需要通过<code>postMessage</code>方法和<code>onmessage</code>回调事件来进行，如果无法优雅地处理这里的异步逻辑，那么之前所做的工作其实意义并不大。</p><p>workerize针对这里的异步逻辑，设计了一个简单的rpc协议（文档中将这个称作<code>a tiny, purpose-built RPC</code>），先来看一下源码中的<code>setup</code>函数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function setup (ctx, rpcMethods, callbacks) &#123;</span><br><span class="line">    ctx.addEventListener(&apos;message&apos;, (&#123; data &#125;) =&gt; &#123;</span><br><span class="line">      // 只捕获满足条件的数据对象</span><br><span class="line">      if (data.type === &apos;RPC&apos;) &#123;</span><br><span class="line">        // 获取数据对象中的 id 属性</span><br><span class="line">        let id = data.id</span><br><span class="line">        if (id != null) &#123;</span><br><span class="line">          // 如果数据对象中存在非空 method 属性，则证明是主线程发送的消息</span><br><span class="line">          if (data.method) &#123;</span><br><span class="line">            // 获取所要调用的方法实例</span><br><span class="line">            let method = rpcMethods[data.method]</span><br><span class="line">            if (method == null) &#123;</span><br><span class="line">              // 如果所调用的方法实例不存在，则发送方法不存在的消息</span><br><span class="line">              ctx.postMessage(&#123; type: &apos;RPC&apos;, id, error: &apos;NO_SUCH_METHOD&apos; &#125;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              // 如果方法存在，则调用它，并将调用结果按不同的类型发送</span><br><span class="line">              Promise.resolve()</span><br><span class="line">                .then(() =&gt; method.apply(null, data.params))</span><br><span class="line">                .then(result =&gt; &#123; ctx.postMessage(&#123; type: &apos;RPC&apos;, id, result &#125;) &#125;)</span><br><span class="line">                .catch(error =&gt; &#123; ctx.postMessage(&#123; type: &apos;RPC&apos;, id, error &#125;) &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">          // 如果 method 属性为空，则证明是 worker 线程发送的消息</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            // 获取每个消息所对应的处于pending状态的Promise实例</span><br><span class="line">            let callback = callbacks[id]</span><br><span class="line">            if (callback == null) throw Error(`Unknown callback $&#123;id&#125;`)</span><br><span class="line">            delete callbacks[id]</span><br><span class="line"></span><br><span class="line">            // 按消息的类型将Promise转化为resolve状态或reject状态。</span><br><span class="line">            if (data.error) callback.reject(Error(data.error))</span><br><span class="line">            else callback.resolve(data.result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>根据注释我们可以知道，这里的setup函数包含了rpc协议的解析规则，因此主线程和worker线程对会调用该方法来注册安装这个rpc协议，具体的代码如下：</p><ul><li>主线程: <code>setup(worker, worker.rpcMethods, callbacks)</code></li><li>worker线程: <code>code += `\n(${toCode(setup)})(self, ${exportsObjName}, {})</code></li></ul><p>这两处代码都是在各自的作用域中，将rpc协议与当前加载的模块绑定起来，只不过主进程所传<code>callbacks</code>是有意义的，而worker则使用一个空对象代替。</p><h3>注册调用逻辑</h3><p>在拥有了rpc协议的基础上，只需要实现调用逻辑即可，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">worker.call = (method, params) =&gt; new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let id = `rpc$&#123;++counter&#125;`</span><br><span class="line">    callbacks[id] = &#123; method, resolve, reject &#125;</span><br><span class="line">    worker.postMessage(&#123; type: &apos;RPC&apos;, id, method, params &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这个<code>call</code>方法，每次会将一次方法的调用，转化为一个<code>pending</code>状态的<code>Promise</code>实例，并存在<code>callbacks</code>变量中，同时向worker线程发送一个格式为调用方法数据格式的消息。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (let i in exports) &#123;</span><br><span class="line">   if (exports.hasOwnProperty(i) &amp;&amp; !(i in worker)) &#123;</span><br><span class="line">     worker[i] = (...args) =&gt; worker.call(i, args)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时在初始化的过程中，会将主线程加载的模块中的每个方法，都绑定一个快捷方法，其方法名与模块中的函数声明保持一致，内部则使用<code>worker.call</code>来完成调用逻辑。</p><h2>最后</h2><p>关于这个库本身，还存在一些可以探讨的问题，比如：</p><ul><li>是否支持依赖解析机制</li><li>如果引入外部依赖模块</li><li>针对消息是否需要按队列进行处理</li></ul><p>关于前两点，似乎作者有一个相同的项目，叫做<code>workerize-loader</code>，可以解决，关于第三点，作者在代码中增加了todo，表示实现消息队列机制可能没有必要，因为当前的通讯基于postMessage，本身的结果已经是有序状态的了。</p><p>关于源码本身的分析大概就这样了，希望可以抛砖引玉，如有错误，还望指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;最近正好在看web worker相关的东西，今天无意中就看到了github一周最热项目的推送中，有这么一个项目&lt;a href=&quot;https://github.com/developit/workerize&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="源码分析" scheme="http://littlelyon.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="js" scheme="http://littlelyon.com/tags/js/"/>
    
      <category term="web worker" scheme="http://littlelyon.com/tags/web-worker/"/>
    
  </entry>
  
  <entry>
    <title>高级 Angular 组件模式 (3b)</title>
    <link href="http://littlelyon.com/2018/01/10/aacp-3b/"/>
    <id>http://littlelyon.com/2018/01/10/aacp-3b/</id>
    <published>2018-01-10T14:02:45.000Z</published>
    <updated>2018-04-04T11:53:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2>03-b Enhance Components with Directives</h2><blockquote><p>原文: <a href="https://blog.angularindepth.com/enhance-components-with-directives-58f16c4ca1f" target="_blank" rel="noopener">Enhance Components with Directives</a></p></blockquote><p>Kent C. Dodds的第四篇文章中的一个重要元素在上一篇文章中没有涉及，使用<code>withToggle</code>高阶组件(HoC, react中的常用模式)可以将<code>&lt;toggle-on&gt;</code>、<code>&lt;toggle-off&gt;</code>、<code>&lt;toggle-button&gt;</code>组件中的公用逻辑分离出来。</p><p>虽然上一篇文章中上面提及的三个组件并没有太多的公用逻辑，可以万一它们有公用逻辑呢？如果我们想要提供更加声明式的功能，比如能够显式的声明它们使用的<code>&lt;toggle&gt;</code>组件实例而非最邻近的父实例。</p><p>同时，因为<code>&lt;toggle&gt;</code>组件的模板并不存在任何的变动，我们可以将它转化为一个<strong>指令</strong>，这样我们可以以更加灵活的方式来使用它。</p><h2>目标</h2><ul><li>允许我们的<code>&lt;toggle&gt;</code>组件能够以<code>tag</code>的形式或者<code>attribute</code>的形式使用，如<code>&lt;toggle&gt;</code>或者<code>&lt;div toggle&gt;&lt;/div&gt;</code></li><li>允许通过`withToggle<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 实现</span><br><span class="line">### 1）将``&lt;toggle&gt;``作为一个指令</span><br><span class="line">将``&lt;toggle&gt;``组件改变为指令十分简单，因为它本身的模板仅仅是``&lt;ng-content&gt;&lt;/ng-content&gt;``，在组件渲染时，``&lt;ng-content&gt;``会被替换为我们当前组件标签内包含的内容，所以我们可以直接移除它，并使用``@Directive``装饰器来描述``&lt;toggle&gt;``组件，如下：</span><br></pre></td></tr></table></figure></li></ul><p>@Directive({exportAs: 'toggle',selector: 'toggle, [toggle]',})export class ToggleDirective {}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">你可能注意到了，指令的选择器允许``toggle``指令可以以**标签名**和**属性名**的形式来使用。对于``exportAs``关键字是必须要提供的，因为这是当我们需要在别的指令或者组件能够获取``toggle``指令引用的名字，会在这个系列文章的第5章详细删除``exportAs``（Handle Template Reference Variables with Directives）。</span><br><span class="line"></span><br><span class="line">### 2）``withToggle``指令</span><br><span class="line">在这个新的指令中，我们将会封装关于如何选取需要绑定某个``toggle``指令实例的逻辑。</span><br><span class="line"></span><br><span class="line">首先，我们的设想是这样的，每一个组件注入``withToggle``指令，而不是直接注入最邻近的父``toggle``指令。同时每个使用``withToggle``指令的组件通过使用``withToggle.toggle``来访问它所绑定的``toggle``指令的实例，如下：</span><br></pre></td></tr></table></figure></p><p>@Component({selector: 'toggle-off',template: <code>&lt;ng-content *ngIf=&quot;!withToggle.toggle?.on&quot;&gt;&lt;/ng-content&gt;</code>,})export class ToggleOffComponent {constructor(public withToggle: WithToggleDirective) {}}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其次，``withToggle``指令将它自身与``toggle``指令的选择器绑定（就是两个指令的选择器是相同的），同时增加一个额外的选择器``[withToggle]``，如下：</span><br></pre></td></tr></table></figure></p><p>@Directive({exportAs: 'withToggle',selector: 'toggle, [toggle], [withToggle]',})export class WithToggleDirective //...<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在``withToggle``指令为它的子组件们提供所绑定的``toggle``指令实例，无论这个实例是显示绑定的，还是默认的父``toggle``指令。关于其中实现的具体细节，可以参考文章最后的[附录部分](#附录)。</span><br><span class="line"></span><br><span class="line">## 成果</span><br><span class="line">我们的``app.component.html``现在可以通过三种不同的使用方式来展现内容。</span><br><span class="line"></span><br><span class="line">### 1）基本</span><br></pre></td></tr></table></figure></p><p>&lt;div toggle #firstToggle=&quot;toggle&quot;&gt;...&lt;toggle #secondToggle=&quot;toggle&quot;&gt;...&lt;/toggle&gt;&lt;/div&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注意``#firstToggle``和``#secondToggle``视图变量是如何使用``toggle``组件的，前者使用属性声明的方式，后者使用标签名声明方式，无论怎样，它们都按理想中那样运行。</span><br><span class="line"></span><br><span class="line">而且，``#secondToggle``是嵌套在``#firstToggle``中的，所以它的子组件使用的是它本身的开关状态，而非``#firstToggle``中的，这符合我们的预期。</span><br><span class="line"></span><br><span class="line">### 2）显式引用</span><br></pre></td></tr></table></figure></p><p>&lt;p [withToggle]=&quot;firstToggle&quot;&gt;First:&lt;toggle-on&gt;On&lt;/toggle-on&gt;&lt;toggle-off&gt;Off&lt;/toggle-off&gt;&lt;toggle-button&gt;&lt;/toggle-button&gt;&lt;/p&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里没有任何``toggle``指令是当前``p``标签的子组件的祖先，但是通过``withToggle``指令，我们可以让所有的子组件使用``#firstToggle``的``toggle``指令实例。</span><br><span class="line"></span><br><span class="line">### 3）自定义组件</span><br></pre></td></tr></table></figure></p><p>&lt;div [withToggle]=&quot;firstToggle&quot;&gt;&lt;labelled-state toggleName=&quot;First&quot;&gt;&lt;/labelled-state&gt;&lt;labelled-button toggleName=&quot;First&quot;&gt;&lt;/labelled-button&gt;&lt;/div&gt;&lt;labelled-state toggleName=&quot;Second&quot; [withToggle]=&quot;secondToggle&quot;&gt; &lt;/labelled-state&gt;&lt;labelled-button toggleName=&quot;Second&quot; [withToggle]=&quot;secondToggle&quot;&gt; &lt;/labelled-button&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">``withToggle``指令甚至可以通过DI机制注入到内部的任何自定义组件中，如``&lt;labelled-state&gt;``组件和``&lt;labelled-button&gt;``都没有任何关于``withToggle``或者``toggle``的引用声明。它们无需关心这个开关状态的来源，它们仅仅需要知道的是，根据这个开关状态，如何与它们的子组件进行交互。</span><br><span class="line"></span><br><span class="line">## 附录</span><br><span class="line">``withToggle``的实现，是一个标准的指令声明方式，除了它的构造方法，如下：</span><br></pre></td></tr></table></figure></p><p>constructor(@Host() @Optional() private toggleDirective: ToggleDirective,) {}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">值得注意的有两点：</span><br><span class="line">* ``@Host()``：这个装饰器的作用是，可以限制从属于当前指令的DI注入器，仅注入**绑定到某个满足特定条件指定或者组件上的**``toggle``指令实例，而不是从它的祖先组件们中注入。（这里选择器为空，则为宿主对象）</span><br><span class="line">* ``@Optional()``：这个装饰器会告诉编译器，当注入器没有找到任何可注入的``toggle``指令时，不要抛出错误（如果我们手动的指定某个引用），这样在它无法被注入时，使它保持``undefined``即可。</span><br><span class="line"></span><br><span class="line">现在我们可以很容易的理解在``ngOnChanges``生命周期钩子函数中的代码的作用，</span><br></pre></td></tr></table></figure></p><p>this.toggle = this.withToggle || this.toggleDirective;</p><pre><code>* 如果我们的``@Input()``被指定，那么使用它的值* 如果没有，则尝试去使用在当前宿主对象上注入的``toggle``指令实例* 如果没有，则使用``undefined``当前的``this``指定``withToggle``本身，所以拥有它引用的子组件都可以访问它。https://stackblitz.com/edit/adv-ng-patterns-03b-enhance-with-directives## 译者注在这一节中，主要进行了以下几方面的改进：* 简化``toggle``本身，因为它一直是作为一个容器组件使用的，所以完全可以以指令（可以理解为没有模板的组件）的形式存在* 依赖注入（DI）的机制虽然很强大，但是受限于它的运作原理（关于具体的运作原理可以参考[官方文档](https://angular.cn/guide/dependency-injection)）。这里原作者使用一个额外的``withToggle``指令作为中间件，来作为``toggle``指令的托管容器。这部分理解起来可能需要先了解一下视图变量和``exportAs``的相关的知识* 对于``toggle``指令实例的获取逻辑，采用平稳退化的策略，就好比人在实际生活中思考问题的方式一样。这种开发模式，在实际工作中，我有一次在重构公司项目中一个关于表单组件的过程中曾使用过，之所以使用这种方式，是因为在表单组件中，会存在一些关于联动校验或者分组的需求，如果将这部门逻辑封装为``service``或者直接写在``controller``内部，越到后面会发现逻辑复杂度越高，从而越来越难维护。使用这种模式，将复杂的逻辑划分成小的颗粒，再封装为独立的指令，在需要用到这些逻辑的组件中注入这些指令即可，指令的特点就是一般都会比较简洁，只会做一些简单的事情，相比之下，维护一个十分复杂的service和维护若干简单的指令，我更倾向于后者。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;03-b Enhance Components with Directives&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;原文: &lt;a href=&quot;https://blog.angularindepth.com/enhance-components-with-direct
      
    
    </summary>
    
      <category term="翻译" scheme="http://littlelyon.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="js" scheme="http://littlelyon.com/tags/js/"/>
    
      <category term="angular" scheme="http://littlelyon.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>高级 Angular 组件模式 (3a)</title>
    <link href="http://littlelyon.com/2018/01/10/aacp-3a/"/>
    <id>http://littlelyon.com/2018/01/10/aacp-3a/</id>
    <published>2018-01-10T14:02:45.000Z</published>
    <updated>2018-04-04T11:53:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2>03-a Communicate Between Components Using Dependency Injection</h2><blockquote><p>原文: <a href="https://blog.angularindepth.com/communicate-between-components-using-dependency-injection-d7280567faa7" target="_blank" rel="noopener">Communicate Between Components Using Dependency Injection</a></p></blockquote><p>当前的<code>&lt;toggle&gt;</code>组件仍然存在其他的问题，比如：</p><ul><li>我们无法在其中方式多个<code>&lt;toggle-on&gt;</code>或者是<code>&lt;toggle-button&gt;</code>在同一个<code>&lt;toggle&gt;</code>中</li><li>如果一个<code>&lt;toggle-on&gt;</code>作为另外一个自定义组件的内容的话，我们无法是使用<code>@ContentChild</code>装饰器获取它</li></ul><h2>目标</h2><p>我们需要将这两个问题作为新的目标：</p><ul><li>我们可以增加多个相同类型的子组件(<code>&lt;toggle-on&gt;</code>、<code>&lt;toggle-off&gt;</code>、<code>&lt;toggle-button&gt;</code>)</li><li>并且可以使这些子组件放置在任意的自定义容器的视图模板(<code>views</code>)中</li></ul><h2>实现</h2><p>针对第一个问题，我们使用<code>@ContentChildren</code>装饰器（因为它获取所有的子组件引用），但是它无法解决第二个问题。</p><p>为了同时解决这两个问题，我们可以使用Angular提供的DI机制(<code>dependency injection mechanism</code>)。你可以将一个组件的祖先组件通过DI机制注入到子组件的构造方法中，这样你就可以通过祖先组件的引用来访问它们的方法和属性。</p><p>所以，<code>&lt;toggle-on&gt;</code>、<code>&lt;toggle-off&gt;</code>、<code>&lt;toggle-button&gt;</code>都可以通过DI机制来获得最相近的<code>&lt;toggle&gt;</code>组件的引用，从而共享它的开关状态。</p><blockquote><p>Note:这里也可以使用<code>service</code>来共享状态，也许还会更便捷，但是我们可以通过DI来达到目的，我们可以在之后的章节（第十二章）来阐述<code>service</code>相关的内容，这部分内容会与<code>React Context Provider</code>的内容对应。</p></blockquote><h2>成果</h2><p>你可以在在线代码仓库看到，有两个<code>&lt;toggle-off&gt;</code>组件如我们预期的那样被渲染，并且有一个<code>&lt;other-component&gt;</code>组件，其中有<code>&lt;toggle-off&gt;</code>和<code>&lt;toggle-on&gt;</code>两个组件。</p><p>这些子组件都会监听同一个<code>&lt;toggle&gt;</code>组件的开关状态。</p><h2>译者注</h2><p>依赖注入是Angular中提供的很强大的功能，在<code>angularjs</code>中就表现出色并作为卖点。</p><p>如果仔细思考的话，我们可以发现，在这一版的实现中，对于<code>&lt;toggle&gt;</code>组件的引用获取方式，从命令式转变为了声明式，因为我们不再关心获取<code>&lt;toggle&gt;</code>引用的细节（比如具体使用<code>@ContentChild</code>还是<code>@ContentChildren</code>）。</p><p>同时，依赖注入机制是依附于组件本身存在的，并不依附于模板的层级关系，因此不会面临问题二的困扰。</p><p>对于木偶组件本身，往往作为消费者存在，这种情况下使用DI机制可能会达到更好的效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;03-a Communicate Between Components Using Dependency Injection&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;原文: &lt;a href=&quot;https://blog.angularindepth.com/communi
      
    
    </summary>
    
      <category term="翻译" scheme="http://littlelyon.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="js" scheme="http://littlelyon.com/tags/js/"/>
    
      <category term="angular" scheme="http://littlelyon.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>高级 Angular 组件模式 (2)</title>
    <link href="http://littlelyon.com/2018/01/10/aacp-2/"/>
    <id>http://littlelyon.com/2018/01/10/aacp-2/</id>
    <published>2018-01-10T13:05:59.000Z</published>
    <updated>2018-04-04T11:53:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2>02 Write Compound Components</h2><blockquote><p>原文: <a href="https://blog.angularindepth.com/write-compound-components-1001449c67f0" target="_blank" rel="noopener">Write Compound Components</a></p></blockquote><h3>目标</h3><p>我们需要实现的需求是能够使使用者通过<code>&lt;toggle&gt;</code>组件动态的改变包含在它内部的内容。</p><h3>实现</h3><p>我们可以把toggle抽象为一个复合组件，由三个新的组件<code>&lt;toggle-button&gt;</code>、<code>&lt;toggle-on&gt;</code>、<code>&lt;toggle-off&gt;</code>构成。</p><p>每一个组件的职能与它们的父组件保持一致，它们各自的职能如下：</p><ul><li><code>toggle-button</code>: 代表开关，用来渲染父组件的开关状态</li><li><code>toggle-on</code>: 根据父组件的开关状态，渲染当状态为<strong>开</strong>时的内容</li><li><code>toggle-off</code>: 根据父组件的开关状态，渲染当状态为<strong>关</strong>时的内容</li></ul><p><code>&lt;toggle&gt;</code>组件可以实现<code>@ContentChild</code>装饰器获取这三个子组件的引用，从而可以根据开关状态的变化调整它们之间的关联逻辑。</p><h2>成果</h2><p>经过这样的调整，我们可以使用户通过使用<code>&lt;toggle&gt;</code>组件去自定义包含在它其中内容的显示逻辑，内容中会有一个按钮负责切换开关的状态。可以尝试在在线代码库中调整子组件的顺序，你可以在它们中间嵌套任何的<code>html</code>字符串，只要这三个组件是作为<code>&lt;toggle&gt;</code>的子组件存在的，一切都将正常的运行。</p><h2>相关话题</h2><ul><li><p><code>@ContentChild</code>装饰器将会返回在组件标签包含的内容中，第一个符合选择器的子组件或者子指令的引用，比如<code>&lt;toggle&gt; This is the content &lt;/toggle&gt;</code>。如果想获取所有的子组件或者子指令，使用<code>@ContentChildren</code>。</p></li><li><p><code>@ViewChild</code>或者<code>@ViewChildren</code>装饰器是用来获取在组件内部模板中使用的单个或者多个组件的。比如<code>template: 'This is the view'</code>或者<code>templateUrl: './my.component.html'</code></p></li></ul><h2>译者注</h2><p>这里组件架构方式是标准的<code>Smart Component（智能组件）</code>和<code>Dump Component（木偶组件）</code>组件架构方式。</p><p>以上的需求完全是可以在<code>&lt;toggle&gt;</code>内部实现的，但是这样会使它的内部充满逻辑代码，反之我们可以将一些职能划分为成更小的碎片，并委托到它的子组件中，本身作为容器组件存在，负责协作子组件从而达到目的。</p><p>对于<code>@ContentChild</code>和<code>@ViewChild</code>的使用场景，我认为通过看装饰器前缀的寓意是最后的方式。</p><ul><li><code>Content</code>代表内容，这些内容在组件渲染时已经存在于组件声明标签的内部，通常在组件内部以<code>&lt;ng-content&gt;</code>为占位符</li><li><code>View</code>代表视图，视图代表组件本身的模板，代表组件本身的渲染逻辑</li></ul><p><code>@ContentChildren</code>和<code>@ViewChildren</code>同理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;02 Write Compound Components&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;原文: &lt;a href=&quot;https://blog.angularindepth.com/write-compound-components-1001449c67f0&quot; t
      
    
    </summary>
    
      <category term="翻译" scheme="http://littlelyon.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="js" scheme="http://littlelyon.com/tags/js/"/>
    
      <category term="angular" scheme="http://littlelyon.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>高级 Angular 组件模式 (1)</title>
    <link href="http://littlelyon.com/2018/01/10/aacp-1/"/>
    <id>http://littlelyon.com/2018/01/10/aacp-1/</id>
    <published>2018-01-10T09:21:19.000Z</published>
    <updated>2018-04-04T11:53:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2>写在前头</h2><p>Angular到现在已经到5.x的版本了，对于MVVM框架我首先接触的是angularjs后来又转为react，之后换了工作因项目技术栈的原因又转换到之前的angularjs，在实际工作中实施了公司几个比较重要项目中前端的重构工作，这个过程逐步意识到，对于MVVM框架本身，在使用层面讲，掌握一些通用的模式是很有必要的，尤其现在已经很流行的组件化开发。这样我们在实际工作中就可以无缝（或者花很少的时间成本）转化到任何的MVVM框架，并把节省下来的时间去学习新的知识。</p><p>最近一直在关注<code>Angular In Depth</code>的博客，偶尔看到这个系列的文章，觉的质量还挺高，所以抽空余时间翻译并分享给大家，并在每个文章后面加了一点自己的拙见，希望可以达到抛砖引玉的效果，如果观点有误，还望各位看官轻喷。</p><h2>01 Build a Toggle Component</h2><blockquote><p>原文: <a href="https://blog.angularindepth.com/build-a-toggle-component-6e8f44889c2c" target="_blank" rel="noopener">Build a Toggle Component</a></p></blockquote><p>如<a href="https://egghead.io/lessons/react-introducing-advanced-react-component-patterns" target="_blank" rel="noopener">Kent C. Dodds Advanced React Component Patterns</a>那样，我们将使用一个相对简单的<code>&lt;toggle&gt;</code>组件来说明这些模式。<code>&lt;toggole&gt;</code>组件的职责是仅仅是管理一个简单的布尔值状态属性: <code>on</code>。使用如此简单的组件进行说明的目的，是因为我们可以将更多的注意力投入到相对组件本身而言较复杂的模式中。</p><p>经过这一系列文章，我将提供包含完整功能的、可运行的演示代码链接。你仅仅需要将注意力集中到<code>app</code>文件夹和<code>toggle</code>文件夹。<code>toggle</code>文件夹包含一些可复用的库（一系列组件），当然这个库会随着文章的深入而改变。<code>app</code>文件夹并且特别是<code>app.component.html</code>，将针对库在不同的情形下的使用做出相应的改变。</p><p>我们将从最原始的<code>toggle</code>组件版本开始。它仅仅有一个使用了<code>@Input()</code>装饰器的<code>on</code>属性，这个属性所控制的状态代表组件本身的开关状态，同时它还有一个是使用了<code>@Output()</code>装饰器的<code>toggle</code>事件发射器，这个事件发射器会在组件开关状态改变的情况下，通知父组件。</p><p>在我们开始下一个话题<a href="http://littlelyon.com/2018/01/10/aacp-2/">02 Write Compound Components</a>之前，可以在<a href="https://stackblitz.com/edit/adv-ng-patterns-01-build-toggle-component" target="_blank" rel="noopener">在线代码仓库</a>看看这个组件的实现以及演示。</p><h2>译者注</h2><p><code>toggle</code>组件的实现是一个很典型的利用单向数据流作为数据源的简单组件：</p><ul><li><code>on</code>是单向数据源，同时代表组件内部的开关状态</li><li><code>toggle`是事件发射器`，以回调的方式将</code>on``状态的变化传递给父组件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;写在前头&lt;/h2&gt;
&lt;p&gt;Angular到现在已经到5.x的版本了，对于MVVM框架我首先接触的是angularjs后来又转为react，之后换了工作因项目技术栈的原因又转换到之前的angularjs，在实际工作中实施了公司几个比较重要项目中前端的重构工作，这个过程逐步意
      
    
    </summary>
    
      <category term="翻译" scheme="http://littlelyon.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="js" scheme="http://littlelyon.com/tags/js/"/>
    
      <category term="angular" scheme="http://littlelyon.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>多维数组取值问题</title>
    <link href="http://littlelyon.com/2017/12/18/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%8F%96%E5%80%BC%E9%97%AE%E9%A2%98/"/>
    <id>http://littlelyon.com/2017/12/18/多维数组取值问题/</id>
    <published>2017-12-18T07:56:47.000Z</published>
    <updated>2017-12-18T07:56:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2>问题简述</h2><p>给予一个多维数组和一个描述取值路径的一维数组, 通过调用函数<code>f</code>返回取值路径描述的值，如<code>f([[1, 2], [3, 4], [5, 6]], [0, 0]) -&gt; 1</code></p><p><a href="https://www.codewars.com/kata/multidimensional-array/train/javascript" target="_blank" rel="noopener">原问题传送门</a></p><p>之所以想记录一下是因为之前有在<code>codewars</code>刷题的习惯，后来工作忙就怠慢了，今天闲来无事就准备刷几道玩玩，然后就挑了一个比较简单的<code>7kyu</code>（<code>codewars</code>中的难度评级）的题。</p><p>因为这题比较简单，我也没多想，上来就干，仔细想了下，很容易嘛，不就是递归吗？按大学老师教的来一套：</p><ul><li>先找递归退出的条件，<code>当路径取到最后</code>或者<code>目标数组已经取尽</code>（这里似乎题目没有说清楚，暂定不对取值路径做限定吧）</li><li>再找递归的模式, <code>如果不满足递归退出的条件，则将目标数组缩小一维，传递新的取值路径并递归</code></li></ul><p>然后就有了第一版代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getElement(array, indexes) &#123;</span><br><span class="line">  const idx = indexes.shift()</span><br><span class="line">  </span><br><span class="line">  if(indexes.length === 0 || array[idx].constructor !== Array ) return array[idx]</span><br><span class="line">  else return getElement(array[idx], indexes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后跑了跑作者提供的简单测试用例，<code>all passed</code>，我就说嘛，这么简单的题目不一把过岂不是有点丢脸，然后就直接点了提交，然后就蹦了一大片的<code>failed</code>测试用例出来，仔细看了看失败的测试用例，并没有看懂，因为都是很多莫名奇妙的数据，并且每次返回的结果都不一致（后来才知道是随机的用例）。</p><p>之后一直以为是自己有一些边界情况没有考虑到，就前前后后又看了几次自己的答案，并没有发现什么大的问题，但是无论怎么提交都是失败。之后前前后后大概看了15分钟左右，突然就觉得是我自己把问题想简单了。</p><p>因为最近一直在看函数式的东西，突然就联想到，自己写的这个函数，并不<code>纯</code>。关于纯函数是函数式编程中最基本的概念之一，所谓纯既是要求函数没有副作用，我这里的<code>getElement</code>使用了<code>Array.shift</code>方法，会对原数组进行修改，从而产生副作用。这么一想一下就和之前每次跑用例总是产生意想不到的结果的情况联系上了，随机用例的失败原因一定是因为测试路径会有很多个，但是测试目标数组只有一个，因此有副作用的话，只有第一次测试的结果是正确的，后面都会因副作用产生不同的结果。</p><p>既然是因为数组是<code>引用类型</code>而产生的问题，那么直接来一个<code>深拷贝</code>就可以了。因为这里只是答题，所以使用一个最简单粗暴的深拷贝大法<code>x =&gt; JSON.parse(JSON.stringify(x))</code>，然后代码就有了第二版代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getElement(array, indexes) &#123;</span><br><span class="line">  array = JSON.parse(JSON.stringify(array))</span><br><span class="line">  indexes = JSON.parse(JSON.stringify(indexes))</span><br><span class="line">  </span><br><span class="line">  const idx = indexes.shift()</span><br><span class="line">  </span><br><span class="line">  if(indexes.length === 0 || array[idx].constructor !== Array ) return array[idx]</span><br><span class="line">  else return getElement(array[idx], indexes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后提交，所有的用例都通过了。但是还没有结束，因为自己的代码在实现上还是挺啰嗦的，同时还使用了深拷贝大法，有没有更简单的方法呢？</p><p>有的。如果仔细思考一下，这里的解题的思路其实和<code>Array.reduce</code>的模式很像</p><ul><li>对一个数组进行遍历（对路径数组进行遍历）</li><li>每次遍历返回一个值，并作为参数传入下一次遍历（对目标函数的降维）</li><li>在遍历完成后，返回一个结果（取值路径对应的值）</li></ul><p>因此利用<code>Array.reduce</code>，这个问题一行代码就可以解决，如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getElement(array, indexes) &#123;</span><br><span class="line">  return indexes.reduce((a, i) =&gt; a[i], array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样多考虑一下，它是<code>纯函数</code>吗？是的，它是纯的。因为这里只做了取值的操作（<code>a[i]</code>），并不涉及任何的修改原数组的操作。这个答案也是在我提交后，所有答案中实现方案最好的一个。</p><p>当然还有其他的暴力破解法，我觉的想法也不错，比如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getElement(array, indexes) &#123;</span><br><span class="line">  return eval(`array[$&#123;indexes.join(&quot;][&quot;)&#125;]`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有利用<code>spread</code>运算符的方法，如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const getElement = (array,[index,...moreIndices]) =&gt; moreIndices.length ? getElement( array[index], moreIndices ) : array[index]</span><br></pre></td></tr></table></figure></p><p>所以工作累了，或者闲来无事，刷刷题还是挺有意思的，可以看见一些自己平时很熟悉但是在需要用时又难以想起的知识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;问题简述&lt;/h2&gt;
&lt;p&gt;给予一个多维数组和一个描述取值路径的一维数组, 通过调用函数&lt;code&gt;f&lt;/code&gt;返回取值路径描述的值，如
&lt;code&gt;f([[1, 2], [3, 4], [5, 6]], [0, 0]) -&amp;gt; 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a
      
    
    </summary>
    
    
      <category term="js" scheme="http://littlelyon.com/tags/js/"/>
    
      <category term="kata" scheme="http://littlelyon.com/tags/kata/"/>
    
  </entry>
  
  <entry>
    <title>从ng1看ng2 关于NgModule的简易归纳</title>
    <link href="http://littlelyon.com/2017/07/21/ng2-%E5%85%B3%E4%BA%8ENgModule%E7%9A%84%E7%AE%80%E6%98%93%E5%BD%92%E7%BA%B3/"/>
    <id>http://littlelyon.com/2017/07/21/ng2-关于NgModule的简易归纳/</id>
    <published>2017-07-21T07:16:35.000Z</published>
    <updated>2018-04-04T11:53:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2>写在前面</h2><p>最近开始折腾<a href="https://angular.io/" target="_blank" rel="noopener">ng2</a>，其实说是ng2，到目前为止，它已经发布了4.3版，就是这么的高产，高产似**，我连2都还木有完整的看完它竟然发布了4.*的版本（鄙视脸）。</p><p>不过话说回来，之前工作不忙的时候，想看看ng2的东西，我的天，又是ts，又是observable的，吓的我硬是没有上来就直接去看它的入门文档，而是买了本typescript的入门开始看，后来书看了一半，工作又忙了，就想着可否重构历史代码加顺带学习rxjs的姿势去做需求，后来我也是这么做的，庆幸的是，这么做效果是挺好的，不仅实际开发效率高了不少，同时也入门了rxjs。</p><p>最近工作又闲了下来，就想着赶紧带着半吊子的ts和rxjs水平看看ng2的文档吧，虽然ng2在国内似乎热度不如react和vue流行，但是在全世界还是劲头还是比较强劲的，毕竟有谷歌爸爸和微软爸爸做东，强强联合。</p><p>而且我是个遵守规则的人，一向喜欢大而全的东西，ng这种框架我觉的真的是很对我的胃口。不过这ng2的文档不看不要紧，一看真的是有些蛋疼，随便看个啥，连码代码加理解，估计一下午也就能看一个简单的概念，就比如今天想归纳的<code>NgModule</code>这部分东西，前后大概有30几页的东西，所以我觉的如果不写点东西总结一下，必然是看了就忘，忘了再看的节奏。</p><h2>ng1中的module回顾</h2><p>其实熟悉ng1的话，对于这ng2中的module的理解是很有帮助的。从ng1开始，就一直再提倡一个module的概念，比如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&apos;baz&apos;, [])</span><br><span class="line">angular.module(&apos;bar&apos;, [])</span><br><span class="line">angular.module(&apos;foo&apos;, [&apos;bar&apos;, &apos;baz&apos;])</span><br><span class="line">       .factory(&apos;fooFactory&apos;, function()&#123; ... &#125;)</span><br><span class="line">       .service(&apos;fooService&apos;, function()&#123; ... &#125;)</span><br><span class="line">       .component(&apos;fooComponent1&apos;, &#123; ... &#125;)</span><br><span class="line">       .directive(&apos;fooDirective&apos;, function()&#123; ... &#125;)</span><br></pre></td></tr></table></figure></p><p>这么的我就分别声明了<code>foo</code>、<code>bar</code>和<code>baz</code>的module，同时<code>foo</code>依赖于<code>baz</code>和<code>bar</code>，然后就没有然后了，之后你就可以在这个这些module中做一切你想做的任何事情。通过这种module的划分，我们可以在各个维度中，抽象我们的代码，比如从业务上、从代码类别上等等。</p><h2>ng2中的module简述</h2><p>ng2将这种概念更推进了一步，虽然我们可以使用module的方法来改变我们编程的思维，但是代码本身并不具有module的含义，这么说可能有点难理解，举个例子，就上面的例子，对于<code>bar</code>和<code>baz</code>模块，我们很难简单的从代码层面来区分它们分别的职能是什么。因此ng2改用了以<a href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841#.x5c2ndtx0" target="_blank" rel="noopener">Decorator</a>的方式来使代码具有语意性，如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@NgModule(&#123;</span><br><span class="line">  imports:      [ ... ],</span><br><span class="line">  declarations: [ ... ],</span><br><span class="line">  providers:    [ ... ],</span><br><span class="line">  exports:      [ ... ]</span><br><span class="line">&#125;)</span><br><span class="line">export class FooModule &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>通过<code>NgModule</code>这个装饰器来对一个class进行描述。如果直接和ng1对比的话，装饰器的参数对象中的几个属性分别对应ng1中的：</p><ul><li><code>imports</code>: 对应ng1声明中的模块依赖数组<code>['bar', 'baz']</code>，进行一些依赖模块的声明</li><li><code>declarations</code>: 对应ng1中的<code>.component('fooComponent1', { ... })</code>和<code>.directive('fooDirective', function(){ ... })</code>，进行一些声明式类的声明</li><li><code>providers</code>: 对应ng1中的<code>.service('fooService', function(){ ... })</code>和<code>.factory('fooFactory', function(){ ... })</code>，进行一些服务类的声明</li><li><code>exports</code>: ng1中没有独立的exports语法，因此不做对比，在ng1中只有依赖模块中提供的服务、模块，加载模块均可使用。</li></ul><h2>ng2中module分类</h2><p>ng2对不同的module提供了不同的语意性描述方式，可以通过装饰器属性来描述它们。</p><h3>root-module（根模块）</h3><p>所谓根模块，即一个应用的最上层的模块，即应用的入口模块，有时候也会称作app-module（这也是文档中指出的最佳实践）。这个概念在ng1中同样有，但是和上面指出的问题一样，就是没有代码层面的语意性描述，为了更好的描述它，ng2中的root-module会提供额外的装饰器属性来修饰它<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@NgModule(&#123;</span><br><span class="line">  ...,</span><br><span class="line">  bootstrap:      [ ... ]</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>这个<code>bootstrap</code>代表这个模块会在应用初始化阶段被引导和加载，一般来讲，ng2都会有一个独立的<code>main.ts</code>文件来引导加载根模块，这个过程对于根模块是透明的，因为它并不知道它如何被加载，有可能是在浏览器加载，有可能是在移动端加载等等，有可能使用JIT做动态加载，有可能提前编译好做静态加载，这些都是未知的，它仅仅需要表达的是，这个模块是可被引导加载的。通常情况下，一个应用只有一个root-module（这不是废话吗），但是在一些大型的应用中，可能会存在多个独立的子项目，那么就有可能存在多个root-module。</p><h3>sub-module（子模块）</h3><p>所谓子模块，即一个应用从属于根模块的模块，即应用按各个维度划分形成的颗粒，比如从功能划分、代码架构划分等等，有时候也会称作feature-module（这也是文档中指出的最佳实践），ng1同样无法在代码层面进行语意性描述。</p><p>一般来讲，只要符合<strong>ng2中的module简述</strong>中的模块声明方式声明的模块，就是一个feature-module，它具有什么样的feature，完全取决于它提供什么样的声明式组件和服务。对于不同的feature，如服务、指令和组件会以其他的装饰器进行修饰和声明，这不是本篇文章的内容，我们只需要知道，一个feature-module负责声明和管理它提供的服务和声明式组件。值得一提的是，和ng1不同，ng2中的feature-module可以声明一些私有的组件和服务，这一点在ng1中时做不到的。</p><h3>core-module（核心模块）</h3><p>核心模块其实本质上讲，即是feature-module，只不过它提供的声明式组件和服务，是基于app本身构建的。言外之意，就是它必须是单例的，比如像登录验证这种服务，就是一种全局性的、app级别的服务，再入导航、顶部条等组件，也是app级别的组件，这些东西应该归并到core-module中，并在app-module中加载它，而坚决不要在feature-module中加载它。</p><h3>share-module（共享模块）</h3><p>共享模块也是feature-module，只不过它提供的声明式组件和服务，是从各个feature-module中提取出的公共组件和服务，在官方的例子中，高亮这个指令，就是一个公用的指令，并不依赖于任何独立的业务逻辑。这些东西应该归并到share-module中，并在各个feature-module中加载它，从而使得我们的代码尽可能的保持简洁。</p><h3>lazy-load-module（懒加载模块）</h3><p>对于SPA来讲，路由是必不可少的东西。那么对于一些未使用页面所加载的模块，我们没有必要从一开始就加载它们，很自然的，它们就成为了懒加载模块，这些模块本质上讲均是feature-module，因为core-module和share-module从职能来讲，在整个的应用生命周期，尤其初始化必不可少，因此它们很少成为懒加载模块。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;最近开始折腾&lt;a href=&quot;https://angular.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ng2&lt;/a&gt;，其实说是ng2，到目前为止，它已经发布了4.3版，就是这么的高产，高产似**，我连2都还木有完
      
    
    </summary>
    
      <category term="原创" scheme="http://littlelyon.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="js" scheme="http://littlelyon.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>在 redux 中集成  angular di 机制</title>
    <link href="http://littlelyon.com/2017/05/31/%E5%9C%A8-redux-%E4%B8%AD%E9%9B%86%E6%88%90-angular-di-%E6%9C%BA%E5%88%B6/"/>
    <id>http://littlelyon.com/2017/05/31/在-redux-中集成-angular-di-机制/</id>
    <published>2017-05-31T01:29:57.000Z</published>
    <updated>2018-04-04T11:53:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在折腾<code>redux</code>相关的东西，算然说官方鼓励的使用方式是将redux和react一起使用，但并不影响我们在其他的mvvm框架中使用它。</p><p>众所周知，angular是一个大而全的框架，想和redux一起使用，需要摒弃一些angular中常用的开发理念与模式，仅仅将它作为一个视图层框架使用，就和react一样，不在将类似<code>domain state</code>和<code>app state</code>的状态维护在controller或service中，而是全权交给redux维护。</p><p>我们可以通过使用<a href="https://github.com/angular-redux/ng-redux" target="_blank" rel="noopener">ng-redux</a>注入redux服务，从而在angular中使用它。</p><p>基本的使用项目文档介绍的已经很详细了，这里仅仅想分享在这段时间折腾redux和angular遇到的一个比较蛋疼的问题，以及是如何解决的。</p><p>在redux中，业务逻辑的抽象被描述在action中，因此除了一些同步action以外，必然存在类似向后端发送请求获取数据之类的异步action。那么问题来了，在angular中有一个大家很熟悉的机制，叫做依赖注入（简称<code>di</code>），因为这种机制的存在，在angular中，我们一般使用一个服务是不关心它的实例化过程的，我们所做的，仅仅是声明它，告诉模块，我们在运行时，需要注入相关依赖的实例，但是在redux中没有这种机制，对于想在action使用的服务，你必须先导入它，实例化，你才可以使用，这与angular本身的di机制相悖。</p><p>那么我们如何来解决这个问题呢？</p><p>一种简单粗暴的方法就是，完全摒弃angular的di机制，使用外部的模块来解决问题。比如发请求，难道我们非要使用<code>$http</code>服务吗？我们完全可以直接使用像<code>superagent</code>这样的第三方库来代替它。但是随之而来的问题就是，对于angular已经使用<code>$http</code>服务的代码，你必须考虑是否重构它们，如果不重构，你则会在代码中拥有两套发送请求的逻辑，代码冗余了，如果重构呢，工作量又会很大，没准折腾redux不成，又给全改回去，得不偿失，因此这种方法不是完美的解决方案。最完美的方法应当是，既不摒弃angular的di机制，又可以兼顾redux框架，可是redux没有di机制这怎么破呢？</p><p>这个问题费了我不少时间去搜索网上的资料，类似如何在action使用angular di机制，如果在action获取service实例等等，虽然能查到的资料都没有完美的给出解决方案，但是都把问题的解决方向，指向了同一处，即redux的中间件机制。</p><p>第二种方法则通过redux中间件的机制来实现什么是中间件机制呢？这个可是个大概念，简单的理解的话，我只引用一个计算机常用的用来调侃的话解释。</p><blockquote><p>计算机科学中，没有什么问题是不能通过增加一个中间件来解决的。</p></blockquote><p>话虽然这么说，但是它是很有道理的，对于redux的中间件机制呢，它是对于action来设计的，即一个action，在最终转移到到处理它的reducer之前，会经过若干大大小小的中间件，这些中间件做的事情十分的简单，即输入一个action，按自己的处理逻辑加工它，再交到下一个中间件手中，直到没有下一个中间件为止。</p><p>明白了redux的中间件机制，那么上面的问题就好解决了，对于想在action中使用的通过angular di机制来实例化的服务，我们没有必要在action中实例化，我们完全可以仅仅在action中声明，之后呢，将实例化的过程交由中间件处理即可，那么可能你又会问，action没有办法集成di机制，中间件难道能集成吗，如果不能岂不是又回到了问题的原点？是的，但是中间件它的确可以集成di功能，为什么呢，因为中间件的实例化逻辑是通过ng-redux在angular内部进行的，而中间件本身呢，有仅仅是一个函数而已，那么我们完全可以把中间件的实现，声明成一个angular中的factory或者service，之后在其中使用angular的di机制，动态的实例化action中依赖服务的实例，关于这一点呢，在ng-redux的文档中有提及，但是没有说的特别的清楚。</p><p>talk is cheap, show me the code. 下面贴一下关于实现解决以上问题的中间件实现源码。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import angular from &apos;angular&apos;</span><br><span class="line">import R from &apos;ramda&apos;</span><br><span class="line"></span><br><span class="line">export default function thunkWithDepsMiddleware () &#123;</span><br><span class="line">  const injector = angular.element(document.body).injector()</span><br><span class="line"></span><br><span class="line">  return (&#123;dispatch, getState&#125;) =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">    const isNotNil = R.complement(R.isNil)</span><br><span class="line">    const isFSA = R.both(R.has(&apos;payload&apos;), R.has(&apos;type&apos;))</span><br><span class="line">    const isLastItemIsFunction = R.compose(R.is(Function), R.last)</span><br><span class="line">    const isAngularInlineArrayAnnotation = R.both(R.is(Array), isLastItemIsFunction)</span><br><span class="line">    let annotation</span><br><span class="line"></span><br><span class="line">    // FSA 处理逻辑</span><br><span class="line">    if (isFSA(action)) annotation = R.prop(&apos;payload&apos;, action)</span><br><span class="line">    // 普通 action 处理逻辑</span><br><span class="line">    else annotation = action</span><br><span class="line"></span><br><span class="line">    if (isAngularInlineArrayAnnotation(annotation)) &#123;</span><br><span class="line">      const locals = &#123;dispatch: dispatch, getState: getState&#125;</span><br><span class="line">      const payload = injector.invoke(annotation, this, locals)</span><br><span class="line">      if (isNotNil(payload)) return dispatch(&#123;...action, payload&#125;)</span><br><span class="line">    &#125; else if (R.is(Function, annotation)) &#123;</span><br><span class="line">      const payload = annotation(dispatch, getState)</span><br><span class="line">      if (isNotNil(payload)) return dispatch(&#123;...action, payload&#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return next(action)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大体逻辑呢，就是通过angular中$injector服务来解决问题，抽离出action中的关于di的声明逻辑，该中间间仅支持<code>inline array annotation</code>语法来声明依赖，对于符合<code>FSA(Flux Standard Action)</code>的action, 如果传入的action中的payload符合该语法，则通过injector.invoke来解析它，如果不是，则简单的按redux-thunk的处理逻辑进行处理，对于一般action同理，只不过是对于它本身进行处理。</p><p>实现之后呢，通过ng-redux的语法注册它，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ngReduxProvider.createStoreWith(reducers, [&apos;thunkWithDepsMiddleware&apos;, promiseMiddleware])</span><br></pre></td></tr></table></figure></p><p>之后我们的action即可直接返回符合<code>inline array annotation</code>语法的数组声明依赖，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export const fetchRoles = createAction(FETCH_ROLES, () =&gt; &#123;</span><br><span class="line">  return [&apos;$q&apos;, &apos;dispatch&apos;, ($q, dispatch) =&gt; &#123;</span><br><span class="line">    // do something ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一直在折腾&lt;code&gt;redux&lt;/code&gt;相关的东西，算然说官方鼓励的使用方式是将redux和react一起使用，但并不影响我们在其他的mvvm框架中使用它。&lt;/p&gt;
&lt;p&gt;众所周知，angular是一个大而全的框架，想和redux一起使用，需要摒弃一些angula
      
    
    </summary>
    
      <category term="原创" scheme="http://littlelyon.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="js" scheme="http://littlelyon.com/tags/js/"/>
    
      <category term="angular" scheme="http://littlelyon.com/tags/angular/"/>
    
      <category term="redux" scheme="http://littlelyon.com/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>es6中的混合器模式</title>
    <link href="http://littlelyon.com/2017/04/24/es6%E4%B8%AD%E7%9A%84%E6%B7%B7%E5%90%88%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://littlelyon.com/2017/04/24/es6中的混合器模式/</id>
    <published>2017-04-24T00:48:12.000Z</published>
    <updated>2018-04-04T11:53:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是有关设计模式相关的第一篇文章，谈及设计模式，一般情况下呢，很多人马上就会说出很多关于它的东西，比如单例模式、策略模式等等。对于各个技术栈的工程师们，各种设计模式应该再熟悉不过，这篇文章要分享的是关于前端中的混合器模式，也可以称作装饰器模式，并分享一些在实际开发中的应用。</p><p>在面向对象的开发中，实际业务的描述是通过<code>类(Class)</code>来进行描述的，如果想给一个已经存在的类扩展某些行为（如增加某个方法、某个属性等），可以通过<code>类的继承</code>来实现，即将可复用、可扩展的方法抽象为父类中的方法之后继承它。</p><p>但是思考一下，这种做法的弊端：</p><ul><li>类的继承所扩展的方法或属性是静态的，既你无法为一个已有的类的实例扩展某些方法。</li><li>类的继承会继承父类中的所有可继承的方法和属性，但是你只想继承其中的某个或某几个方法。</li></ul><p>在es6中，加入了<code>装饰器(Decorator)</code>语法，提供了对于装饰器模式的原生支持。这里对于语法不再进行详细的阐述，可以点击<a href="http://es6.ruanyifeng.com/#docs/decorator#%E7%B1%BB%E7%9A%84%E4%BF%AE%E9%A5%B0" target="_blank" rel="noopener">这里</a>进行了解或学习。</p><p>在这种模式下，我们可以动态的来为一个类增加某个方法或属性，你可能会问，这样听起来似乎和继承没什么不同？你错了，它的优势体现在<code>动态</code>二字，其含义即为可以动态的为类的实例增加某种行为，也许你又会说，在js中，它本身就是动态语言，这种动态性也失去了优势了吧。</p><p>是的，但是在js中想要实现继承绝非易事，因为它的继承机制是通过原型链进行描述的，对于js新手的话，理解起来其实是有点晦涩的，有些时候我们仅仅想通过更清晰的手段使用另一个类中的某些方法。</p><p>举个例子，在SPA开发中，经常会遇到处理分页数据的需求，对于分页逻辑的处理，很显然是一块需要抽象为公共方法的逻辑，但是如果你按继承的角度去考虑，就会发现，有些时候你继承了这些处理分页逻辑的方法反而是多余了，因为并不是每个页面都需要分页，这种情况下，使用混合器模式来实现则可以更好的解决问题。</p><p>我们先来实现一个分页逻辑的混合器，它其实是个函数，函数的参数是一个类，之后会动态的在这个类上增加一些方法，从而达到在<strong>一个类中混入另一个类的某些方法的目的</strong>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export const PaginationMixin = (superClass) =&gt; class extends superClass &#123;</span><br><span class="line">  nextPage (url, callback) &#123;</span><br><span class="line">    this.handlePaginationResolve(url, callback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  previousPage (url, callback) &#123;</span><br><span class="line">    this.handlePaginationResolve(url, callback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handlePaginationResolve (url, callback) &#123;</span><br><span class="line">    if (!url) return</span><br><span class="line"></span><br><span class="line">    customAPIComposer(url, &apos;get&apos;).then(callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后，只需要按如下进行代码，对需要扩展的类进行扩展，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class AttendanceManageCtrl extends PaginationMixin(MixinBase)</span><br></pre></td></tr></table></figure></p><p>扩展后就可以使用混合器中混入的方法了，如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;oa-list-table list-data=&apos;$ctrl.listData&apos; on-next=&apos;$ctrl.nextPage($ctrl.listData.next, $ctrl.render)&apos; on-previous=&apos;$ctrl.previousPage($ctrl.listData.previous, $ctrl.render)&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>这样做似乎和继承没什么区别，但是不妨看看如下代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class PeopleCtrl extends R.compose(PaginationMixin, StateManageMixin)(MixinBase)</span><br></pre></td></tr></table></figure></p><p>没错，你可以对一个类同时使用多个混合器，但是你却无法使一个类同时继承与多个类，虽然你可以通过多重继承实现，但显然比前者繁琐很多。</p><p>尽情混入吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是有关设计模式相关的第一篇文章，谈及设计模式，一般情况下呢，很多人马上就会说出很多关于它的东西，比如单例模式、策略模式等等。对于各个技术栈的工程师们，各种设计模式应该再熟悉不过，这篇文章要分享的是关于前端中的混合器模式，也可以称作装饰器模式，并分享一些在实际开发中的应用。
      
    
    </summary>
    
      <category term="原创" scheme="http://littlelyon.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="js" scheme="http://littlelyon.com/tags/js/"/>
    
      <category term="es6" scheme="http://littlelyon.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>codereview-s8</title>
    <link href="http://littlelyon.com/2017/02/07/codereview-s8/"/>
    <id>http://littlelyon.com/2017/02/07/codereview-s8/</id>
    <published>2017-02-07T02:02:05.000Z</published>
    <updated>2018-04-04T11:49:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2>当元素间存在父子关系时，留意事件冒泡机制所引发的连锁反应</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr style=&quot;cursor: pointer;&quot; ng-repeat=&quot;row in $ctrl.efficiencyTable.bodyData&quot; ng-click=&quot;$ctrl.stepView(row)&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;td class=&quot;text-left&quot;&gt;</span><br><span class="line">        &lt;a ng-click=&quot;$ctrl.efficiencyView(row)&quot; class=&quot;hover-link&quot;&gt;查看流程&lt;/a&gt;</span><br><span class="line">    &lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>a元素的点击事件会<code>efficiencyView</code>方法，但因为事件冒泡机制，也会间接的调用<code>stepView</code>方法</p></blockquote><h3>最佳实践</h3><blockquote><p>angular中可以使用内置的 $event 对象来解决相应问题</p></blockquote><p>首先声明使用<code>$event</code>对象并传参<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a ng-click=&quot;$ctrl.efficiencyView(row, $event)&quot; class=&quot;hover-link&quot;&gt;查看流程&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>之后再<code>efficiencyView</code>方法中调用<code>stopPropagation</code>方法阻止事件冒泡<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">efficiencyView (workflow, $event) &#123;</span><br><span class="line">    ...</span><br><span class="line">    $event.stopPropagation()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>也可以对比<code>$event</code>对象中的<code>target</code>和<code>currentTarget</code>属性是否相同，因为这两个属性分别代表触发事件的dom节点与响应事件的当前节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if($event.target === $event.currentTarget) ...</span><br></pre></td></tr></table></figure></p><h3>扩展</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">EventTarget.addEventListener 方法及其参数的含义</a></li><li><a href="http://blog.csdn.net/luanlouis/article/details/23927347" target="_blank" rel="noopener">解析Javascript事件冒泡机制</a></li></ul><h2>z-index 常见问题</h2><p>关于<code>z-index</code>本身用法我是了解的，但是最近在做下拉框组件和datepicker时，踩了一些坑，如下：</p><ul><li>只有设置了<code>position</code>属性的元素的<code>z-index</code>才会生效</li><li>当父容器的<code>z-index</code>小于元素A时，其子容器的<code>z-index</code>无论多大都无法覆盖元素A</li></ul><h3>最佳实践</h3><p>实现具有下拉菜单展开特效的组件时，一般会套用一下结构<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;dropdown-wrapper&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;dropdown-toggle&quot;&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;dropdown-list&quot;&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>当两个下拉菜单处于垂直布局时，如果没有设置<code>z-index</code>属性，因为<code>dropdown-toggle</code>比<code>dropdown-list</code>先出现，因此默认的图层顺序是前者高于后者，所以当上面的下拉菜单出现的时候，并不会覆盖下面的<code>toggle</code>,为了解决这个问题，必须做如下处理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.dropdown-list&#123;</span><br><span class="line">    ...</span><br><span class="line">    z-index: 1000;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后附上<a href="https://jsbin.com/suyojovino/edit?html,css,output" target="_blank" rel="noopener">DEMO</a></p><h3>扩展</h3><ul><li><a href="https://css-tricks.com/almanac/properties/z/z-index/" target="_blank" rel="noopener">z-index</a></li></ul><h2>对表格中的单元格增加一个hover高亮效果</h2><p>对于表格中<code>td</code>增加<code>hover</code>高亮时可能会遇到一个问题，就是当你使用常规的<code>border</code>属性对边框进行设置时，可能会发现，每个单元格的上边框和左边框都没有达到理想的效果，但是下边框和右边框却是正常的。这种问题会出现在对<code>table</code>增加<code>border-collapse: collapse</code>属性或是引用一些第三方的css库，比如bootstrap，具体现象参考<a href="https://jsbin.com/hivukumosu/edit?html,css,output" target="_blank" rel="noopener">DEMO</a>。</p><h3>最佳实践</h3><p>解决方法其实很简单，就是将<code>td</code>边框的样式从<code>solid</code>改为<code>double</code>，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table tr td &#123;</span><br><span class="line">    border-style: double;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原因如下：</p><blockquote><p>Since double is &quot;more distinct&quot; then solid, its colour takes precedence over cells around it, and looks identical to solid anyway ;)</p></blockquote><h3>扩展</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-style" target="_blank" rel="noopener">border-style各属性值及赋值语法</a></li></ul><h2>angular中遭遇的一个奇葩<a href="https://github.com/angular/angular.js/issues/4558" target="_blank" rel="noopener">问题</a></h2><p>这个问题是我在本期开发排班器组件时遇到的一个很奇葩的问题，大体描述就是如上面github链接中描述的一样，就是当父组件的一个数据采用双向绑定时，并且需要已事件回调的方法更新其内部的某个属性值，然后使用签名为<code>onChange</code>的<code>scope</code>属性传给子组件，比如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scope:&#123;</span><br><span class="line">    ...</span><br><span class="line">    onChange: &apos;&amp;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么这个<code>onChange</code>的调用在父组件进行更新某条以双向绑定方式进行绑定的属性时，会先于子组件的更新前自动调用，这么说有点抽象，大体的问题我简单描述下。</p><p>本来<code>onChange</code>的调用时机应当是自下而上的，也就是当子组件发生更新时，调用父组件通过<code>onChange</code>属性传递的事件回调方法，这个方法会更具子组件的当前状态来对父组件进行更新，这就是理想中的单向数据流子组件通知父组件进行更新的机制。但是在angular中遇到的奇葩现象现象就是，在父组件进行更新时，不知道是因为签名的缘故还是双向绑定的缘故，这个<code>onChange</code>都会先于子组件运行一次，那么问题来了，这个方法本来的调用时机是子组件更新后需要通知父组件进行相应更新时调用的，然而现在子组件还未更新则先调用了该方法，那么回调函数中的参数必为空，除非<code>onChange</code>中加入了空校验代码，不然就会报错，其实加了空校验也没有什么意义，因为这个方法都会调用的，但是却不会进行任何的改变，相当于浪费了一部分性能。</p><h3>最佳实践</h3><p>解决方法在<a href="http://plnkr.co/edit/fs7S6yX1a5aeo1Ese522?p=preview" target="_blank" rel="noopener">这里</a>，这种解决方法算是一种<code>workaround</code>，即在组件中使用另一个对象来储存父组件需要更新的那个值，算是做了一种类似中间件的处理，之后因为双向绑定自动更新机制对于对象的更新时更具<code>reference</code>来进行的，那么在父组件或子组件中对于这一个数据的引用均是相同的，而不会像基本数据类型存在一个新旧值的差异，不过这终究是一个<code>workaround</code>。</p><h2>限制上传文件的类型</h2><p>现在通过<code>type</code>为文件类型的<code>input</code>上传文件已经很普遍了，并且对于表单的校验，通常我们会在提交时进行，文件类型的表单也不例外，一般校验的内容有文件大小、文件类型（扩展名）等等。今天遇到一个需求很有意思，大体意思是想在用户进行文件上传时，就有偏向性的屏蔽掉一些不支持的文件格式，比如上传图片，那么在文件选择对话框就不要出现文本类型的文件。</p><p>这个问题我一开始是不知道怎么解决的，因为浏览器对于操作系统是一个沙盒，因此对于文件显示的控制应当没有权限控制，去网上google了下，答案也是这样的，没有方式可以实现百分之百屏蔽某种文件类型的方式。但是却发现了另一个很有意思的属性，也可以达到类型的效果。</p><p>这个属性就是<code>input</code>标签的<code>accept</code>属性：</p><blockquote><p>If the value of the type attribute is file, then this attribute will indicate the types of files that the server accepts, otherwise it will be ignored. The value must be a comma-separated list of unique content type specifiers:</p></blockquote><p>它可以接受的值的描述：</p><ul><li>A file extension starting with the STOP character (U+002E). (e.g. .jpg, .png, .doc).</li><li>A valid MIME type with no extensions.</li><li>audio/* representing sound files. HTML5</li><li>video/* representing video files. HTML5</li><li>image/* representing image files. HTML5</li></ul><h3>最佳实践</h3><p>比如我们想要限制上传文件类型为excel文件类型，只需要创建如下标签:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;file&quot; accept=&quot;.xls,.xlsx&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>这样这个文件表单对话框被激活时，默认会选取以.xls和.xlsx结尾的文件。</p><p>虽然这个属性可以达到类似的效果，但是是无法完全替代对于文件扩展名的校验的。因为只要用户想要上传别的类型的文件，通过切换文件对话框中的选取文件类型选项（比如显示全部文件类型），就可以选取别的类型的文件了，因此在提交时，也别忘了添加校验逻辑，防止因为上传了一些不支持的类型造成服务器内部错误。</p><h3>扩展</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input" target="_blank" rel="noopener">input</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;当元素间存在父子关系时，留意事件冒泡机制所引发的连锁反应&lt;/h2&gt;
&lt;p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
    
      <category term="js" scheme="http://littlelyon.com/tags/js/"/>
    
  </entry>
  
</feed>
