<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fine, thank you, and you.</title>
  <subtitle>一切安好，感谢有你，与你同行。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-22T02:24:37.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lyon Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【译】 Understanding SOLID Principles - Dependency Inversion</title>
    <link href="http://yoursite.com/2018/01/22/SOLID-d/"/>
    <id>http://yoursite.com/2018/01/22/SOLID-d/</id>
    <published>2018-01-22T02:21:35.000Z</published>
    <updated>2018-01-22T02:24:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Understanding-SOLID-Principles-Dependency-Inversion"><a href="#Understanding-SOLID-Principles-Dependency-Inversion" class="headerlink" title="Understanding SOLID Principles: Dependency Inversion"></a><a href="https://codeburst.io/understanding-solid-principles-dependency-injection-d570c15560ab" target="_blank" rel="external">Understanding SOLID Principles: Dependency Inversion</a></h1><blockquote>
<p>这是理解<code>SOLID</code>原则中，关于<strong>依赖倒置</strong>原则如何帮助我们编写低耦合和可测试代码的第一篇文章。</p>
</blockquote>
<h2 id="写在前头"><a href="#写在前头" class="headerlink" title="写在前头"></a>写在前头</h2><p>当我们在读书，或者在和一些别的开发者聊天的时候，可能会谈及或者听到术语<code>SOILD</code>。在这些讨论中，一些人会提及它的重要性，以及一个理想中的系统，应当包含它所包含的5条原则的特性。</p>
<p>我们在每次的工作中，你可能没有那么多时间思考关于<strong>架构</strong>这个比较大的概念，或者在有限的时间内或督促下，你也没有办法实践一些好的设计理念。</p>
<p>但是，这些原则存在的意义不是让我们“跳过”它们。软件工程师应当将这些原则应用到他们的开发工作中。所以，在你每一次敲代码的时候，如何能够正确的将这些原则付诸于行，才是真正的问题所在。如果可以那样的话，你的代码会变得更优雅。</p>
<p><code>SOLID</code>原则是由5个基本的原则构成的。这些概念会帮助创造更好（或者说更健壮）的软件架构。这些原则包含（<code>SOLID</code>是这5个原则的开头字母组成的缩略词）：</p>
<ul>
<li>S stands for SRP (Single responsibility principle)：单一职能原则</li>
<li>O stands for OCP (Open closed principle)：开闭原则</li>
<li>L stands for LSP (Liskov substitution principle)：里氏替换原则</li>
<li>I stand for ISP ( Interface segregation principle)：接口隔离原则</li>
<li>D stands for DIP ( Dependency inversion principle)：依赖倒置原则</li>
</ul>
<p>起初这些原则是<a href="https://en.wikipedia.org/wiki/Robert_Cecil_Martin" target="_blank" rel="external">Robert C. Martin</a>在1990年提出的，遵循这些原则可以帮助我们更好的构建，低耦合、高内聚的软件架构，同时能够真正的对现实中的业务逻辑进行恰到好处的封装。</p>
<p>不过这些原则并不会使一个差劲的程序员转变为一个优秀的程序员。这些法则取决于你如何应用它们，如果你是很随意的应用它们，那等同于你并没有使用它们一样。</p>
<p>关于原则和模式的知识能够帮助你决定在何时何地正确的使用它们。尽管这些原则仅仅是启示性的，它们是常见问题的常规解决方案。实践中，这些原则的正确性已经被证实了很多次，所以它们应当成为一种常识。</p>
<h2 id="依赖倒置原则是什么"><a href="#依赖倒置原则是什么" class="headerlink" title="依赖倒置原则是什么"></a>依赖倒置原则是什么</h2><ul>
<li>高级模块不应当依赖于低级模块。它们都应当依赖于抽象。</li>
<li>抽象不应当依赖于实现，实现应当依赖于抽象。</li>
</ul>
<p>这两句话的意思是什么呢？</p>
<p>一方面，你会抽象一些东西。在软件工程和计算机科学中，抽象是一种关于规划计算机系统中的复杂性的技术。它的工作原理一般是在一个人与系统交互的复杂环境中，隐藏当前级别下的更复杂的实现细节，同时它的范围很广，常常会覆盖多个子系统。这样，当我们在与一个以高级层面作为抽象的系统协作时，我们仅仅需要在意，我们能做什么，而不是我们<strong>如何</strong>做。</p>
<p>另外，你会针对你的抽象，有一写低级别的模块或者具体实现逻辑。这些东西与抽象是相反的。它们是被用于解决某些特定问题所编写的代码。它们的作用域仅仅在某个单元和子系统中。比如，建立一个与MySQL数据库的连接就是一个低级别的实现逻辑，因为它与某个特定的技术领域所绑定。</p>
<p>现在仔细读这两句话，我们能够得到什么暗示呢？</p>
<p>依赖倒置原则存在的真正意义是指，我们需要将一些对象解耦，它们的耦合关系需要达到当一个对象依赖的对象作出改变时，对象本身不需要更改任何代码。</p>
<p>这样的架构可以实现一种松耦合的状态的系统，因为系统中所有的组件，彼此之间都了解很少或者不需要了解系统中其余组件的具体定义和实现细节。它同时实现了一种可测试和可替换的系统架构，因为在松耦合的系统中，任何组件都可以被提供相同服务的组件所替换。</p>
<p>但是相反的，依赖倒置也有一些缺点，就是你需要一个用于处理依赖倒置逻辑的容器，同时，你还需要配置它。容器通常需要具备能够在系统中注入服务，这些服务需要具备正确的作用域和参数，还应当被注入正确的执行上下文中。</p>
<h2 id="以提供Websocket连接服务为例子"><a href="#以提供Websocket连接服务为例子" class="headerlink" title="以提供Websocket连接服务为例子"></a>以提供Websocket连接服务为例子</h2><p>举个例子，我们可以在这个例子中学到更多关于依赖倒置的知识，我们将使用<code>Inversify.js</code>作为依赖倒置的容器，通过这个依赖倒置容器，我们可以看看如何针对提供<code>Websocket</code>连接服务的业务场景，提供服务。</p>
<p>比如，我们有一个web服务器提供<code>WebSockets</code>连接服务，同时客户端想要连接服务器，同时接受更新的通知。当前我们有若干种解决方案来提供一个WebSocket服务，比如说<code>Socket.io</code>、<code>Socks</code>或者使用浏览器提供的关于原生的<code>WebSocket</code>接口。每一套解决方案，都提供不同的接口和方法供我们调用，那么问题来了，我们是否可以在一个接口中，将所有的解决方案都抽象成一个提供<code>WebSocket</code>连接服务的提供者？这样，我们就可以根据我们的实际需求，使用不同的WebSocket服务提供者。</p>
<p>首先，我们来定义我们的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">export interface WebSocketConfiguration &#123;</div><div class="line">  uri: string;</div><div class="line">  options?: Object;</div><div class="line">&#125;</div><div class="line">export interface SocketFactory &#123;</div><div class="line">  createSocket(configuration: WebSocketConfiguration): any;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意在接口中，我们没有提供任何的实现细节，因此它既是我们所拥有的<strong>抽象</strong>。</p>
<p>接下来，如果我们想要一个提供<code>Socket.io</code>服务工厂：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import &#123;Manager&#125; from &apos;socket.io-client&apos;;</div><div class="line"></div><div class="line">class SocketIOFactory implements SocketFactory &#123;</div><div class="line">  createSocket(configuration: WebSocketConfiguration): any &#123;</div><div class="line">    return new Manager(configuration.uri, configuration.opts);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里已经包含了一些具体的实现细节，因此它不再是抽象，因为它声明了一个从<code>Socket.io</code>库中导入的<code>Manager</code>对象，它是我们的具体实现细节。</p>
<p>我们可以通过实现<code>SocketFactory</code>接口，来增加若干工厂类，只要我们实现这个接口即可。</p>
<p>我们在提供一个关于客户端连接实例的抽象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">export interface SocketClient &#123;</div><div class="line">  connect(configuration: WebSocketConfiguration): Promise&lt;any&gt;;</div><div class="line">  close(): Promise&lt;any&gt;;</div><div class="line">  emit(event: string, ...args: any[]): Promise&lt;any&gt;;</div><div class="line">  on(event: string, fn: Function): Promise&lt;any&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后再提供一些实现细节：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">class WebSocketClient implements SocketClient &#123;</div><div class="line">  private socketFactory: SocketFactory;</div><div class="line">  private socket: any;</div><div class="line">  public constructor(webSocketFactory: SocketFactory) &#123;</div><div class="line">    this.socketFactory = webSocketFactory;</div><div class="line">  &#125;</div><div class="line">  public connect(config: WebSocketConfiguration): Promise&lt;any&gt; &#123;</div><div class="line">    if (!this.socket) &#123;</div><div class="line">      this.socket = this.socketFactory.createSocket(config);</div><div class="line">    &#125;</div><div class="line">    return new Promise&lt;any&gt;((resolve, reject) =&gt; &#123;</div><div class="line">      this.socket.on(&apos;connect&apos;, () =&gt; resolve());</div><div class="line">      this.socket.on(&apos;connect_error&apos;, (error: Error) =&gt; reject(error));</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  public emit(event: string, ...args: any[]): Promise&lt;any&gt; &#123;</div><div class="line">    return new Promise&lt;string | Object&gt;((resolve, reject) =&gt; &#123;</div><div class="line">      if (!this.socket) &#123;</div><div class="line">        return reject(&apos;No socket connection.&apos;);</div><div class="line">      &#125;</div><div class="line">      return this.socket.emit(event, args, (response: any) =&gt; &#123;</div><div class="line">        if (response.error) &#123;</div><div class="line">          return reject(response.error);</div><div class="line">        &#125;</div><div class="line">        return resolve();</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  public on(event: string, fn: Function): Promise&lt;any&gt; &#123;</div><div class="line">    return new Promise&lt;any&gt;((resolve, reject) =&gt; &#123;</div><div class="line">      if (!this.socket) &#123;</div><div class="line">        return reject(&apos;No socket connection.&apos;);</div><div class="line">      &#125;</div><div class="line">      this.socket.on(event, fn);</div><div class="line">      resolve();</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  public close(): Promise&lt;any&gt; &#123;</div><div class="line">    return new Promise&lt;any&gt;((resolve) =&gt; &#123;</div><div class="line">      this.socket.close(() =&gt; &#123;</div><div class="line">        this.socket = null;</div><div class="line">        resolve();</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>值得注意的是，这里我们在构造函数中，传入了一个类型是<code>SocketFactory</code>的参数，这是为了满足关于依赖倒置原则的第一条规则。对于第二条规则，我们需要一种方式来提供这个不需要了解内部实现细节的、可替换的、易于配置的参数。</p>
<p>这也是为什么我们要使用<code>Inversify</code>这个库的原因，我们来加入一些额外的代码和注解（装饰器）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import &#123;injectable&#125; from &apos;inversify&apos;;</div><div class="line">const webSocketFactoryType: symbol = Symbol(&apos;WebSocketFactory&apos;);</div><div class="line">const webSocketClientType: symbol = Symbol(&apos;WebSocketClient&apos;);</div><div class="line">let TYPES: any = &#123;</div><div class="line">    WebSocketFactory: webSocketFactoryType,</div><div class="line">    WebSocketClient: webSocketClientType</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@injectable()</div><div class="line">class SocketIOFactory implements SocketFactory &#123;...&#125;</div><div class="line">...</div><div class="line">@injectable()</div><div class="line">class WebSocketClient implements SocketClient &#123;</div><div class="line">public constructor(@inject(TYPES.WebSocketFactory) webSocketFactory: SocketFactory) &#123;</div><div class="line">  this.socketFactory = webSocketFactory;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这些注释（装饰器）仅仅会在代码运行时，在如何提供这些组件实例时，提供一些元数据，接下来我们仅仅需要创建一个依赖倒置容器，并将所有的对象按正确的类型绑定起来，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import &#123;Container&#125; from &apos;inversify&apos;;</div><div class="line">import &apos;reflect-metadata&apos;;</div><div class="line">import &#123;TYPES, SocketClient, SocketFactory, SocketIOFactory, WebSocketClient&#125; from &apos;@web/app&apos;;</div><div class="line">const provider = new Container(&#123;defaultScope: &apos;Singleton&apos;&#125;);</div><div class="line">// Bindings</div><div class="line">provider.bind&lt;SocketClient&gt;(TYPES.WebSocketClient).to(WebSocketClient);</div><div class="line">provider.bind&lt;SocketFactory&gt;(TYPES.WebSocketFactory).to(SocketIOFactory);</div><div class="line">export default provider;</div></pre></td></tr></table></figure></p>
<p>让我们来看看我们如何使用我们提供连接服务的客户端实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var socketClient = provider.get&lt;SocketClient&gt;(TYPES.WebSocketClient);</div></pre></td></tr></table></figure></p>
<p>当然，使用<code>Inversify</code>可以提供一些更简单易用的绑定，可以通过浏览它的网站来了解。</p>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>一般说到依赖倒置原则，往往第一个想到的术语即是<code>依赖注入</code>，这种在各个技术栈都有应用，之后又会马上想到<code>spring</code>、<code>ng</code>等前后端框架。</p>
<p>我们确实是通过使用这些框架熟知这个概念的，但是如果你仔细想想的话，是否还有其他的一些场景也使用了类似的概念呢？</p>
<p>比如：</p>
<ul>
<li>一些使用插件和中间件的框架，如<code>express</code>、<code>redux</code></li>
<li>js中this的动态绑定</li>
<li>js中的回调函数</li>
</ul>
<p>也许有的人会不同意我的观点，会说依赖注入一般都是面向类和接口来讲的，这确实有一定的道理，但是我认为没有必要局限在一种固定的模式中去理解依赖倒置，毕竟它是一种思想，一种模式，在js中，所有的东西都是动态的，函数是一等公民，是对象，那么把这些与依赖倒置原则联系起来，完全也讲的通。我们真正关心的是核心问题是如何<strong>解耦</strong>，把更多的注意力投入的真正的业务逻辑中去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Understanding-SOLID-Principles-Dependency-Inversion&quot;&gt;&lt;a href=&quot;#Understanding-SOLID-Principles-Dependency-Inversion&quot; class=&quot;headerlin
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="编程思想" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>尝鲜 workerize 源码</title>
    <link href="http://yoursite.com/2018/01/16/workerize/"/>
    <id>http://yoursite.com/2018/01/16/workerize/</id>
    <published>2018-01-16T02:11:31.000Z</published>
    <updated>2018-01-16T02:11:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近正好在看web worker相关的东西，今天无意中就看到了github一周最热项目的推送中，有这么一个项目<a href="https://github.com/developit/workerize" target="_blank" rel="external">workerize</a>，repo里的文档的描述如下：</p>
<blockquote>
<p>Moves a module into a Web Worker, automatically reflecting exported functions as asynchronous proxies.</p>
</blockquote>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>关于README很简单，包含一个类似hello world的例子就没其他什么了。但是从例子本身可以看出这个库要解决的问题，是想通过模块化的方式编写运行在web worker中的脚本，因为通常情况下，web worker每加载一个脚本文件是需要通过一个符合同源策略的URL的，这样会对服务端发送一个额外的请求。同时对于web worker本身加载的js文件的执行环境，与主线程是隔离的（这也是它在进行复杂运算时不会阻塞主线程的原因），与主线程的通讯靠<code>postMessage</code>api和<code>onmessage</code>回调事件来通讯，这样我们在编写一些通信代码时，需要同时在两个不同的环境中分别编写发送消息和接受消息的逻辑，比较繁琐，同时这些代码也不能以模块化的形式存在。</p>
<p>如果存在一种方式，我们可以以模块化的方式来编写代码，注入web worker，之后还能通过类似Promsie机制来处理等异步，那便是极好的。</p>
<p>先来看看例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import workerize from &apos;workerize&apos;</div><div class="line"></div><div class="line">let worker1 = workerize(`</div><div class="line">	export function add(a, b) &#123;</div><div class="line">		let start = Date.now();</div><div class="line">		while (Date.now()-start &lt; 500);</div><div class="line">		return a + b;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  export default function minus(a, b)&#123;</div><div class="line">    let start = Date.now();</div><div class="line">		while (Date.now()-start &lt; 500);</div><div class="line">    return a - b</div><div class="line">  &#125;</div><div class="line">`)</div><div class="line"></div><div class="line">let worker2 = workerize(function (m) &#123;</div><div class="line">  m.add = function (a, b) &#123;</div><div class="line">    let start = Date.now()</div><div class="line">    while (Date.now() - start &lt; 500);</div><div class="line">    return a + b</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">(async () =&gt; &#123;</div><div class="line">  console.log(&apos;1 + 2 = &apos;, await worker1.add(1, 2))</div><div class="line">  console.log(&apos;3 + 9 = &apos;, await worker2.call(&apos;add&apos;, [3, 9]))</div><div class="line">&#125;)()</div></pre></td></tr></table></figure></p>
<p>worker1和worker2是两种不同的使用方式，一种是以字符串的形式声明模块，一种以函数的形式声明模块。但是无论哪种，最后的结果都是一样的，我们可以通过worker实例显示的调用我们想要调用的方法，每个方法的调用结果均是一个Promise，因此它还可以完美的适配async/await语法。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>那么问题来了，这种模块的加载机制和调用方式是怎样实现的呢？我在运行demo代码的时候心中也默默想到，我去，看了好几天的web worker原来还能这么玩，所以一定要研究研究它的源码和它的实现原理。</p>
<p>打开源代码才发现其实并没有多少代码，官文文档也通过一句话强调了这一点：</p>
<blockquote>
<p>Just 900 bytes of gzipped ES3</p>
</blockquote>
<p>所以对其中主要的两点进行简单说明：</p>
<ul>
<li>如何实现按内容模块化加载脚本而不是通过URL</li>
<li>如何通过Promise来代理主线程与worker线程的通讯过程</li>
</ul>
<h3 id="使用Blob动态生成加载脚本资源"><a href="#使用Blob动态生成加载脚本资源" class="headerlink" title="使用Blob动态生成加载脚本资源"></a>使用Blob动态生成加载脚本资源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let blob = new Blob([code], &#123;</div><div class="line">      type: &apos;application/javascript&apos;</div><div class="line">    &#125;),</div><div class="line">    url = URL.createObjectURL(blob),</div><div class="line">    worker = new Worker(url)</div></pre></td></tr></table></figure>
<p>这其实不是什么新鲜的东西，就是将代码的内容转化为Blob对象，之后再通过<code>URL.createObjectURL</code>将Blob对象转化为URL的形式，之后再用worker加载它，仅此而已。但是这里的问题是，这个<code>code</code>是哪里从哪里来的呢？</p>
<h3 id="将加载代码模块化"><a href="#将加载代码模块化" class="headerlink" title="将加载代码模块化"></a>将加载代码模块化</h3><p>在加载代码之前，还有重要的一步，就是需要将加载的代码转变为模块，模板本身只对外暴露统一的接口，这样不论对于主线程还是worker线程，就有了统一的约束条件。源码中作者把上一步中的<code>code</code>转化为了类似commonjs的形式，主要涉及的代码有:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let exportsObjName = `__EXPORTS_$&#123;Math.random().toString().substring(2)&#125;__`</div><div class="line">  if (typeof code === &apos;function&apos;) code = `($&#123;toCode(code)&#125;)($&#123;exportsObjName&#125;)`</div><div class="line">  code = toCjs(code, exportsObjName, exports)</div><div class="line">  code += `\n($&#123;toCode(setup)&#125;)(self, $&#123;exportsObjName&#125;, &#123;&#125;)`</div></pre></td></tr></table></figure></p>
<p>和<code>toCjs</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function toCjs (code, exportsObjName, exports) &#123;</div><div class="line">  exportsObjName = exportsObjName || &apos;exports&apos;</div><div class="line">  exports = exports || &#123;&#125;</div><div class="line">  code = code.replace(/^(\s*)export\s+default\s+/m, (s, before) =&gt; &#123;</div><div class="line">    exports.default = true</div><div class="line">    return `$&#123;before&#125;$&#123;exportsObjName&#125;.default = `</div><div class="line">  &#125;)</div><div class="line">  code = code.replace(/^(\s*)export\s+(function|const|let|var)(\s+)([a-zA-Z$_][a-zA-Z0-9$_]*)/m, (s, before, type, ws, name) =&gt; &#123;</div><div class="line">    exports[name] = true</div><div class="line">    return `$&#123;before&#125;$&#123;exportsObjName&#125;.$&#123;name&#125; = $&#123;type&#125;$&#123;ws&#125;$&#123;name&#125;`</div><div class="line">  &#125;)</div><div class="line">  return `var $&#123;exportsObjName&#125; = &#123;&#125;;\n$&#123;code&#125;\n$&#123;exportsObjName&#125;;`</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于toCjs方法，如果你的正则知识比较扎实的话，可以发现，它做了一件事，就是将字符串类型的code中的所有导出方法的声明，使用commonjs的导出语法替换掉(中间会涉及一些具体的语法规则)，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 如果 exportsObjName 使用默认值 exports, ...代表省略代码</div><div class="line">export function foo()&#123; ... &#125; =&gt; exports.foo = function foo()&#123; ... &#125;</div><div class="line">export default ... =&gt; exports.default = ...</div></pre></td></tr></table></figure></p>
<p>如果code是函数类型，则首先使用<code>toCode</code>函数将code转化为string类型，之后再将它转化为IIFE的形式，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 如果 exportsObjName 使用默认值 exports, ...代表省略代码</div><div class="line">// 传入的code是如下形式：</div><div class="line">function( m )&#123; </div><div class="line">  ... </div><div class="line">&#125;</div><div class="line">// 转化为</div><div class="line">(function( m )&#123;</div><div class="line">  ...</div><div class="line">&#125;)(exports)</div></pre></td></tr></table></figure></p>
<p>这里的<code>exportsObjName</code>代表模块的名字，默认值是<code>exports</code>(联想commonjs)，不过这里会在一开始就随机生成一个模块名字，生成代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let exportsObjName = `__EXPORTS_$&#123;Math.random().toString().substring(2)&#125;__`</div></pre></td></tr></table></figure></p>
<p>这样只有我们按照约定的语法来编写web worker加载的代码，它便会加载了一个符合同样约定的commonjs模块。</p>
<h3 id="使用-Promise-来做异步代理"><a href="#使用-Promise-来做异步代理" class="headerlink" title="使用 Promise 来做异步代理"></a>使用 Promise 来做异步代理</h3><p>经过上面两步，web worker加载到了模块化的代码，但是worker线程与主线程进行通讯则是仍然需要通过<code>postMessage</code>方法和<code>onmessage</code>回调事件来进行，如果无法优雅地处理这里的异步逻辑，那么之前所做的工作其实意义并不大。</p>
<p>workerize针对这里的异步逻辑，设计了一个简单的rpc协议（文档中将这个称作<code>a tiny, purpose-built RPC</code>），先来看一下源码中的<code>setup</code>函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">function setup (ctx, rpcMethods, callbacks) &#123;</div><div class="line">    ctx.addEventListener(&apos;message&apos;, (&#123; data &#125;) =&gt; &#123;</div><div class="line">      // 只捕获满足条件的数据对象</div><div class="line">      if (data.type === &apos;RPC&apos;) &#123;</div><div class="line">        // 获取数据对象中的 id 属性</div><div class="line">        let id = data.id</div><div class="line">        if (id != null) &#123;</div><div class="line">          // 如果数据对象中存在非空 method 属性，则证明是主线程发送的消息</div><div class="line">          if (data.method) &#123;</div><div class="line">            // 获取所要调用的方法实例</div><div class="line">            let method = rpcMethods[data.method]</div><div class="line">            if (method == null) &#123;</div><div class="line">              // 如果所调用的方法实例不存在，则发送方法不存在的消息</div><div class="line">              ctx.postMessage(&#123; type: &apos;RPC&apos;, id, error: &apos;NO_SUCH_METHOD&apos; &#125;)</div><div class="line">            &#125; else &#123;</div><div class="line">              // 如果方法存在，则调用它，并将调用结果按不同的类型发送</div><div class="line">              Promise.resolve()</div><div class="line">                .then(() =&gt; method.apply(null, data.params))</div><div class="line">                .then(result =&gt; &#123; ctx.postMessage(&#123; type: &apos;RPC&apos;, id, result &#125;) &#125;)</div><div class="line">                .catch(error =&gt; &#123; ctx.postMessage(&#123; type: &apos;RPC&apos;, id, error &#125;) &#125;)</div><div class="line">            &#125;</div><div class="line">          // 如果 method 属性为空，则证明是 worker 线程发送的消息</div><div class="line">          &#125; else &#123;</div><div class="line">            // 获取每个消息所对应的处于pending状态的Promise实例</div><div class="line">            let callback = callbacks[id]</div><div class="line">            if (callback == null) throw Error(`Unknown callback $&#123;id&#125;`)</div><div class="line">            delete callbacks[id]</div><div class="line"></div><div class="line">            // 按消息的类型将Promise转化为resolve状态或reject状态。</div><div class="line">            if (data.error) callback.reject(Error(data.error))</div><div class="line">            else callback.resolve(data.result)</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>根据注释我们可以知道，这里的setup函数包含了rpc协议的解析规则，因此主线程和worker线程对会调用该方法来注册安装这个rpc协议，具体的代码如下：</p>
<ul>
<li>主线程: <code>setup(worker, worker.rpcMethods, callbacks)</code></li>
<li>worker线程: <code>code += `\n(${toCode(setup)})(self, ${exportsObjName}, {})</code></li>
</ul>
<p>这两处代码都是在各自的作用域中，将rpc协议与当前加载的模块绑定起来，只不过主进程所传<code>callbacks</code>是有意义的，而worker则使用一个空对象代替。</p>
<h3 id="注册调用逻辑"><a href="#注册调用逻辑" class="headerlink" title="注册调用逻辑"></a>注册调用逻辑</h3><p>在拥有了rpc协议的基础上，只需要实现调用逻辑即可，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">worker.call = (method, params) =&gt; new Promise((resolve, reject) =&gt; &#123;</div><div class="line">    let id = `rpc$&#123;++counter&#125;`</div><div class="line">    callbacks[id] = &#123; method, resolve, reject &#125;</div><div class="line">    worker.postMessage(&#123; type: &apos;RPC&apos;, id, method, params &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这个<code>call</code>方法，每次会将一次方法的调用，转化为一个<code>pending</code>状态的<code>Promise</code>实例，并存在<code>callbacks</code>变量中，同时向worker线程发送一个格式为调用方法数据格式的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (let i in exports) &#123;</div><div class="line">   if (exports.hasOwnProperty(i) &amp;&amp; !(i in worker)) &#123;</div><div class="line">     worker[i] = (...args) =&gt; worker.call(i, args)</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时在初始化的过程中，会将主线程加载的模块中的每个方法，都绑定一个快捷方法，其方法名与模块中的函数声明保持一致，内部则使用<code>worker.call</code>来完成调用逻辑。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>关于这个库本身，还存在一些可以探讨的问题，比如：</p>
<ul>
<li>是否支持依赖解析机制</li>
<li>如果引入外部依赖模块</li>
<li>针对消息是否需要按队列进行处理</li>
</ul>
<p>关于前两点，似乎作者有一个相同的项目，叫做<code>workerize-loader</code>，可以解决，关于第三点，作者在代码中增加了todo，表示实现消息队列机制可能没有必要，因为当前的通讯基于postMessage，本身的结果已经是有序状态的了。</p>
<p>关于源码本身的分析大概就这样了，希望可以抛砖引玉，如有错误，还望指正。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;最近正好在看web worker相关的东西，今天无意中就看到了github一周最热项目的推送中，有这么一个项目&lt;a href
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="web worker" scheme="http://yoursite.com/tags/web-worker/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>高级 Angular 组件模式 (3b)</title>
    <link href="http://yoursite.com/2018/01/10/aacp-3b/"/>
    <id>http://yoursite.com/2018/01/10/aacp-3b/</id>
    <published>2018-01-10T14:02:45.000Z</published>
    <updated>2018-01-11T02:32:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="03-b-Enhance-Components-with-Directives"><a href="#03-b-Enhance-Components-with-Directives" class="headerlink" title="03-b Enhance Components with Directives"></a>03-b Enhance Components with Directives</h2><blockquote>
<p>原文: <a href="https://blog.angularindepth.com/enhance-components-with-directives-58f16c4ca1f" target="_blank" rel="external">Enhance Components with Directives</a></p>
</blockquote>
<p>Kent C. Dodds的第四篇文章中的一个重要元素在上一篇文章中没有涉及，使用<code>withToggle</code>高阶组件(HoC, react中的常用模式)可以将<code>&lt;toggle-on&gt;</code>、<code>&lt;toggle-off&gt;</code>、<code>&lt;toggle-button&gt;</code>组件中的公用逻辑分离出来。</p>
<p>虽然上一篇文章中上面提及的三个组件并没有太多的公用逻辑，可以万一它们有公用逻辑呢？如果我们想要提供更加声明式的功能，比如能够显式的声明它们使用的<code>&lt;toggle&gt;</code>组件实例而非最邻近的父实例。</p>
<p>同时，因为<code>&lt;toggle&gt;</code>组件的模板并不存在任何的变动，我们可以将它转化为一个<strong>指令</strong>，这样我们可以以更加灵活的方式来使用它。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>允许我们的<code>&lt;toggle&gt;</code>组件能够以<code>tag</code>的形式或者<code>attribute</code>的形式使用，如<code>&lt;toggle&gt;</code>或者<code>&lt;div toggle&gt;&lt;/div&gt;</code></li>
<li>允许通过`withToggle<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 实现</div><div class="line">### 1）将``&lt;toggle&gt;``作为一个指令</div><div class="line">将``&lt;toggle&gt;``组件改变为指令十分简单，因为它本身的模板仅仅是``&lt;ng-content&gt;&lt;/ng-content&gt;``，在组件渲染时，``&lt;ng-content&gt;``会被替换为我们当前组件标签内包含的内容，所以我们可以直接移除它，并使用``@Directive``装饰器来描述``&lt;toggle&gt;``组件，如下：</div></pre></td></tr></table></figure></li>
</ul>
<p>@Directive({<br>  exportAs: ‘toggle’,<br>  selector: ‘toggle, [toggle]’,<br>})<br>export class ToggleDirective {}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">你可能注意到了，指令的选择器允许``toggle``指令可以以**标签名**和**属性名**的形式来使用。对于``exportAs``关键字是必须要提供的，因为这是当我们需要在别的指令或者组件能够获取``toggle``指令引用的名字，会在这个系列文章的第5章详细删除``exportAs``（Handle Template Reference Variables with Directives）。</div><div class="line"></div><div class="line">### 2）``withToggle``指令</div><div class="line">在这个新的指令中，我们将会封装关于如何选取需要绑定某个``toggle``指令实例的逻辑。</div><div class="line"></div><div class="line">首先，我们的设想是这样的，每一个组件注入``withToggle``指令，而不是直接注入最邻近的父``toggle``指令。同时每个使用``withToggle``指令的组件通过使用``withToggle.toggle``来访问它所绑定的``toggle``指令的实例，如下：</div></pre></td></tr></table></figure></p>
<p>@Component({<br>  selector: ‘toggle-off’,<br>  template: <code>&lt;ng-content *ngIf=&quot;!withToggle.toggle?.on&quot;&gt;&lt;/ng-content&gt;</code>,<br>})<br>export class ToggleOffComponent {<br>  constructor(public withToggle: WithToggleDirective) {}<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">其次，``withToggle``指令将它自身与``toggle``指令的选择器绑定（就是两个指令的选择器是相同的），同时增加一个额外的选择器``[withToggle]``，如下：</div></pre></td></tr></table></figure></p>
<p>@Directive({<br>  exportAs: ‘withToggle’,<br>  selector: ‘toggle, [toggle], [withToggle]’,<br>})<br>export class WithToggleDirective //…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">现在``withToggle``指令为它的子组件们提供所绑定的``toggle``指令实例，无论这个实例是显示绑定的，还是默认的父``toggle``指令。关于其中实现的具体细节，可以参考文章最后的[附录部分](#附录)。</div><div class="line"></div><div class="line">## 成果</div><div class="line">我们的``app.component.html``现在可以通过三种不同的使用方式来展现内容。</div><div class="line"></div><div class="line">### 1）基本</div></pre></td></tr></table></figure></p>
<p><div toggle="" #firsttoggle="toggle"><br>  …<br>  <toggle #secondtoggle="toggle"><br>    …<br>  </toggle><br></div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">注意``#firstToggle``和``#secondToggle``视图变量是如何使用``toggle``组件的，前者使用属性声明的方式，后者使用标签名声明方式，无论怎样，它们都按理想中那样运行。</div><div class="line"></div><div class="line">而且，``#secondToggle``是嵌套在``#firstToggle``中的，所以它的子组件使用的是它本身的开关状态，而非``#firstToggle``中的，这符合我们的预期。</div><div class="line"></div><div class="line">### 2）显式引用</div></pre></td></tr></table></figure></p>
<p></p><p [withtoggle]="firstToggle"><br>  First:<br>  <toggle-on>On</toggle-on><br>  <toggle-off>Off</toggle-off><br>  <toggle-button></toggle-button><br></p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">这里没有任何``toggle``指令是当前``p``标签的子组件的祖先，但是通过``withToggle``指令，我们可以让所有的子组件使用``#firstToggle``的``toggle``指令实例。</div><div class="line"></div><div class="line">### 3）自定义组件</div></pre></td></tr></table></figure><p></p>
<p><div [withtoggle]="firstToggle"><br>  <labelled-state togglename="First"></labelled-state><br>  <labelled-button togglename="First"></labelled-button><br></div></p>
<p><labelled-state togglename="Second" [withtoggle]="secondToggle"> </labelled-state></p>
<p><labelled-button togglename="Second" [withtoggle]="secondToggle"> </labelled-button><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">``withToggle``指令甚至可以通过DI机制注入到内部的任何自定义组件中，如``&lt;labelled-state&gt;``组件和``&lt;labelled-button&gt;``都没有任何关于``withToggle``或者``toggle``的引用声明。它们无需关心这个开关状态的来源，它们仅仅需要知道的是，根据这个开关状态，如何与它们的子组件进行交互。</div><div class="line"></div><div class="line">## 附录</div><div class="line">``withToggle``的实现，是一个标准的指令声明方式，除了它的构造方法，如下：</div></pre></td></tr></table></figure></p>
<p>constructor(<br>  @Host() @Optional() private toggleDirective: ToggleDirective,<br>) {}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">值得注意的有两点：</div><div class="line">* ``@Host()``：这个装饰器的作用是，可以限制从属于当前指令的DI注入器，仅注入**绑定到某个满足特定条件指定或者组件上的**``toggle``指令实例，而不是从它的祖先组件们中注入。（这里选择器为空，则为宿主对象）</div><div class="line">* ``@Optional()``：这个装饰器会告诉编译器，当注入器没有找到任何可注入的``toggle``指令时，不要抛出错误（如果我们手动的指定某个引用），这样在它无法被注入时，使它保持``undefined``即可。</div><div class="line"></div><div class="line">现在我们可以很容易的理解在``ngOnChanges``生命周期钩子函数中的代码的作用，</div></pre></td></tr></table></figure></p>
<p>this.toggle = this.withToggle || this.toggleDirective;<br>```</p>
<ul>
<li>如果我们的<code>@Input()</code>被指定，那么使用它的值</li>
<li>如果没有，则尝试去使用在当前宿主对象上注入的<code>toggle</code>指令实例</li>
<li>如果没有，则使用<code>undefined</code></li>
</ul>
<p>当前的<code>this</code>指定<code>withToggle</code>本身，所以拥有它引用的子组件都可以访问它。</p>
<iframe src="https://stackblitz.com/edit/adv-ng-patterns-03b-enhance-with-directives" width="800" height="600" frameborder="0" allowfullscreen></iframe>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>在这一节中，主要进行了以下几方面的改进：</p>
<ul>
<li>简化<code>toggle</code>本身，因为它一直是作为一个容器组件使用的，所以完全可以以指令（可以理解为没有模板的组件）的形式存在</li>
<li>依赖注入（DI）的机制虽然很强大，但是受限于它的运作原理（关于具体的运作原理可以参考<a href="https://angular.cn/guide/dependency-injection" target="_blank" rel="external">官方文档</a>）。这里原作者使用一个额外的<code>withToggle</code>指令作为中间件，来作为<code>toggle</code>指令的托管容器。这部分理解起来可能需要先了解一下视图变量和<code>exportAs</code>的相关的知识</li>
<li>对于<code>toggle</code>指令实例的获取逻辑，采用平稳退化的策略，就好比人在实际生活中思考问题的方式一样。</li>
</ul>
<p>这种开发模式，在实际工作中，我有一次在重构公司项目中一个关于表单组件的过程中曾使用过，之所以使用这种方式，是因为在表单组件中，会存在一些关于联动校验或者分组的需求，如果将这部门逻辑封装为<code>service</code>或者直接写在<code>controller</code>内部，越到后面会发现逻辑复杂度越高，从而越来越难维护。</p>
<p>使用这种模式，将复杂的逻辑划分成小的颗粒，再封装为独立的指令，在需要用到这些逻辑的组件中注入这些指令即可，指令的特点就是一般都会比较简洁，只会做一些简单的事情，相比之下，维护一个十分复杂的service和维护若干简单的指令，我更倾向于后者。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;03-b-Enhance-Components-with-Directives&quot;&gt;&lt;a href=&quot;#03-b-Enhance-Components-with-Directives&quot; class=&quot;headerlink&quot; title=&quot;03-b Enhance C
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="ngx" scheme="http://yoursite.com/tags/ngx/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>高级 Angular 组件模式 (3a)</title>
    <link href="http://yoursite.com/2018/01/10/aacp-3a/"/>
    <id>http://yoursite.com/2018/01/10/aacp-3a/</id>
    <published>2018-01-10T14:02:45.000Z</published>
    <updated>2018-01-10T14:02:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="03-a-Communicate-Between-Components-Using-Dependency-Injection"><a href="#03-a-Communicate-Between-Components-Using-Dependency-Injection" class="headerlink" title="03-a Communicate Between Components Using Dependency Injection"></a>03-a Communicate Between Components Using Dependency Injection</h2><blockquote>
<p>原文: <a href="https://blog.angularindepth.com/communicate-between-components-using-dependency-injection-d7280567faa7" target="_blank" rel="external">Communicate Between Components Using Dependency Injection</a></p>
</blockquote>
<p>当前的<code>&lt;toggle&gt;</code>组件仍然存在其他的问题，比如：</p>
<ul>
<li>我们无法在其中方式多个<code>&lt;toggle-on&gt;</code>或者是<code>&lt;toggle-button&gt;</code>在同一个<code>&lt;toggle&gt;</code>中</li>
<li>如果一个<code>&lt;toggle-on&gt;</code>作为另外一个自定义组件的内容的话，我们无法是使用<code>@ContentChild</code>装饰器获取它</li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>我们需要将这两个问题作为新的目标：</p>
<ul>
<li>我们可以增加多个相同类型的子组件(<code>&lt;toggle-on&gt;</code>、<code>&lt;toggle-off&gt;</code>、<code>&lt;toggle-button&gt;</code>)</li>
<li>并且可以使这些子组件放置在任意的自定义容器的视图模板(<code>views</code>)中</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>针对第一个问题，我们使用<code>@ContentChildren</code>装饰器（因为它获取所有的子组件引用），但是它无法解决第二个问题。</p>
<p>为了同时解决这两个问题，我们可以使用Angular提供的DI机制(<code>dependency injection mechanism</code>)。你可以将一个组件的祖先组件通过DI机制注入到子组件的构造方法中，这样你就可以通过祖先组件的引用来访问它们的方法和属性。</p>
<p>所以，<code>&lt;toggle-on&gt;</code>、<code>&lt;toggle-off&gt;</code>、<code>&lt;toggle-button&gt;</code>都可以通过DI机制来获得最相近的<code>&lt;toggle&gt;</code>组件的引用，从而共享它的开关状态。</p>
<blockquote>
<p>Note:<br>这里也可以使用<code>service</code>来共享状态，也许还会更便捷，但是我们可以通过DI来达到目的，我们可以在之后的章节（第十二章）来阐述<code>service</code>相关的内容，这部分内容会与<code>React Context Provider</code>的内容对应。</p>
</blockquote>
<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>你可以在在线代码仓库看到，有两个<code>&lt;toggle-off&gt;</code>组件如我们预期的那样被渲染，并且有一个<code>&lt;other-component&gt;</code>组件，其中有<code>&lt;toggle-off&gt;</code>和<code>&lt;toggle-on&gt;</code>两个组件。</p>
<p>这些子组件都会监听同一个<code>&lt;toggle&gt;</code>组件的开关状态。</p>
<iframe src="https://stackblitz.com/edit/adv-ng-patterns-03a-compound-comp-inject-parent" width="800" height="600" frameborder="0" allowfullscreen></iframe>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>依赖注入是Angular中提供的很强大的功能，在<code>angularjs</code>中就表现出色并作为卖点。</p>
<p>如果仔细思考的话，我们可以发现，在这一版的实现中，对于<code>&lt;toggle&gt;</code>组件的引用获取方式，从命令式转变为了声明式，因为我们不再关心获取<code>&lt;toggle&gt;</code>引用的细节（比如具体使用<code>@ContentChild</code>还是<code>@ContentChildren</code>）。</p>
<p>同时，依赖注入机制是依附于组件本身存在的，并不依附于模板的层级关系，因此不会面临问题二的困扰。</p>
<p>对于木偶组件本身，往往作为消费者存在，这种情况下使用DI机制可能会达到更好的效果。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;03-a-Communicate-Between-Components-Using-Dependency-Injection&quot;&gt;&lt;a href=&quot;#03-a-Communicate-Between-Components-Using-Dependency-Injec
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="ngx" scheme="http://yoursite.com/tags/ngx/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>高级 Angular 组件模式 (2)</title>
    <link href="http://yoursite.com/2018/01/10/aacp-2/"/>
    <id>http://yoursite.com/2018/01/10/aacp-2/</id>
    <published>2018-01-10T13:05:59.000Z</published>
    <updated>2018-01-10T13:13:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="02-Write-Compound-Components"><a href="#02-Write-Compound-Components" class="headerlink" title="02 Write Compound Components"></a>02 Write Compound Components</h2><blockquote>
<p>原文: <a href="https://blog.angularindepth.com/write-compound-components-1001449c67f0" target="_blank" rel="external">Write Compound Components</a></p>
</blockquote>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>我们需要实现的需求是能够使使用者通过<code>&lt;toggle&gt;</code>组件动态的改变包含在它内部的内容。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们可以把toggle抽象为一个复合组件，由三个新的组件<code>&lt;toggle-button&gt;</code>、<code>&lt;toggle-on&gt;</code>、<code>&lt;toggle-off&gt;</code>构成。</p>
<p>每一个组件的职能与它们的父组件保持一致，它们各自的职能如下：</p>
<ul>
<li><code>toggle-button</code>: 代表开关，用来渲染父组件的开关状态</li>
<li><code>toggle-on</code>: 根据父组件的开关状态，渲染当状态为<strong>开</strong>时的内容</li>
<li><code>toggle-off</code>: 根据父组件的开关状态，渲染当状态为<strong>关</strong>时的内容</li>
</ul>
<p><code>&lt;toggle&gt;</code>组件可以实现<code>@ContentChild</code>装饰器获取这三个子组件的引用，从而可以根据开关状态的变化调整它们之间的关联逻辑。</p>
<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>经过这样的调整，我们可以使用户通过使用<code>&lt;toggle&gt;</code>组件去自定义包含在它其中内容的显示逻辑，内容中会有一个按钮负责切换开关的状态。可以尝试在在线代码库中调整子组件的顺序，你可以在它们中间嵌套任何的<code>html</code>字符串，只要这三个组件是作为<code>&lt;toggle&gt;</code>的子组件存在的，一切都将正常的运行。</p>
<h2 id="相关话题"><a href="#相关话题" class="headerlink" title="相关话题"></a>相关话题</h2><ul>
<li><p><code>@ContentChild</code>装饰器将会返回在组件标签包含的内容中，第一个符合选择器的子组件或者子指令的引用，比如<code>&lt;toggle&gt; This is the content &lt;/toggle&gt;</code>。如果想获取所有的子组件或者子指令，使用<code>@ContentChildren</code>。</p>
</li>
<li><p><code>@ViewChild</code>或者<code>@ViewChildren</code>装饰器是用来获取在组件内部模板中使用的单个或者多个组件的。比如<code>template: &#39;This is the view&#39;</code>或者<code>templateUrl: &#39;./my.component.html&#39;</code></p>
</li>
</ul>
<iframe src="https://stackblitz.com/edit/adv-ng-patterns-02-compound-components" width="800" height="600" frameborder="0" allowfullscreen></iframe>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>这里组件架构方式是标准的<code>Smart Component（智能组件）</code>和<code>Dump Component（木偶组件）</code>组件架构方式。</p>
<p>以上的需求完全是可以在<code>&lt;toggle&gt;</code>内部实现的，但是这样会使它的内部充满逻辑代码，反之我们可以将一些职能划分为成更小的碎片，并委托到它的子组件中，本身作为容器组件存在，负责协作子组件从而达到目的。</p>
<p>对于<code>@ContentChild</code>和<code>@ViewChild</code>的使用场景，我认为通过看装饰器前缀的寓意是最后的方式。</p>
<ul>
<li><code>Content</code>代表内容，这些内容在组件渲染时已经存在于组件声明标签的内部，通常在组件内部以<code>&lt;ng-content&gt;</code>为占位符</li>
<li><code>View</code>代表视图，视图代表组件本身的模板，代表组件本身的渲染逻辑</li>
</ul>
<p><code>@ContentChildren</code>和<code>@ViewChildren</code>同理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;02-Write-Compound-Components&quot;&gt;&lt;a href=&quot;#02-Write-Compound-Components&quot; class=&quot;headerlink&quot; title=&quot;02 Write Compound Components&quot;&gt;&lt;/a&gt;02
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="ngx" scheme="http://yoursite.com/tags/ngx/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>高级 Angular 组件模式 (1)</title>
    <link href="http://yoursite.com/2018/01/10/aacp-1/"/>
    <id>http://yoursite.com/2018/01/10/aacp-1/</id>
    <published>2018-01-10T09:21:19.000Z</published>
    <updated>2018-01-11T01:29:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前头"><a href="#写在前头" class="headerlink" title="写在前头"></a>写在前头</h2><p>Angular到现在已经到5.x的版本了，对于MVVM框架我首先接触的是angularjs后来又转为react，之后换了工作因项目技术栈的原因又转换到之前的angularjs，在实际工作中实施了公司几个比较重要项目中前端的重构工作，这个过程逐步意识到，对于MVVM框架本身，在使用层面讲，掌握一些通用的模式是很有必要的，尤其现在已经很流行的组件化开发。这样我们在实际工作中就可以无缝（或者花很少的时间成本）转化到任何的MVVM框架，并把节省下来的时间去学习新的知识。</p>
<p>最近一直在关注<code>Angular In Depth</code>的博客，偶尔看到这个系列的文章，觉的质量还挺高，所以抽空余时间翻译并分享给大家，并在每个文章后面加了一点自己的拙见，希望可以达到抛砖引玉的效果，如果观点有误，还望各位看官轻喷。</p>
<h2 id="01-Build-a-Toggle-Component"><a href="#01-Build-a-Toggle-Component" class="headerlink" title="01 Build a Toggle Component"></a>01 Build a Toggle Component</h2><blockquote>
<p>原文: <a href="https://blog.angularindepth.com/build-a-toggle-component-6e8f44889c2c" target="_blank" rel="external">Build a Toggle Component</a></p>
</blockquote>
<p>如<a href="https://egghead.io/lessons/react-introducing-advanced-react-component-patterns" target="_blank" rel="external">Kent C. Dodds Advanced React Component Patterns</a>那样，我们将使用一个相对简单的<code>&lt;toggle&gt;</code>组件来说明这些模式。<code>&lt;toggole&gt;</code>组件的职责是仅仅是管理一个简单的布尔值状态属性: <code>on</code>。使用如此简单的组件进行说明的目的，是因为我们可以将更多的注意力投入到相对组件本身而言较复杂的模式中。</p>
<p>经过这一系列文章，我将提供包含完整功能的、可运行的演示代码链接。你仅仅需要将注意力集中到<code>app</code>文件夹和<code>toggle</code>文件夹。<code>toggle</code>文件夹包含一些可复用的库（一系列组件），当然这个库会随着文章的深入而改变。<code>app</code>文件夹并且特别是<code>app.component.html</code>，将针对库在不同的情形下的使用做出相应的改变。</p>
<p>我们将从最原始的<code>toggle</code>组件版本开始。它仅仅有一个使用了<code>@Input()</code>装饰器的<code>on</code>属性，这个属性所控制的状态代表组件本身的开关状态，同时它还有一个是使用了<code>@Output()</code>装饰器的<code>toggle</code>事件发射器，这个事件发射器会在组件开关状态改变的情况下，通知父组件。</p>
<p>在我们开始下一个话题<a href="http://littlelyon.com/2018/01/10/aacp-2/" target="_blank" rel="external">02 Write Compound Components</a>之前，可以在<a href="https://stackblitz.com/edit/adv-ng-patterns-01-build-toggle-component" target="_blank" rel="external">在线代码仓库</a>看看这个组件的实现以及演示。</p>
<iframe src="https://stackblitz.com/edit/adv-ng-patterns-01-build-toggle-component" width="800" height="600" frameborder="0" allowfullscreen></iframe>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p><code>toggle</code>组件的实现是一个很典型的利用单向数据流作为数据源的简单组件：</p>
<ul>
<li><code>on</code>是单向数据源，同时代表组件内部的开关状态</li>
<li><code>toggle`是事件发射器`，以回调的方式将</code>on``状态的变化传递给父组件</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前头&quot;&gt;&lt;a href=&quot;#写在前头&quot; class=&quot;headerlink&quot; title=&quot;写在前头&quot;&gt;&lt;/a&gt;写在前头&lt;/h2&gt;&lt;p&gt;Angular到现在已经到5.x的版本了，对于MVVM框架我首先接触的是angularjs后来又转为react，之后换了工作
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="ngx" scheme="http://yoursite.com/tags/ngx/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>多维数组取值问题</title>
    <link href="http://yoursite.com/2017/12/18/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%8F%96%E5%80%BC%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/12/18/多维数组取值问题/</id>
    <published>2017-12-18T07:56:47.000Z</published>
    <updated>2017-12-18T07:56:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h2><p>给予一个多维数组和一个描述取值路径的一维数组, 通过调用函数<code>f</code>返回取值路径描述的值，如<br><code>f([[1, 2], [3, 4], [5, 6]], [0, 0]) -&gt; 1</code></p>
<p><a href="https://www.codewars.com/kata/multidimensional-array/train/javascript" target="_blank" rel="external">原问题传送门</a></p>
<p>之所以想记录一下是因为之前有在<code>codewars</code>刷题的习惯，后来工作忙就怠慢了，今天闲来无事就准备刷几道玩玩，然后就挑了一个比较简单的<code>7kyu</code>（<code>codewars</code>中的难度评级）的题。</p>
<p>因为这题比较简单，我也没多想，上来就干，仔细想了下，很容易嘛，不就是递归吗？按大学老师教的来一套：</p>
<ul>
<li>先找递归退出的条件，<code>当路径取到最后</code>或者<code>目标数组已经取尽</code>（这里似乎题目没有说清楚，暂定不对取值路径做限定吧）</li>
<li>再找递归的模式, <code>如果不满足递归退出的条件，则将目标数组缩小一维，传递新的取值路径并递归</code></li>
</ul>
<p>然后就有了第一版代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function getElement(array, indexes) &#123;</div><div class="line">  const idx = indexes.shift()</div><div class="line">  </div><div class="line">  if(indexes.length === 0 || array[idx].constructor !== Array ) return array[idx]</div><div class="line">  else return getElement(array[idx], indexes)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后跑了跑作者提供的简单测试用例，<code>all passed</code>，我就说嘛，这么简单的题目不一把过岂不是有点丢脸，然后就直接点了提交，然后就蹦了一大片的<code>failed</code>测试用例出来，仔细看了看失败的测试用例，并没有看懂，因为都是很多莫名奇妙的数据，并且每次返回的结果都不一致（后来才知道是随机的用例）。</p>
<p>之后一直以为是自己有一些边界情况没有考虑到，就前前后后又看了几次自己的答案，并没有发现什么大的问题，但是无论怎么提交都是失败。之后前前后后大概看了15分钟左右，突然就觉得是我自己把问题想简单了。</p>
<p>因为最近一直在看函数式的东西，突然就联想到，自己写的这个函数，并不<code>纯</code>。关于纯函数是函数式编程中最基本的概念之一，所谓纯既是要求函数没有副作用，我这里的<code>getElement</code>使用了<code>Array.shift</code>方法，会对原数组进行修改，从而产生副作用。这么一想一下就和之前每次跑用例总是产生意想不到的结果的情况联系上了，随机用例的失败原因一定是因为测试路径会有很多个，但是测试目标数组只有一个，因此有副作用的话，只有第一次测试的结果是正确的，后面都会因副作用产生不同的结果。</p>
<p>既然是因为数组是<code>引用类型</code>而产生的问题，那么直接来一个<code>深拷贝</code>就可以了。因为这里只是答题，所以使用一个最简单粗暴的深拷贝大法<code>x =&gt; JSON.parse(JSON.stringify(x))</code>，然后代码就有了第二版代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function getElement(array, indexes) &#123;</div><div class="line">  array = JSON.parse(JSON.stringify(array))</div><div class="line">  indexes = JSON.parse(JSON.stringify(indexes))</div><div class="line">  </div><div class="line">  const idx = indexes.shift()</div><div class="line">  </div><div class="line">  if(indexes.length === 0 || array[idx].constructor !== Array ) return array[idx]</div><div class="line">  else return getElement(array[idx], indexes)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之后提交，所有的用例都通过了。但是还没有结束，因为自己的代码在实现上还是挺啰嗦的，同时还使用了深拷贝大法，有没有更简单的方法呢？</p>
<p>有的。如果仔细思考一下，这里的解题的思路其实和<code>Array.reduce</code>的模式很像</p>
<ul>
<li>对一个数组进行遍历（对路径数组进行遍历）</li>
<li>每次遍历返回一个值，并作为参数传入下一次遍历（对目标函数的降维）</li>
<li>在遍历完成后，返回一个结果（取值路径对应的值）</li>
</ul>
<p>因此利用<code>Array.reduce</code>，这个问题一行代码就可以解决，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function getElement(array, indexes) &#123;</div><div class="line">  return indexes.reduce((a, i) =&gt; a[i], array);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样多考虑一下，它是<code>纯函数</code>吗？是的，它是纯的。因为这里只做了取值的操作（<code>a[i]</code>），并不涉及任何的修改原数组的操作。这个答案也是在我提交后，所有答案中实现方案最好的一个。</p>
<p>当然还有其他的暴力破解法，我觉的想法也不错，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function getElement(array, indexes) &#123;</div><div class="line">  return eval(`array[$&#123;indexes.join(&quot;][&quot;)&#125;]`);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还有利用<code>spread</code>运算符的方法，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const getElement = (array,[index,...moreIndices]) =&gt; moreIndices.length ? getElement( array[index], moreIndices ) : array[index]</div></pre></td></tr></table></figure></p>
<p>所以工作累了，或者闲来无事，刷刷题还是挺有意思的，可以看见一些自己平时很熟悉但是在需要用时又难以想起的知识。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题简述&quot;&gt;&lt;a href=&quot;#问题简述&quot; class=&quot;headerlink&quot; title=&quot;问题简述&quot;&gt;&lt;/a&gt;问题简述&lt;/h2&gt;&lt;p&gt;给予一个多维数组和一个描述取值路径的一维数组, 通过调用函数&lt;code&gt;f&lt;/code&gt;返回取值路径描述的值，如&lt;br&gt;&lt;c
    
    </summary>
    
    
      <category term="kata" scheme="http://yoursite.com/tags/kata/"/>
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>从ng1看ng2 关于NgModule的简易归纳</title>
    <link href="http://yoursite.com/2017/07/21/ng2-%E5%85%B3%E4%BA%8ENgModule%E7%9A%84%E7%AE%80%E6%98%93%E5%BD%92%E7%BA%B3/"/>
    <id>http://yoursite.com/2017/07/21/ng2-关于NgModule的简易归纳/</id>
    <published>2017-07-21T07:16:35.000Z</published>
    <updated>2017-07-21T08:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近开始折腾<a href="https://angular.io/" target="_blank" rel="external">ng2</a>，其实说是ng2，到目前为止，它已经发布了4.3版，就是这么的高产，高产似<em>*，我连2都还木有完整的看完它竟然发布了4.</em>的版本（鄙视脸）。</p>
<p>不过话说回来，之前工作不忙的时候，想看看ng2的东西，我的天，又是ts，又是observable的，吓的我硬是没有上来就直接去看它的入门文档，而是买了本typescript的入门开始看，后来书看了一半，工作又忙了，就想着可否重构历史代码加顺带学习rxjs的姿势去做需求，后来我也是这么做的，庆幸的是，这么做效果是挺好的，不仅实际开发效率高了不少，同时也入门了rxjs。</p>
<p>最近工作又闲了下来，就想着赶紧带着半吊子的ts和rxjs水平看看ng2的文档吧，虽然ng2在国内似乎热度不如react和vue流行，但是在全世界还是劲头还是比较强劲的，毕竟有谷歌爸爸和微软爸爸做东，强强联合。</p>
<p>而且我是个遵守规则的人，一向喜欢大而全的东西，ng这种框架我觉的真的是很对我的胃口。不过这ng2的文档不看不要紧，一看真的是有些蛋疼，随便看个啥，连码代码加理解，估计一下午也就能看一个简单的概念，就比如今天想归纳的<code>NgModule</code>这部分东西，前后大概有30几页的东西，所以我觉的如果不写点东西总结一下，必然是看了就忘，忘了再看的节奏。</p>
<h2 id="ng1中的module回顾"><a href="#ng1中的module回顾" class="headerlink" title="ng1中的module回顾"></a>ng1中的module回顾</h2><p>其实熟悉ng1的话，对于这ng2中的module的理解是很有帮助的。从ng1开始，就一直再提倡一个module的概念，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">angular.module(&apos;baz&apos;, [])</div><div class="line">angular.module(&apos;bar&apos;, [])</div><div class="line">angular.module(&apos;foo&apos;, [&apos;bar&apos;, &apos;baz&apos;])</div><div class="line">       .factory(&apos;fooFactory&apos;, function()&#123; ... &#125;)</div><div class="line">       .service(&apos;fooService&apos;, function()&#123; ... &#125;)</div><div class="line">       .component(&apos;fooComponent1&apos;, &#123; ... &#125;)</div><div class="line">       .directive(&apos;fooDirective&apos;, function()&#123; ... &#125;)</div></pre></td></tr></table></figure></p>
<p>这么的我就分别声明了<code>foo</code>、<code>bar</code>和<code>baz</code>的module，同时<code>foo</code>依赖于<code>baz</code>和<code>bar</code>，然后就没有然后了，之后你就可以在这个这些module中做一切你想做的任何事情。通过这种module的划分，我们可以在各个维度中，抽象我们的代码，比如从业务上、从代码类别上等等。</p>
<h2 id="ng2中的module简述"><a href="#ng2中的module简述" class="headerlink" title="ng2中的module简述"></a>ng2中的module简述</h2><p>ng2将这种概念更推进了一步，虽然我们可以使用module的方法来改变我们编程的思维，但是代码本身并不具有module的含义，这么说可能有点难理解，举个例子，就上面的例子，对于<code>bar</code>和<code>baz</code>模块，我们很难简单的从代码层面来区分它们分别的职能是什么。因此ng2改用了以<a href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841#.x5c2ndtx0" target="_blank" rel="external">Decorator</a>的方式来使代码具有语意性，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@NgModule(&#123;</div><div class="line">  imports:      [ ... ],</div><div class="line">  declarations: [ ... ],</div><div class="line">  providers:    [ ... ],</div><div class="line">  exports:      [ ... ]</div><div class="line">&#125;)</div><div class="line">export class FooModule &#123; &#125;</div></pre></td></tr></table></figure></p>
<p>通过<code>NgModule</code>这个装饰器来对一个class进行描述。如果直接和ng1对比的话，装饰器的参数对象中的几个属性分别对应ng1中的：</p>
<ul>
<li><code>imports</code>: 对应ng1声明中的模块依赖数组<code>[&#39;bar&#39;, &#39;baz&#39;]</code>，进行一些依赖模块的声明</li>
<li><code>declarations</code>: 对应ng1中的<code>.component(&#39;fooComponent1&#39;, { ... })</code>和<code>.directive(&#39;fooDirective&#39;, function(){ ... })</code>，进行一些声明式类的声明</li>
<li><code>providers</code>: 对应ng1中的<code>.service(&#39;fooService&#39;, function(){ ... })</code>和<code>.factory(&#39;fooFactory&#39;, function(){ ... })</code>，进行一些服务类的声明</li>
<li><code>exports</code>: ng1中没有独立的exports语法，因此不做对比，在ng1中只有依赖模块中提供的服务、模块，加载模块均可使用。</li>
</ul>
<h2 id="ng2中module分类"><a href="#ng2中module分类" class="headerlink" title="ng2中module分类"></a>ng2中module分类</h2><p>ng2对不同的module提供了不同的语意性描述方式，可以通过装饰器属性来描述它们。</p>
<h3 id="root-module（根模块）"><a href="#root-module（根模块）" class="headerlink" title="root-module（根模块）"></a>root-module（根模块）</h3><p>所谓根模块，即一个应用的最上层的模块，即应用的入口模块，有时候也会称作app-module（这也是文档中指出的最佳实践）。这个概念在ng1中同样有，但是和上面指出的问题一样，就是没有代码层面的语意性描述，为了更好的描述它，ng2中的root-module会提供额外的装饰器属性来修饰它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@NgModule(&#123;</div><div class="line">  ...,</div><div class="line">  bootstrap:      [ ... ]</div><div class="line">&#125;)</div><div class="line">export class AppModule &#123; &#125;</div></pre></td></tr></table></figure></p>
<p>这个<code>bootstrap</code>代表这个模块会在应用初始化阶段被引导和加载，一般来讲，ng2都会有一个独立的<code>main.ts</code>文件来引导加载根模块，这个过程对于根模块是透明的，因为它并不知道它如何被加载，有可能是在浏览器加载，有可能是在移动端加载等等，有可能使用JIT做动态加载，有可能提前编译好做静态加载，这些都是未知的，它仅仅需要表达的是，这个模块是可被引导加载的。通常情况下，一个应用只有一个root-module（这不是废话吗），但是在一些大型的应用中，可能会存在多个独立的子项目，那么就有可能存在多个root-module。</p>
<h3 id="sub-module（子模块）"><a href="#sub-module（子模块）" class="headerlink" title="sub-module（子模块）"></a>sub-module（子模块）</h3><p>所谓子模块，即一个应用从属于根模块的模块，即应用按各个维度划分形成的颗粒，比如从功能划分、代码架构划分等等，有时候也会称作feature-module（这也是文档中指出的最佳实践），ng1同样无法在代码层面进行语意性描述。</p>
<p>一般来讲，只要符合<strong>ng2中的module简述</strong>中的模块声明方式声明的模块，就是一个feature-module，它具有什么样的feature，完全取决于它提供什么样的声明式组件和服务。对于不同的feature，如服务、指令和组件会以其他的装饰器进行修饰和声明，这不是本篇文章的内容，我们只需要知道，一个feature-module负责声明和管理它提供的服务和声明式组件。值得一提的是，和ng1不同，ng2中的feature-module可以声明一些私有的组件和服务，这一点在ng1中时做不到的。</p>
<h3 id="core-module（核心模块）"><a href="#core-module（核心模块）" class="headerlink" title="core-module（核心模块）"></a>core-module（核心模块）</h3><p>核心模块其实本质上讲，即是feature-module，只不过它提供的声明式组件和服务，是基于app本身构建的。言外之意，就是它必须是单例的，比如像登录验证这种服务，就是一种全局性的、app级别的服务，再入导航、顶部条等组件，也是app级别的组件，这些东西应该归并到core-module中，并在app-module中加载它，而坚决不要在feature-module中加载它。</p>
<h3 id="share-module（共享模块）"><a href="#share-module（共享模块）" class="headerlink" title="share-module（共享模块）"></a>share-module（共享模块）</h3><p>共享模块也是feature-module，只不过它提供的声明式组件和服务，是从各个feature-module中提取出的公共组件和服务，在官方的例子中，高亮这个指令，就是一个公用的指令，并不依赖于任何独立的业务逻辑。这些东西应该归并到share-module中，并在各个feature-module中加载它，从而使得我们的代码尽可能的保持简洁。</p>
<h3 id="lazy-load-module（懒加载模块）"><a href="#lazy-load-module（懒加载模块）" class="headerlink" title="lazy-load-module（懒加载模块）"></a>lazy-load-module（懒加载模块）</h3><p>对于SPA来讲，路由是必不可少的东西。那么对于一些未使用页面所加载的模块，我们没有必要从一开始就加载它们，很自然的，它们就成为了懒加载模块，这些模块本质上讲均是feature-module，因为core-module和share-module从职能来讲，在整个的应用生命周期，尤其初始化必不可少，因此它们很少成为懒加载模块。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;最近开始折腾&lt;a href=&quot;https://angular.io/&quot; target=&quot;_blank&quot; rel=&quot;exte
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="mvvm" scheme="http://yoursite.com/tags/mvvm/"/>
    
      <category term="ng2" scheme="http://yoursite.com/tags/ng2/"/>
    
  </entry>
  
  <entry>
    <title>在 redux 中集成  angular di 机制</title>
    <link href="http://yoursite.com/2017/05/31/%E5%9C%A8-redux-%E4%B8%AD%E9%9B%86%E6%88%90-angular-di-%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/05/31/在-redux-中集成-angular-di-机制/</id>
    <published>2017-05-31T01:29:57.000Z</published>
    <updated>2017-10-12T02:15:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在折腾<code>redux</code>相关的东西，算然说官方鼓励的使用方式是将redux和react一起使用，但并不影响我们在其他的mvvm框架中使用它。</p>
<p>众所周知，angular是一个大而全的框架，想和redux一起使用，需要摒弃一些angular中常用的开发理念与模式，仅仅将它作为一个视图层框架使用，就和react一样，不在将类似<code>domain state</code>和<code>app state</code>的状态维护在controller或service中，而是全权交给redux维护。</p>
<p>我们可以通过使用<a href="https://github.com/angular-redux/ng-redux" target="_blank" rel="external">ng-redux</a>注入redux服务，从而在angular中使用它。</p>
<p>基本的使用项目文档介绍的已经很详细了，这里仅仅想分享在这段时间折腾redux和angular遇到的一个比较蛋疼的问题，以及是如何解决的。</p>
<p>在redux中，业务逻辑的抽象被描述在action中，因此除了一些同步action以外，必然存在类似向后端发送请求获取数据之类的异步action。那么问题来了，在angular中有一个大家很熟悉的机制，叫做依赖注入（简称<code>di</code>），因为这种机制的存在，在angular中，我们一般使用一个服务是不关心它的实例化过程的，我们所做的，仅仅是声明它，告诉模块，我们在运行时，需要注入相关依赖的实例，但是在redux中没有这种机制，对于想在action使用的服务，你必须先导入它，实例化，你才可以使用，这与angular本身的di机制相悖。</p>
<p>那么我们如何来解决这个问题呢？</p>
<p>一种简单粗暴的方法就是，完全摒弃angular的di机制，使用外部的模块来解决问题。比如发请求，难道我们非要使用<code>$http</code>服务吗？我们完全可以直接使用像<code>superagent</code>这样的第三方库来代替它。但是随之而来的问题就是，对于angular已经使用<code>$http</code>服务的代码，你必须考虑是否重构它们，如果不重构，你则会在代码中拥有两套发送请求的逻辑，代码冗余了，如果重构呢，工作量又会很大，没准折腾redux不成，又给全改回去，得不偿失，因此这种方法不是完美的解决方案。最完美的方法应当是，既不摒弃angular的di机制，又可以兼顾redux框架，可是redux没有di机制这怎么破呢？</p>
<p>这个问题费了我不少时间去搜索网上的资料，类似如何在action使用angular di机制，如果在action获取service实例等等，虽然能查到的资料都没有完美的给出解决方案，但是都把问题的解决方向，指向了同一处，即redux的中间件机制。</p>
<p>第二种方法则通过redux中间件的机制来实现<br>什么是中间件机制呢？这个可是个大概念，简单的理解的话，我只引用一个计算机常用的用来调侃的话解释。</p>
<blockquote>
<p>计算机科学中，没有什么问题是不能通过增加一个中间件来解决的。</p>
</blockquote>
<p>话虽然这么说，但是它是很有道理的，对于redux的中间件机制呢，它是对于action来设计的，即一个action，在最终转移到到处理它的reducer之前，会经过若干大大小小的中间件，这些中间件做的事情十分的简单，即输入一个action，按自己的处理逻辑加工它，再交到下一个中间件手中，直到没有下一个中间件为止。</p>
<p>明白了redux的中间件机制，那么上面的问题就好解决了，对于想在action中使用的通过angular di机制来实例化的服务，我们没有必要在action中实例化，我们完全可以仅仅在action中声明，之后呢，将实例化的过程交由中间件处理即可，那么可能你又会问，action没有办法集成di机制，中间件难道能集成吗，如果不能岂不是又回到了问题的原点？是的，但是中间件它的确可以集成di功能，为什么呢，因为中间件的实例化逻辑是通过ng-redux在angular内部进行的，而中间件本身呢，有仅仅是一个函数而已，那么我们完全可以把中间件的实现，声明成一个angular中的factory或者service，之后在其中使用angular的di机制，动态的实例化action中依赖服务的实例，关于这一点呢，在ng-redux的文档中有提及，但是没有说的特别的清楚。</p>
<p>talk is cheap, show me the code. 下面贴一下关于实现解决以上问题的中间件实现源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">import angular from &apos;angular&apos;</div><div class="line">import R from &apos;ramda&apos;</div><div class="line"></div><div class="line">export default function thunkWithDepsMiddleware () &#123;</div><div class="line">  const injector = angular.element(document.body).injector()</div><div class="line"></div><div class="line">  return (&#123;dispatch, getState&#125;) =&gt; next =&gt; action =&gt; &#123;</div><div class="line">    const isNotNil = R.complement(R.isNil)</div><div class="line">    const isFSA = R.both(R.has(&apos;payload&apos;), R.has(&apos;type&apos;))</div><div class="line">    const isLastItemIsFunction = R.compose(R.is(Function), R.last)</div><div class="line">    const isAngularInlineArrayAnnotation = R.both(R.is(Array), isLastItemIsFunction)</div><div class="line">    let annotation</div><div class="line"></div><div class="line">    // FSA 处理逻辑</div><div class="line">    if (isFSA(action)) annotation = R.prop(&apos;payload&apos;, action)</div><div class="line">    // 普通 action 处理逻辑</div><div class="line">    else annotation = action</div><div class="line"></div><div class="line">    if (isAngularInlineArrayAnnotation(annotation)) &#123;</div><div class="line">      const locals = &#123;dispatch: dispatch, getState: getState&#125;</div><div class="line">      const payload = injector.invoke(annotation, this, locals)</div><div class="line">      if (isNotNil(payload)) return dispatch(&#123;...action, payload&#125;)</div><div class="line">    &#125; else if (R.is(Function, annotation)) &#123;</div><div class="line">      const payload = annotation(dispatch, getState)</div><div class="line">      if (isNotNil(payload)) return dispatch(&#123;...action, payload&#125;)</div><div class="line">    &#125; else &#123;</div><div class="line">      return next(action)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大体逻辑呢，就是通过angular中$injector服务来解决问题，抽离出action中的关于di的声明逻辑，该中间间仅支持<code>inline array annotation</code>语法来声明依赖，对于符合<code>FSA(Flux Standard Action)</code>的action, 如果传入的action中的payload符合该语法，则通过injector.invoke来解析它，如果不是，则简单的按redux-thunk的处理逻辑进行处理，对于一般action同理，只不过是对于它本身进行处理。</p>
<p>实现之后呢，通过ng-redux的语法注册它，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ngReduxProvider.createStoreWith(reducers, [&apos;thunkWithDepsMiddleware&apos;, promiseMiddleware])</div></pre></td></tr></table></figure></p>
<p>之后我们的action即可直接返回符合<code>inline array annotation</code>语法的数组声明依赖，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">export const fetchRoles = createAction(FETCH_ROLES, () =&gt; &#123;</div><div class="line">  return [&apos;$q&apos;, &apos;dispatch&apos;, ($q, dispatch) =&gt; &#123;</div><div class="line">    // do something ...</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直在折腾&lt;code&gt;redux&lt;/code&gt;相关的东西，算然说官方鼓励的使用方式是将redux和react一起使用，但并不影响我们在其他的mvvm框架中使用它。&lt;/p&gt;
&lt;p&gt;众所周知，angular是一个大而全的框架，想和redux一起使用，需要摒弃一些angula
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="angular" scheme="http://yoursite.com/tags/angular/"/>
    
      <category term="redux" scheme="http://yoursite.com/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>es6中的混合器模式</title>
    <link href="http://yoursite.com/2017/04/24/es6%E4%B8%AD%E7%9A%84%E6%B7%B7%E5%90%88%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/04/24/es6中的混合器模式/</id>
    <published>2017-04-24T00:48:12.000Z</published>
    <updated>2017-04-24T01:59:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是有关设计模式相关的第一篇文章，谈及设计模式，一般情况下呢，很多人马上就会说出很多关于它的东西，比如单例模式、策略模式等等。对于各个技术栈的工程师们，各种设计模式应该再熟悉不过，这篇文章要分享的是关于前端中的混合器模式，也可以称作装饰器模式，并分享一些在实际开发中的应用。</p>
<p>在面向对象的开发中，实际业务的描述是通过<code>类(Class)</code>来进行描述的，如果想给一个已经存在的类扩展某些行为（如增加某个方法、某个属性等），可以通过<code>类的继承</code>来实现，即将可复用、可扩展的方法抽象为父类中的方法之后继承它。</p>
<p>但是思考一下，这种做法的弊端：</p>
<ul>
<li>类的继承所扩展的方法或属性是静态的，既你无法为一个已有的类的实例扩展某些方法。</li>
<li>类的继承会继承父类中的所有可继承的方法和属性，但是你只想继承其中的某个或某几个方法。</li>
</ul>
<p>在es6中，加入了<code>装饰器(Decorator)</code>语法，提供了对于装饰器模式的原生支持。这里对于语法不再进行详细的阐述，可以点击<a href="http://es6.ruanyifeng.com/#docs/decorator#类的修饰" target="_blank" rel="external">这里</a>进行了解或学习。</p>
<p>在这种模式下，我们可以动态的来为一个类增加某个方法或属性，你可能会问，这样听起来似乎和继承没什么不同？你错了，它的优势体现在<code>动态</code>二字，其含义即为可以动态的为类的实例增加某种行为，也许你又会说，在js中，它本身就是动态语言，这种动态性也失去了优势了吧。</p>
<p>是的，但是在js中想要实现继承绝非易事，因为它的继承机制是通过原型链进行描述的，对于js新手的话，理解起来其实是有点晦涩的，有些时候我们仅仅想通过更清晰的手段使用另一个类中的某些方法。</p>
<p>举个例子，在SPA开发中，经常会遇到处理分页数据的需求，对于分页逻辑的处理，很显然是一块需要抽象为公共方法的逻辑，但是如果你按继承的角度去考虑，就会发现，有些时候你继承了这些处理分页逻辑的方法反而是多余了，因为并不是每个页面都需要分页，这种情况下，使用混合器模式来实现则可以更好的解决问题。</p>
<p>我们先来实现一个分页逻辑的混合器，它其实是个函数，函数的参数是一个类，之后会动态的在这个类上增加一些方法，从而达到在<strong>一个类中混入另一个类的某些方法的目的</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">export const PaginationMixin = (superClass) =&gt; class extends superClass &#123;</div><div class="line">  nextPage (url, callback) &#123;</div><div class="line">    this.handlePaginationResolve(url, callback)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  previousPage (url, callback) &#123;</div><div class="line">    this.handlePaginationResolve(url, callback)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  handlePaginationResolve (url, callback) &#123;</div><div class="line">    if (!url) return</div><div class="line"></div><div class="line">    customAPIComposer(url, &apos;get&apos;).then(callback)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之后，只需要按如下进行代码，对需要扩展的类进行扩展，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class AttendanceManageCtrl extends PaginationMixin(MixinBase)</div></pre></td></tr></table></figure></p>
<p>扩展后就可以使用混合器中混入的方法了，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;oa-list-table list-data=&apos;$ctrl.listData&apos; on-next=&apos;$ctrl.nextPage($ctrl.listData.next, $ctrl.render)&apos; on-previous=&apos;$ctrl.previousPage($ctrl.listData.previous, $ctrl.render)&apos;&gt;</div></pre></td></tr></table></figure></p>
<p>这样做似乎和继承没什么区别，但是不妨看看如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class PeopleCtrl extends R.compose(PaginationMixin, StateManageMixin)(MixinBase)</div></pre></td></tr></table></figure></p>
<p>没错，你可以对一个类同时使用多个混合器，但是你却无法使一个类同时继承与多个类，虽然你可以通过多重继承实现，但显然比前者繁琐很多。</p>
<p>尽情混入吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是有关设计模式相关的第一篇文章，谈及设计模式，一般情况下呢，很多人马上就会说出很多关于它的东西，比如单例模式、策略模式等等。对于各个技术栈的工程师们，各种设计模式应该再熟悉不过，这篇文章要分享的是关于前端中的混合器模式，也可以称作装饰器模式，并分享一些在实际开发中的应用。
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>codereview-s8</title>
    <link href="http://yoursite.com/2017/02/07/codereview-s8/"/>
    <id>http://yoursite.com/2017/02/07/codereview-s8/</id>
    <published>2017-02-07T02:02:05.000Z</published>
    <updated>2017-03-14T12:35:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="当元素间存在父子关系时，留意事件冒泡机制所引发的连锁反应"><a href="#当元素间存在父子关系时，留意事件冒泡机制所引发的连锁反应" class="headerlink" title="当元素间存在父子关系时，留意事件冒泡机制所引发的连锁反应"></a>当元素间存在父子关系时，留意事件冒泡机制所引发的连锁反应</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;tr style=&quot;cursor: pointer;&quot; ng-repeat=&quot;row in $ctrl.efficiencyTable.bodyData&quot; ng-click=&quot;$ctrl.stepView(row)&quot;&gt;</div><div class="line">    ...</div><div class="line">    &lt;td class=&quot;text-left&quot;&gt;</div><div class="line">        &lt;a ng-click=&quot;$ctrl.efficiencyView(row)&quot; class=&quot;hover-link&quot;&gt;查看流程&lt;/a&gt;</div><div class="line">    &lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>a元素的点击事件会<code>efficiencyView</code>方法，但因为事件冒泡机制，也会间接的调用<code>stepView</code>方法</p>
</blockquote>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><blockquote>
<p>angular中可以使用内置的 $event 对象来解决相应问题</p>
</blockquote>
<p>首先声明使用<code>$event</code>对象并传参<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a ng-click=&quot;$ctrl.efficiencyView(row, $event)&quot; class=&quot;hover-link&quot;&gt;查看流程&lt;/a&gt;</div></pre></td></tr></table></figure></p>
<p>之后再<code>efficiencyView</code>方法中调用<code>stopPropagation</code>方法阻止事件冒泡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">efficiencyView (workflow, $event) &#123;</div><div class="line">    ...</div><div class="line">    $event.stopPropagation()</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>也可以对比<code>$event</code>对象中的<code>target</code>和<code>currentTarget</code>属性是否相同，因为这两个属性分别代表触发事件的dom节点与响应事件的当前节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if($event.target === $event.currentTarget) ...</div></pre></td></tr></table></figure></p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="external">EventTarget.addEventListener 方法及其参数的含义</a></li>
<li><a href="http://blog.csdn.net/luanlouis/article/details/23927347" target="_blank" rel="external">解析Javascript事件冒泡机制</a></li>
</ul>
<h2 id="z-index-常见问题"><a href="#z-index-常见问题" class="headerlink" title="z-index 常见问题"></a>z-index 常见问题</h2><p>关于<code>z-index</code>本身用法我是了解的，但是最近在做下拉框组件和datepicker时，踩了一些坑，如下：</p>
<ul>
<li>只有设置了<code>position</code>属性的元素的<code>z-index</code>才会生效</li>
<li>当父容器的<code>z-index</code>小于元素A时，其子容器的<code>z-index</code>无论多大都无法覆盖元素A</li>
</ul>
<h3 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>实现具有下拉菜单展开特效的组件时，一般会套用一下结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;dropdown-wrapper&quot;&gt;</div><div class="line">    &lt;div class=&quot;dropdown-toggle&quot;&gt;</div><div class="line">        ...</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;div class=&quot;dropdown-list&quot;&gt;</div><div class="line">        ...</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>当两个下拉菜单处于垂直布局时，如果没有设置<code>z-index</code>属性，因为<code>dropdown-toggle</code>比<code>dropdown-list</code>先出现，因此默认的图层顺序是前者高于后者，所以当上面的下拉菜单出现的时候，并不会覆盖下面的<code>toggle</code>,为了解决这个问题，必须做如下处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.dropdown-list&#123;</div><div class="line">    ...</div><div class="line">    z-index: 1000;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后附上<a href="https://jsbin.com/suyojovino/edit?html,css,output" target="_blank" rel="external">DEMO</a></p>
<h3 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><a href="https://css-tricks.com/almanac/properties/z/z-index/" target="_blank" rel="external">z-index</a></li>
</ul>
<h2 id="对表格中的单元格增加一个hover高亮效果"><a href="#对表格中的单元格增加一个hover高亮效果" class="headerlink" title="对表格中的单元格增加一个hover高亮效果"></a>对表格中的单元格增加一个hover高亮效果</h2><p>对于表格中<code>td</code>增加<code>hover</code>高亮时可能会遇到一个问题，就是当你使用常规的<code>border</code>属性对边框进行设置时，可能会发现，每个单元格的上边框和左边框都没有达到理想的效果，但是下边框和右边框却是正常的。<br>这种问题会出现在对<code>table</code>增加<code>border-collapse: collapse</code>属性或是引用一些第三方的css库，比如bootstrap，具体现象参考<a href="https://jsbin.com/hivukumosu/edit?html,css,output" target="_blank" rel="external">DEMO</a>。</p>
<h3 id="最佳实践-2"><a href="#最佳实践-2" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>解决方法其实很简单，就是将<code>td</code>边框的样式从<code>solid</code>改为<code>double</code>，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">table tr td &#123;</div><div class="line">    border-style: double;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原因如下：</p>
<blockquote>
<p>Since double is “more distinct” then solid, its colour takes precedence over cells around it, and looks identical to solid anyway ;)</p>
</blockquote>
<h3 id="扩展-2"><a href="#扩展-2" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-style" target="_blank" rel="external">border-style各属性值及赋值语法</a></li>
</ul>
<h2 id="angular中遭遇的一个奇葩问题"><a href="#angular中遭遇的一个奇葩问题" class="headerlink" title="angular中遭遇的一个奇葩问题"></a>angular中遭遇的一个奇葩<a href="https://github.com/angular/angular.js/issues/4558" target="_blank" rel="external">问题</a></h2><p>这个问题是我在本期开发排班器组件时遇到的一个很奇葩的问题，大体描述就是如上面github链接中描述的一样，就是当父组件的一个数据采用双向绑定时，并且需要已事件回调的方法更新其内部的某个属性值，然后使用签名为<code>onChange</code>的<code>scope</code>属性传给子组件，比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scope:&#123;</div><div class="line">    ...</div><div class="line">    onChange: &apos;&amp;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么这个<code>onChange</code>的调用在父组件进行更新某条以双向绑定方式进行绑定的属性时，会先于子组件的更新前自动调用，这么说有点抽象，大体的问题我简单描述下。</p>
<p>本来<code>onChange</code>的调用时机应当是自下而上的，也就是当子组件发生更新时，调用父组件通过<code>onChange</code>属性传递的事件回调方法，这个方法会更具子组件的当前状态来对父组件进行更新，这就是理想中的单向数据流子组件通知父组件进行更新的机制。但是在angular中遇到的奇葩现象现象就是，在父组件进行更新时，不知道是因为签名的缘故还是双向绑定的缘故，这个<code>onChange</code>都会先于子组件运行一次，那么问题来了，这个方法本来的调用时机是子组件更新后需要通知父组件进行相应更新时调用的，然而现在子组件还未更新则先调用了该方法，那么回调函数中的参数必为空，除非<code>onChange</code>中加入了空校验代码，不然就会报错，其实加了空校验也没有什么意义，因为这个方法都会调用的，但是却不会进行任何的改变，相当于浪费了一部分性能。</p>
<h3 id="最佳实践-3"><a href="#最佳实践-3" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>解决方法在<a href="http://plnkr.co/edit/fs7S6yX1a5aeo1Ese522?p=preview" target="_blank" rel="external">这里</a>，这种解决方法算是一种<code>workaround</code>，即在组件中使用另一个对象来储存父组件需要更新的那个值，算是做了一种类似中间件的处理，之后因为双向绑定自动更新机制对于对象的更新时更具<code>reference</code>来进行的，那么在父组件或子组件中对于这一个数据的引用均是相同的，而不会像基本数据类型存在一个新旧值的差异，不过这终究是一个<code>workaround</code>。</p>
<h2 id="限制上传文件的类型"><a href="#限制上传文件的类型" class="headerlink" title="限制上传文件的类型"></a>限制上传文件的类型</h2><p>现在通过<code>type</code>为文件类型的<code>input</code>上传文件已经很普遍了，并且对于表单的校验，通常我们会在提交时进行，文件类型的表单也不例外，一般校验的内容有文件大小、文件类型（扩展名）等等。今天遇到一个需求很有意思，大体意思是想在用户进行文件上传时，就有偏向性的屏蔽掉一些不支持的文件格式，比如上传图片，那么在文件选择对话框就不要出现文本类型的文件。</p>
<p>这个问题我一开始是不知道怎么解决的，因为浏览器对于操作系统是一个沙盒，因此对于文件显示的控制应当没有权限控制，去网上google了下，答案也是这样的，没有方式可以实现百分之百屏蔽某种文件类型的方式。但是却发现了另一个很有意思的属性，也可以达到类型的效果。</p>
<p>这个属性就是<code>input</code>标签的<code>accept</code>属性：</p>
<blockquote>
<p>If the value of the type attribute is file, then this attribute will indicate the types of files that the server accepts, otherwise it will be ignored. The value must be a comma-separated list of unique content type specifiers:</p>
</blockquote>
<p>它可以接受的值的描述：</p>
<ul>
<li>A file extension starting with the STOP character (U+002E). (e.g. .jpg, .png, .doc).</li>
<li>A valid MIME type with no extensions.</li>
<li>audio/* representing sound files. HTML5</li>
<li>video/* representing video files. HTML5</li>
<li>image/* representing image files. HTML5</li>
</ul>
<h3 id="最佳实践-4"><a href="#最佳实践-4" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>比如我们想要限制上传文件类型为excel文件类型，只需要创建如下标签:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;file&quot; accept=&quot;.xls,.xlsx&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>这样这个文件表单对话框被激活时，默认会选取以.xls和.xlsx结尾的文件。</p>
<p>虽然这个属性可以达到类似的效果，但是是无法完全替代对于文件扩展名的校验的。因为只要用户想要上传别的类型的文件，通过切换文件对话框中的选取文件类型选项（比如显示全部文件类型），就可以选取别的类型的文件了，因此在提交时，也别忘了添加校验逻辑，防止因为上传了一些不支持的类型造成服务器内部错误。</p>
<h3 id="扩展-3"><a href="#扩展-3" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input" target="_blank" rel="external">input</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;当元素间存在父子关系时，留意事件冒泡机制所引发的连锁反应&quot;&gt;&lt;a href=&quot;#当元素间存在父子关系时，留意事件冒泡机制所引发的连锁反应&quot; class=&quot;headerlink&quot; title=&quot;当元素间存在父子关系时，留意事件冒泡机制所引发的连锁反应&quot;&gt;&lt;/a&gt;当元
    
    </summary>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>async-for-js</title>
    <link href="http://yoursite.com/2016/11/28/async-for-js/"/>
    <id>http://yoursite.com/2016/11/28/async-for-js/</id>
    <published>2016-11-28T01:16:51.000Z</published>
    <updated>2017-03-08T07:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍关于js开发中所涉及的主流异步编程解决方案</p>
<blockquote>
<p>repo: <a href="https://github.com/haoliangwu/todoMVCs/tree/master/async-for-js" target="_blank" rel="external">async-for-js</a></p>
</blockquote>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>插入3个div元素，其中第二个div元素使用<code>setTimeout</code>模拟异步操作，理想的插入顺序为div1 div2 div3，但这里的代码的插入顺序为div1 div3 div2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// async way</div><div class="line">function _async() &#123;</div><div class="line">  document.body.appendChild(div1)</div><div class="line"></div><div class="line">  setTimeout(function () &#123;</div><div class="line">    document.body.appendChild(div2)</div><div class="line">  &#125;, 2000)</div><div class="line"></div><div class="line">  document.body.appendChild(div3)</div><div class="line">&#125;</div><div class="line"></div><div class="line">_async()</div></pre></td></tr></table></figure></p>
<h2 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h2><p>最常用的方法是利用<code>callback</code>(回调函数)的方式，因为js中函数也是作为对象存在的，因此可以被当做参数传入另一个函数中，只需要在异步操作执行代码后调用回调函数即可。</p>
<p>但是使用回调函数有很明显的局限性，一方面体现在需要自己对异步操作进行控制，另一方面还很容易陷入”回调地狱”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// use plain callback to sync</div><div class="line">function _callback(cb) &#123;</div><div class="line">  document.body.appendChild(div1)</div><div class="line"></div><div class="line">  setTimeout(function () &#123;</div><div class="line">    document.body.appendChild(div2)</div><div class="line">    cb(&apos;done&apos;)</div><div class="line">  &#125;, 2000)</div><div class="line"></div><div class="line">  return &apos;done&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">_callback(function () &#123;</div><div class="line">  document.body.appendChild(div3)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>因为回调地狱的问题，后来聪明的人使用将回调延迟执行的思想，从而发明了promise库，调用者可以根据异步流程随心所欲的resolve或reject某个值给之后的操作，从而解决了毁掉地狱的问题。</p>
<p>不过使用promise仍然有问题，就是当代码逻辑很长的时候，总需要带着大片大片的<code>then</code>方法，可读性仍然不够清晰。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// use promise to sync</div><div class="line">function _promise() &#123;</div><div class="line">  document.body.appendChild(div1)</div><div class="line"></div><div class="line">  return new Promise(res =&gt; &#123;</div><div class="line">    setTimeout(function () &#123;</div><div class="line">      document.body.appendChild(div2)</div><div class="line">      res(&apos;done&apos;)</div><div class="line">    &#125;, 2000)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">_promise().then(data =&gt; &#123;</div><div class="line">  console.log(data)</div><div class="line">  document.body.appendChild(div3)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="Generate"><a href="#Generate" class="headerlink" title="Generate"></a>Generate</h2><p>后来promise加入了es6标准，同时推出了新的异步解决方案，叫做generate函数，大体讲是提供了一个具有状态机功能的函数，每次执行会停止在实现者声明的某个状态，下次调用会继续从这个状态开始执行。</p>
<p>generate的出现，使必须依靠<code>callback</code>实现异步操作的代码风格，可以使用同步代码风格实现，是一颗非常甜的语法糖。</p>
<p>但是它仍有有一些缺点，就是它作为状态机，无法自执行，必须借助实现一个run函数或使用第三方库(如<code>co</code>)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// use generate to sync</div><div class="line">function* _generate() &#123;</div><div class="line">  document.body.appendChild(div1)</div><div class="line"></div><div class="line">  yield function (cb) &#123;</div><div class="line">    setTimeout(function () &#123;</div><div class="line">      document.body.appendChild(div2)</div><div class="line">      cb()</div><div class="line">    &#125;, 2000)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  document.body.appendChild(div3)</div><div class="line"></div><div class="line">  return &apos;done&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function run(fn) &#123;</div><div class="line">  var gen = fn()</div><div class="line"></div><div class="line">  function next(data) &#123;</div><div class="line">    var result = gen.next(data)</div><div class="line"></div><div class="line">    console.log(result.value)</div><div class="line"></div><div class="line">    if (result.done) return</div><div class="line"></div><div class="line">    result.value(next)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  next()</div><div class="line">&#125;</div><div class="line"></div><div class="line">run(_generate)</div></pre></td></tr></table></figure>
<h2 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h2><p>为了解决generate的缺点，es7很快发布了继generate更强大的一个东西，叫做async函数。简单说，它并没有什么新特性，把它看做是可以自执行的generate函数即可，其中的await的操作符可以看做是yield操作符的翻版。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// use async/await and promise to sync</div><div class="line">const fn = function () &#123;</div><div class="line">  return new Promise(res =&gt; &#123;</div><div class="line">    setTimeout(function () &#123;</div><div class="line">      res(document.body.appendChild(div2))</div><div class="line">    &#125;, 2000)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">async function _await () &#123;</div><div class="line">  document.body.appendChild(div1)</div><div class="line">  const f = await fn()</div><div class="line">  console.log(f)</div><div class="line">  document.body.appendChild(div3)</div><div class="line">&#125;</div><div class="line"></div><div class="line">_await()</div></pre></td></tr></table></figure>
<h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><p>最近很火的rxjs也快成用来解决这个问题，详细的介绍可以去它的<a href="http://reactivex.io/rxjs/manual/overview.html" target="_blank" rel="external">官网</a>了解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// use rxjs and callback to sync</div><div class="line">const _callbackObservable = Observable.bindCallback(_callback)</div><div class="line">const result = _callbackObservable()</div><div class="line"></div><div class="line">// result.subscribe(x =&gt; &#123;</div><div class="line">//   document.body.appendChild(div3)</div><div class="line">//   console.log(x)</div><div class="line">// &#125;)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍关于js开发中所涉及的主流异步编程解决方案&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;repo: &lt;a href=&quot;https://github.com/haoliangwu/todoMVCs/tree/master/async-for-js&quot; target=&quot;_blan
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>当开发一周了</title>
    <link href="http://yoursite.com/2016/10/14/%E5%BD%93%E5%BC%80%E5%8F%91%E4%B8%80%E5%91%A8%E4%BA%86/"/>
    <id>http://yoursite.com/2016/10/14/当开发一周了/</id>
    <published>2016-10-14T07:00:09.000Z</published>
    <updated>2017-03-08T07:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>转行做前端开发正好一周了，仔细一想，是真正意义上的一周呀，因为连上了7天班了。</p>
<p>说到感觉如何，我只能说，那是太好了。自从来了新公司，心情一下就变好了，回想这半年来，一直因为一些事情闷闷不乐，我也是蛮能拼的。不过总体工作还是比较忙，因为正好赶上项目要发布的最后一周，而且前端组的好多工作似乎还堆积了，不过好在最后也是按时完成了任务。</p>
<a id="more"></a>
<p>说到公司整体印象，挺好的。我本来寻思吧，估计大连没有像Liferay一样自由的公司了，然而我得到的答案是“自由最自由，只有更自由”。不过这种自由和Liferay相比还不一样，平时的时候，很自由，很轻松，工作或者解决问题的时候，大家又变得很认真、很紧张，这点不同对于我来说，其实是好的。其实原来我也一直在寻找这种感觉，就是大家为一个目标共同努力，共同工作，最后一直也没有找到。原来在Liferay的感觉是，虽然大家都在一起工作，但其实彼此的工作，联系似乎太少了，总是感觉个干个的，交流也少，整体的工作的节奏也比较慢，能解决的事情就解决，解决不了就拖着，慢慢就不了了之了。</p>
<p>说到工作内容，我还是有点惭愧的。我本想，作为一个新来的，代码也不熟悉，业务也不熟悉，然后就把一部分核心功能交给我做了。我只能说，对于我这种半路出家的前端开发，这是有多信任我啊，我自己都有点受宠若惊的感觉。按我的理解，一般新来还不先改改bug，熟悉熟悉业务，之后慢慢再开始做功能，先做次要的，再做主要的，再来核心的。所以导致我写代码的时候，总是有一种使命感似的，因为要对得起这份别人的信任啊。这种感觉仔细想想，似乎仅仅在两年前刚入职Liferay那会有，所以我后来就下定决心好好学习了，现在这种感觉又回来了，真好。</p>
<p>最后，我只想说，作为一个新的开始，只要仍然能够做到不忘初心，能够真心实意的为做一些事情而付出，开开心心的度过每一天，我就很满足了。</p>
<img src="/img/new_start.jpg" width="500" height="350">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转行做前端开发正好一周了，仔细一想，是真正意义上的一周呀，因为连上了7天班了。&lt;/p&gt;
&lt;p&gt;说到感觉如何，我只能说，那是太好了。自从来了新公司，心情一下就变好了，回想这半年来，一直因为一些事情闷闷不乐，我也是蛮能拼的。不过总体工作还是比较忙，因为正好赶上项目要发布的最后一周，而且前端组的好多工作似乎还堆积了，不过好在最后也是按时完成了任务。&lt;/p&gt;
    
    </summary>
    
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>我为什么选择离开了Liferay</title>
    <link href="http://yoursite.com/2016/09/26/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%BB%E5%BC%80%E4%BA%86Liferay/"/>
    <id>http://yoursite.com/2016/09/26/我为什么离开了Liferay/</id>
    <published>2016-09-26T06:21:15.000Z</published>
    <updated>2017-03-08T07:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>距离离开Liferay还剩下用指头可以数出来的日子了，心中不禁感慨万千。这一个月除了做一些交接工作和下一份工作的准备意外，剩下的时间基本都在思考在Liferay的两年半时间我到底得到了什么，又留下了什么？仔细想想，好像没留下什么，至于得到的，确是很多的，毕竟这是我毕业步入社会进入的第一家公司，很多事情从未知到已知都是从这里开始。</p>
<p>在这里认识了不少人，我从他们身上都学到了很多很多，不经意间也帮助了我很多很多，我衷心说声谢谢，同时我也想说，对于我的离职我只想说，离别是为了下次更好的相遇。</p>
<p>不过写这篇的目的并不是为了怀旧，只是最近稍微熟悉点儿的人都在问我一个问题，“你为什么离职？”。这个问题，我从有离职想法的那天，到念头一点点变大，再到最后做出离职的决定，我已经问过自己无数次了。细说起来，大大小小的原因有很多，不过大体概括也就两点，一，我无法得到我想要的，二，Liferay同时也并不需要我这样的人，仅此而已，所以我选择离开。</p>
<p>这里直接说Liferay好像扣上了一个很大的帽子，好吧，这里只是说中国这边的Liferay，后边不特殊说明均指代Liferay CN，如果再具体些，可以指代Liferay CNQA。</p>
<a id="more"></a>
<p>时间回到两年前，我刚刚来Liferay的时候，呆了一个星期左右，大体的感觉是，中国竟然还有这样人性化的公司？弹性制，不加班，年假长，事还少，虽然待遇差点，我心想也值得了，多给我个1000、2000的估计我也不会换其他公司，我也暗自决定，虽然闲，但是不能浪费这些时间，要好好利用空余的时间好好提升自己。事实上，我也是这么做的，这两年间我基本把所有空余的时间都投入到了学技术，学英语，学xx上。但越到后边，越觉的感觉不对，总觉的自己与公司、团队的距离越来越远了，最终不得不选择离职。</p>
<p>最直接的感觉是，团队的技术氛围越来越淡了，做事风格也越来越浮躁了，做很多事情只求结果。还有一些我至今也不是特别懂的事情莫名其妙就发生了，比如:</p>
<p>以前一个关一个ticket是很有自豪感，可以很负责任地说我关闭了它，它是没有问题的，现在我可以以各种流程为理由关闭它，但我再也不敢说它是没有问题的了。</p>
<p>前段时间CN这边也开始做test-fix，其实一开始我挺期待的，后边才发现确实不适合我做，我遇事但求个明白，我一直想要一个fix的技术标准，得到的标准却是as it work。</p>
<p>我后来抽时间给团队分享了一本有关公司测试脚本语音的学习笔记，心想水平虽然比不上某些去美国培训的人强吧，至少也是我自学这么长时间的一些心得体会，抛钻引玉而已，然后竟然被贴了一个“不尊重上级”的标签，还被越级告了一状。</p>
<p>再后来，我给团队写一个editor吧，也是对培养我两年之久的团队的一个证明，心想不求能极大的提高团队效率，能节省3、5分钟也是极好的，最终却令某些人嗤之以鼻，以“用工具最终出了问题谁负责”，“３、５分钟Lyon也许你觉得很重要，反正我觉得不重要”，“IDE评估了要半年才能做好这么一个东西”等理由被拒绝，最终说我态度有问题和我吵了一架，然后也没有下文了。后来我交了辞职信从别人口中得知，似乎也是尝试性地用过我做的这个editor的，之后似乎是真的没有下文了。不过对于这个editor反馈是好，还是不好，我一点都不清楚。在我看来，这更多算是一种“无声抗议”吧，你也不能说人家就是不愿意用你做的东西不是？但是人家就是不愿意。</p>
<p>我想说的是，和我这么多的不痛快，到底图个啥？我自以为，归根结底是因为我做很多事情，总是先斩后奏，导致别人总觉得上级领导是偏心我怎么的。据我猜测，应该是我这个人总让人产生不安全感，总让人觉的盛气凌人，总让人觉得会从别人那里抢走什么似的。那我确实不知道说什么了，毕竟这是人的问题，性格问题，处心积虑地为保全自己的地位来这么一次，我表示理解。</p>
<p>其实对于别人的想法，我是略委屈的，有些时候我也不知道我做这些最终图个啥？从未计较过薪酬待遇，也未曾计较过一官半职，只想尽情做自己想做的事情，为团队尽力所能及之力，改变一些事情。到头来却发现困难重重，一方面是因为团队相对别的office资源本来较少，工作中又常常处于被动的一方，没有什么话语权，另一方面则是团队大部分人本身就缺乏积极性，对于做出改变这种事情，大家大多选择安于现状，对于新鲜事毫无兴趣，少数人甚至比较排斥。</p>
<p>这两年来，我最大的遗憾，莫过于没有向美国证明，中国这边也是可以做技术活儿的，并不一定要依赖他们。我一直很不爽的事情，莫过于被人轻视，不过也是怪我，将这种情结也联系到了工作上面，致使我一直这么觉的，中国office是被美国轻视的，然后qa组的在中国的是被别的组的轻视的，然而最终还是证明我图样图森破，以一己之力，怎么可以带动整个团队？反过来想，现在的这样子的一个团队似乎也不能怪人家轻视。既缺乏核心技术竞争力，同时又处于工作中的被动方，人力成本又便宜，轻视你，怎么了？</p>
<p>我离开Liferay只因为我做事太爱钻死理儿。逢事必问为什么，不然只能靠自己去寻找答案，却在寻找答案的过程中，碰了某些人的所谓的底线。</p>
<p>我离开Liferay只因为我做事不喜欢拖太久。今日事今日毕，有些时候其实并不怪我有些事情先斩后奏，实在是就算先奏，等能斩的时候黄花菜都凉了。</p>
<p>我离开Liferay只因为我做事脑子太“懒”，手却太“勤”，总强调一个效率。时间就是金钱我的朋友，别总和我说３分钟，５分钟不重要这种话，对于我，很重要，对于团队，也很重要。</p>
<p>我离开Liferay只因为我太执着，很多事情但凡投入心血，很难放下。是的，很难放下，但是我还是选择离开了，我并非薄情寡义之人，实在有苦难言，有痛难言。</p>
<p>不过我真心感谢我的直系经理sophia和小组组长steven还有整个fixpack组的每一个人，这两年间给予了我很多支持和鼓励，没有这些，<strong>我想我无法坚持这么久，也无法完成看起来无法完成的事情</strong>。</p>
<p>mark一下，从加入fixpack到离开的可计量工作（其实不是很完全和准确，因为后来做editor没太多精力了）和一些自发的全栈项目。</p>
<p>fixpack改为sub task后的工作量分布图:</p>
<img src="/img/sub-tasks.png" width="250" height="350">
<p>项目:</p>
<ul>
<li><a href="https://github.com/haoliangwu/vscode-poshi" target="_blank" rel="external">vscode-poshi</a></li>
<li><a href="https://github.com/haoliangwu/EasyComment" target="_blank" rel="external">easycomment</a></li>
<li><a href="https://github.com/haoliangwu/testray-screenshot" target="_blank" rel="external">testray-screenshot</a></li>
<li><a href="https://github.com/haoliangwu/FixPack-Workbench" target="_blank" rel="external">fixpack-workbench</a></li>
</ul>
<p>最后祝Liferay越来越好，每个人工作顺利，开心。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;距离离开Liferay还剩下用指头可以数出来的日子了，心中不禁感慨万千。这一个月除了做一些交接工作和下一份工作的准备意外，剩下的时间基本都在思考在Liferay的两年半时间我到底得到了什么，又留下了什么？仔细想想，好像没留下什么，至于得到的，确是很多的，毕竟这是我毕业步入社会进入的第一家公司，很多事情从未知到已知都是从这里开始。&lt;/p&gt;
&lt;p&gt;在这里认识了不少人，我从他们身上都学到了很多很多，不经意间也帮助了我很多很多，我衷心说声谢谢，同时我也想说，对于我的离职我只想说，离别是为了下次更好的相遇。&lt;/p&gt;
&lt;p&gt;不过写这篇的目的并不是为了怀旧，只是最近稍微熟悉点儿的人都在问我一个问题，“你为什么离职？”。这个问题，我从有离职想法的那天，到念头一点点变大，再到最后做出离职的决定，我已经问过自己无数次了。细说起来，大大小小的原因有很多，不过大体概括也就两点，一，我无法得到我想要的，二，Liferay同时也并不需要我这样的人，仅此而已，所以我选择离开。&lt;/p&gt;
&lt;p&gt;这里直接说Liferay好像扣上了一个很大的帽子，好吧，这里只是说中国这边的Liferay，后边不特殊说明均指代Liferay CN，如果再具体些，可以指代Liferay CNQA。&lt;/p&gt;
    
    </summary>
    
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>vscode typings配置</title>
    <link href="http://yoursite.com/2016/09/21/vscode-typings%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2016/09/21/vscode-typings配置/</id>
    <published>2016-09-21T07:33:31.000Z</published>
    <updated>2017-03-08T07:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>vscode发布至今已经到1.5.2了，我是从1.1开始用的，经历了几个改动比较大的版本。总体给我的感觉还是很好的，作为一个rich editor，能够提供像webstorm之类ide的代码提示功能非常赞，但是对于这块的配置还真没折腾过，只知道它的提示是基于ts的compiler提供的，虽然是ts提供的，但是js作为ts的编译对象，同样可以享受这个compiler提供的便利。</p>
<a id="more"></a>
<p>大体步骤分为：</p>
<ul>
<li><a href="#进行vscode的js项目配置">配置typings</a> </li>
<li><a href="#安装typings的依赖资源">安装typings的依赖资源</a></li>
<li><a href="#进行vscode的js项目配置">进行vscode的js项目配置</a></li>
</ul>
<h2 id="配置typings"><a href="#配置typings" class="headerlink" title="配置typings"></a>配置typings</h2><p>首先你需要安装nodejs环境，这里不赘述了。之后</p>
<blockquote>
<p>npm i typings -g</p>
</blockquote>
<p>这样全局都可以调用typings这个命令了，然后只需要在你需要提供智能提示的project的根目录执行</p>
<blockquote>
<p>typings init</p>
</blockquote>
<p>这样会生成一个typings.json文件，这个文件的功能和package.json类似。</p>
<h2 id="安装typings的依赖资源"><a href="#安装typings的依赖资源" class="headerlink" title="安装typings的依赖资源"></a>安装typings的依赖资源</h2><p>安装依赖就容易多了，比如你需要angular的资源，只需要执行</p>
<blockquote>
<p>typings i dt~angular –save –global</p>
</blockquote>
<p>这里的dt~是指资源的registry，这个可以在typings的帮助信息中查看。</p>
<p>如果你不确定某个资源的registry，比如你想要react的资源，你可以执行</p>
<blockquote>
<p>typings search react</p>
</blockquote>
<p>之后console会列出已知的所有资源的registry。</p>
<h2 id="进行vscode的js项目配置"><a href="#进行vscode的js项目配置" class="headerlink" title="进行vscode的js项目配置"></a>进行vscode的js项目配置</h2><p>最后一步，需要为vscode指定js项目配置，这个配置文件叫做jsconfig.json，如果你只需要提供智能提示的功能话，这个文件可以为空。</p>
<p>这个文件的位置表示以当前位置为项目根目录。</p>
<p>并行的项目可以提供多个jsconfig在不同的项目中，以此来表示它们是彼此区分的。</p>
<p>对于嵌套的项目，配置多个jsconfig并不会区分父子关系，不是很建议这么做，因为这个智能提示功能是基于vscode extension的language server实现的，如果一个项目文件过多，可能导致解析超时而导致无法提供正确的提示信息（我遇过n次这种情况，开始还以为是vscode的bug），最好还是采用并行的方式。</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>上图一张</p>
<img src="/img/vscode_typings_angular.png" width="566" height="312">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vscode发布至今已经到1.5.2了，我是从1.1开始用的，经历了几个改动比较大的版本。总体给我的感觉还是很好的，作为一个rich editor，能够提供像webstorm之类ide的代码提示功能非常赞，但是对于这块的配置还真没折腾过，只知道它的提示是基于ts的compiler提供的，虽然是ts提供的，但是js作为ts的编译对象，同样可以享受这个compiler提供的便利。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>7 tips for cooking</title>
    <link href="http://yoursite.com/2016/09/14/7-tips-for-cooking/"/>
    <id>http://yoursite.com/2016/09/14/7-tips-for-cooking/</id>
    <published>2016-09-14T05:07:02.000Z</published>
    <updated>2017-03-08T07:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Quick-cooking-need-not-be-a-chore"><a href="#Quick-cooking-need-not-be-a-chore" class="headerlink" title="Quick cooking need not be a chore."></a>Quick cooking need not be a chore.</h1><p>Use fresh and quick cooking ingredients to make a fast, healthy meal. The following tips will help hurried cooks get a quick meal to the table.</p>
<a id="more"></a>
<ul>
<li>Before cooking organize ingredients. Measure out needed ingredients and place them in small cups or bowls.</li>
</ul>
<blockquote>
<p>Best practice: 麻婆豆腐(spicy tofu) tofu, pepper, soya beans and starch.</p>
</blockquote>
<ul>
<li>Lay out cooking utensils needed to complete the recipe.</li>
</ul>
<blockquote>
<p>Best practice: you need 1-3 bowls to place sauce and 3-5 dishes to place meal.</p>
</blockquote>
<ul>
<li>Set up a time line of when to cook each item. Use recipes with a minimum amount of ingredients.</li>
</ul>
<blockquote>
<p>Best practice: 10-15 minutes per meal.</p>
</blockquote>
<ul>
<li>Cook meals that require few steps in the cooking process.</li>
</ul>
<blockquote>
<p>Best practice: 5-10 steps or less.</p>
</blockquote>
<ul>
<li><p>Cook ahead. Prepare meals in advance and freeze them. Later defrost and reheat the meals in the oven or microwave.</p>
</li>
<li><p>Purchase and use cookbooks that will have titles such as one dish meals, quick cooking, or specify a minimum of ingredients to prepare recipes.</p>
</li>
<li><p>Practice cooking recipes when time is not a factor. Cooking is an art and the more cooking is practiced the easier and quicker the task becomes.</p>
</li>
</ul>
<blockquote>
<p>Best practice: Practice make perfect.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Quick-cooking-need-not-be-a-chore&quot;&gt;&lt;a href=&quot;#Quick-cooking-need-not-be-a-chore&quot; class=&quot;headerlink&quot; title=&quot;Quick cooking need not be a chore.&quot;&gt;&lt;/a&gt;Quick cooking need not be a chore.&lt;/h1&gt;&lt;p&gt;Use fresh and quick cooking ingredients to make a fast, healthy meal. The following tips will help hurried cooks get a quick meal to the table.&lt;/p&gt;
    
    </summary>
    
    
      <category term="英语" scheme="http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>angular学习笔记</title>
    <link href="http://yoursite.com/2016/09/06/angular%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/09/06/angular学习笔记/</id>
    <published>2016-09-06T06:36:48.000Z</published>
    <updated>2017-03-08T07:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近没有怎么写东西，主要是因为准备要换工作了，一方面是以前工作的交接，另一方面就是新公司让我利用这段时间熟悉熟悉angular相关的东西。说来惭愧，angular这个东西其实早在2年前我就涉足过，只可惜当时水平有限，连个npm都玩不明白，更别说什么双向绑定、自定义指令什么的了，然后后来就放弃了。后来就慢慢自学，从html/css到js，再到es6，最后又发现react火了，学了一段时间。</p>
<a id="more"></a>
<p>虽然对于mvvm框架，掌握react一个其实已经够用，但是从找工作开始慢慢才发现，其实react对于好多中小型的公司还算比较”新”的技术，所谓新不是指这个技术有多新，而是因为很多项目的构建基于一些相对而言比较旧的技术，比如angular，因此为了迎合新技术推翻重来一次明显是不现实的，我慢慢意识到２年前欠下的债得还。</p>
<p>因此最近的时间基本都花在重学angular上了，不过可能因为基础相对第一次学习时扎实了不少，又加上有了mvvm框架的使用经验，学习过程相对轻松了不少，但是轻松归轻松，angular给我的感觉依旧是大而全，就是入门很简单，熟练需要经验，精通很难，而且es6的语法也流行开来，angualr当时为了解决很多问题的框架语法现在利用es6的语法完全可以解决，因此我觉的有必要好好梳理一下，先挖个坑，以后慢慢填。</p>
<p>我把所有的笔记都放到了<a href="/angular">这里</a>，供记录参考。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近没有怎么写东西，主要是因为准备要换工作了，一方面是以前工作的交接，另一方面就是新公司让我利用这段时间熟悉熟悉angular相关的东西。说来惭愧，angular这个东西其实早在2年前我就涉足过，只可惜当时水平有限，连个npm都玩不明白，更别说什么双向绑定、自定义指令什么的了，然后后来就放弃了。后来就慢慢自学，从html/css到js，再到es6，最后又发现react火了，学了一段时间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="angular" scheme="http://yoursite.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>interview record 20160822</title>
    <link href="http://yoursite.com/2016/08/22/interview-record-20160822/"/>
    <id>http://yoursite.com/2016/08/22/interview-record-20160822/</id>
    <published>2016-08-22T09:12:41.000Z</published>
    <updated>2017-03-08T07:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试公司"><a href="#面试公司" class="headerlink" title="面试公司"></a>面试公司</h2><p>大连云匠软件</p>
<a id="more"></a>
<h2 id="面试职位"><a href="#面试职位" class="headerlink" title="面试职位"></a>面试职位</h2><p>Web前端开发</p>
<h2 id="面试方式"><a href="#面试方式" class="headerlink" title="面试方式"></a>面试方式</h2><p>电话面试</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>问了一些列范围超级广的问题，不过我感觉大部分问题的答案，面试官还是比较满意的，有一些小问题没有答上来，我觉的并不是因为自己没有能力，其实就是所谓的“约书亚树”道理，当你不明白或者不知道一个事情的时候，如果没有机会去了解它，确实可能永远不可能了解了。就好比这次面试，如果面试官不问我，而我项目经验又比较匮乏，确实真的不知道啊。</p>
<p>有两个问题我特意去网上查了一下，因此这里特意记录下来，知道的就无视吧，不知道的共勉吧。</p>
<blockquote>
<p>display:inline-block为默认样式的标签有哪些？</p>
</blockquote>
<p>这个问题我去网上查了一圈，最终按我的理解，这个问题答案的起点应该始于，HTML中有哪些替代标签?</p>
<p>那么就来查概念吧，<strong>替换标签</strong>是浏览器根据其标签的元素与属性来判断具体显示内容的标签。比如常见的input，根据type属性的值会生成不同功能及样式的标签。所以举一反三咯，a也是，img也是，textarea也是，select也是，因为这些标签本身并没有内容，它们的内容依赖于属性，因此是可”替换”的。</p>
<p>值得一提的是，替换标签均可以增加行高(line-height)，还可以调整baseline（vertical-align），废话，因为人家是inline嘛。</p>
<blockquote>
<p>内容区高度值 = padding-top + padding-bottom + margin-top + margin-bottom + height</p>
</blockquote>
<p>那么反过来，<strong>非替换标签</strong>就是浏览器根据其标签内容直接判断具体显示内容的标签。这个就很常见了，因为浏览器中的标签大部分都是非替换的，比如div, p等等。非替换元素添加padding-top或padding-bottom，不影响行框高度，但内容区高度会变化，margin-top，margin- bottom对行框没有任何影响。添加左右边距会影响非替换元素水平位置。要使非替换元素在父元素框内居中，可以设定line-height = 父元素框的高度。</p>
<p>参考: <a href="http://www.cnblogs.com/huangyin1213/p/5566192.html" target="_blank" rel="external">html中label宽度设置、非替换元素和替换元素</a></p>
<blockquote>
<p>使用display:inline-block时，标签之间的空格如何解决（非margin）？ </p>
</blockquote>
<p>这个问题是面试官连着上面的问题问的，当时直接就蒙逼了。后来挂了电话之后，回到电脑上试了一下，这个问题其实以前也确实遇到过，只不过没有在意罢了。</p>
<p>这个问题的表现类似于这样：</p>
<iframe src="http://jsbin.com/cabetumewu/edit?output" width="680" height="200" frameborder="0" allowfullscreen></iframe>
<p>其中第一行中的input之间有一个小小的空格，然后呢，源码中并没有类似的的空格，然而真的没有吗，并不是的，这里的空格其实是input后跟着的那个换行符，要解决这个问题，下边的大神博客给了Ｎ种方法，我并没有挨个试，因为我没有额外的ie浏览器进行验证，只挑了几个简单易行的。</p>
<ul>
<li>可以不写换行符，直接把元素写到一行，如果觉的可读性不行，那就把换行符写到块级注释中。</li>
<li>可以使用margin为负值进行调整，但是这个不推荐，因为空格宽度因浏览器不同而不同。</li>
<li>可以使用无闭合标签</li>
<li>可以对父元素使用<code>font-size: 0;</code></li>
</ul>
<p>这几个方法我亲测有效，其他方法日后有机会也试试，最后感叹句css真是博大精深，我表示除了积累应该是没有捷径了。</p>
<p>参考: <a href="http://www.zhangxinxu.com/wordpress/?p=2357" target="_blank" rel="external">去除inline-block元素间间距的N种方法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面试公司&quot;&gt;&lt;a href=&quot;#面试公司&quot; class=&quot;headerlink&quot; title=&quot;面试公司&quot;&gt;&lt;/a&gt;面试公司&lt;/h2&gt;&lt;p&gt;大连云匠软件&lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
      <category term="interview" scheme="http://yoursite.com/tags/interview/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>HTML is about meaning</title>
    <link href="http://yoursite.com/2016/08/10/HTML-is-about-meaning/"/>
    <id>http://yoursite.com/2016/08/10/HTML-is-about-meaning/</id>
    <published>2016-08-10T05:05:39.000Z</published>
    <updated>2017-03-08T07:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址: <a href="http://marksheet.io/html-semantics.html" target="_blank" rel="external">http://marksheet.io/html-semantics.html</a></p>
</blockquote>
<p>HTML标签本身的意义是为了传递对于一个document元素的含义，所以再考虑使用正确的标签表达内容之前，考虑你的网页看起来怎么样为时过早，请将注意力集中到每一个你使用的HTML标签上。</p>
<p>你需要根据你书写的内容及本文本身的含义，来选择与之匹配的HTML标签。</p>
<a id="more"></a>
<h2 id="Structure-elements-组织页面"><a href="#Structure-elements-组织页面" class="headerlink" title="Structure elements: 组织页面"></a>Structure elements: 组织页面</h2><p>你可以使用<strong>结构</strong>元素来组织页面的主要部分，这些部分通常包含其他的HTML元素。</p>
<p>下面是一个典型的网页需要包含的<strong>主要部分</strong>:</p>
<ul>
<li><code>&lt;header&gt;</code>作为页面的第一个元素，包含logo和tagline。</li>
<li><code>&lt;nav&gt;</code>作为跳转到其他不同的页面的超链接集合。</li>
<li><code>&lt;h1&gt;</code>作为页面的标题。</li>
<li><code>&lt;article&gt;</code>作为页面的内容模块，比如blog的一个post。</li>
<li><code>&lt;footer&gt;</code>作为页面的最后一个元素，位于最底部。</li>
</ul>
<h2 id="Text-elements-定义内容"><a href="#Text-elements-定义内容" class="headerlink" title="Text elements: 定义内容"></a>Text elements: 定义内容</h2><p>在结构元素中，通常需要寻找一些<strong>文本</strong>元素来达到定义内容的目的。</p>
<p>你将主要使用如下标签:</p>
<ul>
<li><code>&lt;p&gt;</code>作为段落</li>
<li><code>&lt;ul&gt;</code>作为无序列表</li>
<li><code>&lt;ol&gt;</code>作为有序列表</li>
<li><code>&lt;li&gt;</code>作为列表单元</li>
<li><code>&lt;blockquote&gt;</code>作为引用</li>
</ul>
<h2 id="Inline-elements-区分文本"><a href="#Inline-elements-区分文本" class="headerlink" title="Inline elements: 区分文本"></a>Inline elements: 区分文本</h2><p>因为文本标签通常会很长，并且会有不同的内容，<strong>行内</strong>元素使你可以将一些关键部分从文本中区分出来。</p>
<p>有很多的行内元素可以使用，但是你会经常用到以下几个:</p>
<ul>
<li><code>&lt;strong&gt;</code>作为关键字</li>
<li><code>&lt;em&gt;</code>作为强调字</li>
<li><code>&lt;a&gt;</code>作为超链接</li>
<li><code>&lt;small&gt;</code>作为次要字</li>
<li><code>&lt;abbr&gt;</code>作为缩写</li>
</ul>
<p>尝试阅读下面的HTML代码，你就可以很容易的理解每一个元素的用途。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;article&gt;</div><div class="line">  &lt;h1&gt;Main title of the page&lt;/h1&gt;</div><div class="line">  &lt;h2&gt;A subtitle&lt;/h2&gt;</div><div class="line">  &lt;p&gt;</div><div class="line">    Something something an other stuff and some &lt;em&gt;emphasis&lt;/em&gt; and even &lt;strong&gt;important&lt;/strong&gt; words.</div><div class="line">  &lt;/p&gt;</div><div class="line">  &lt;p&gt;</div><div class="line">    Another paragraph.</div><div class="line">  &lt;/p&gt;</div><div class="line">  &lt;ul&gt;</div><div class="line">    &lt;li&gt;One&lt;/li&gt;</div><div class="line">    &lt;li&gt;Two&lt;/li&gt;</div><div class="line">    &lt;li&gt;Three&lt;/li&gt;</div><div class="line">  &lt;/ul&gt;</div><div class="line">  &lt;blockquote&gt;</div><div class="line">    Once said</div><div class="line">  &lt;/blockquote&gt;</div><div class="line">&lt;/article&gt;</div><div class="line">&lt;aside&gt;</div><div class="line">  &lt;h3&gt;My latest posts&lt;/h3&gt;</div><div class="line">  &lt;ul&gt;</div><div class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;One&lt;/a&gt;&lt;/li&gt;</div><div class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;One&lt;/a&gt;&lt;/li&gt;</div><div class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;One&lt;/a&gt;&lt;/li&gt;</div><div class="line">  &lt;/ul&gt;</div><div class="line">&lt;/aside&gt;</div></pre></td></tr></table></figure>
<h2 id="Generic-elements-演变标签"><a href="#Generic-elements-演变标签" class="headerlink" title="Generic elements 演变标签"></a>Generic elements 演变标签</h2><p>当没有显而易见的具有语义的标签来匹配相关内容，但你仍然要插入一些标签来达到格式化和分组化的目的，你可以使用一到两个下面的具有演变性的标签:</p>
<blockquote>
<p>我理解的演变的意思是这些标签可以通过css样式来变成不同职能的其他标签</p>
</blockquote>
<ul>
<li><code>&lt;div&gt;</code>作为块级元素组</li>
<li><code>&lt;span&gt;</code>作为行内元素组</li>
</ul>
<p>尽管这些标签没有任何的实际意义，但它们与css配合使用将十分有用。</p>
<h2 id="Don’t-overthink-semantics-不要想太多"><a href="#Don’t-overthink-semantics-不要想太多" class="headerlink" title="Don’t overthink semantics 不要想太多"></a>Don’t overthink semantics 不要想太多</h2><p>大约有100多种语义标签供你使用。如果可以选择合适的元素来使用，那将是十分不错的选择。</p>
<p>但是不要花费太多的事情太考虑这件事，仅仅从现在开始，有选择地使用上面所提供的标签，你的网页将会变得更好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址: &lt;a href=&quot;http://marksheet.io/html-semantics.html&quot;&gt;http://marksheet.io/html-semantics.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HTML标签本身的意义是为了传递对于一个document元素的含义，所以再考虑使用正确的标签表达内容之前，考虑你的网页看起来怎么样为时过早，请将注意力集中到每一个你使用的HTML标签上。&lt;/p&gt;
&lt;p&gt;你需要根据你书写的内容及本文本身的含义，来选择与之匹配的HTML标签。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>liferay-portlet-container</title>
    <link href="http://yoursite.com/2016/07/26/liferay-portlet-container/"/>
    <id>http://yoursite.com/2016/07/26/liferay-portlet-container/</id>
    <published>2016-07-26T09:44:46.000Z</published>
    <updated>2017-03-08T07:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>portlet是portal中最常用的组件了，所以也来山寨一个70版本的portlet container的UI吧。</p>
<a id="more"></a>
<iframe src="http://jsbin.com/hiviye/edit?output" width="680" height="550" frameborder="0" allowfullscreen></iframe>
<p>唯一花了我不少时间的是，这个对齐的问题，最后才发现，其实只要保证子组件的width+border等于父组件的width就可以了，唉，原谅我的数学是体育老师教的。</p>
<p>除了配色、左上角和右上角的图标以外，相似度应该很高了，就不截原版图啦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;portlet是portal中最常用的组件了，所以也来山寨一个70版本的portlet container的UI吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="liferay" scheme="http://yoursite.com/tags/liferay/"/>
    
  </entry>
  
</feed>
