<!DOCTYPE HTML>
<html>
<head >
  <meta charset="utf-8">
  
  <title>Fine, thank you, and you. | 一切安好，感谢有你，与你同行。</title>

  
  <meta name="author" content="Lyon Wu">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Fine, thank you, and you."/>

  
  <meta property="og:image" content="/favicon.ico"/>
  
  <link rel="manifest" href="/manifest.json">
  <link href="/favicon.ico" rel="icon">

  <link rel="alternate" href="/atom.xml" title="Fine, thank you, and you." type="application/atom+xml">
  <link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/base/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">


</head>


  <body>
    <style>
      .loading {
        position: fixed;
        left: 0px;
        top: 0px;
        width: 100%;
        height: 100%;
        z-index: 9999;
        background: url(/images/magic_cube_loading_spinner.gif) center no-repeat #fff;
      }
    </style>
    <div class="loading"></div>
    <div class="blog">
      <div class="content">

        

    <header class="header-container" style="background-image: url('/images/blog-bg.jpg');">


<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <div class="navbar-header page-scroll">
          <button type="button" id="tglBtn" class="navbar-toggle">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">Lyon Wu</a>
        </div>
        <div id="bosenyblog-navbar">
          <div class="navbar-collapse" id="bs-example-navbar-collapse-6">
            <ul class="nav navbar-nav navbar-right">
            
              <li><a href="/">Home</a></li>
            
              <li><a href="/archives">Archives</a></li>
            
            </ul>
          </div>
        </div>

    </div>
 </nav>
 <div class="gotop-btn">

 </div>
</header>

          
            <div class="container ">
              <div class="row">
                <main class="site-main posts-loop    col-lg-8 col-lg-offset-1
                    col-md-8 col-md-offset-1
                    col-sm-12
                    col-xs-12">
                  
  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2018/05/30/aacp-6/"><span>高级 Angular 组件模式 (6)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/05/30/aacp-6/" rel="bookmark">
        <time class="entry-date published" datetime="2018-05-30T03:06:00.000Z">
          2018-05-30
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
      
          <h2 id="06-Use"><a href="#06-Use" class="headerlink" title="06 Use "></a>06 Use <ng-template></ng-template></h2><blockquote>
<p>原文: <a href="https://blog.angularindepth.com/use-ng-template-c72852c37fba" target="_blank" rel="noopener">Use <ng-template></ng-template></a></p>
</blockquote>
<p><code>[Render Props](https://reactjs.org/docs/render-props.html)</code>最近在<code>React</code>社区中引起了轰动，但是与之类似的模式在Angular中似乎并没有得到太多关注。我在之前写的文章提及过，<code>TemplateRefs</code>就是<code>Angular</code>中的<code>Render Props</code>，同时我会在这篇文章中列举一个简单易用的例子。</p>
<blockquote>
<p>Note: <code>TemplateRef</code>是一个类名而<code>&lt;ng-template&gt;</code>是一个<code>html</code>标签，它们本质上是相同的。不过你可能会在项目中更频繁地使用<code>&lt;ng-template&gt;</code>，但是在网上你可以很容易的搜索到关于<code>TemplateRef</code>的知识，因为<code>&lt;ng-template&gt;</code>会给你提供很多<code>html5</code>中的<code>&lt;template&gt;</code>标签的信息。</p>
</blockquote>
<p>我们已有的实现中，使用自定义内容指令(content directives)。当组件作者提前了解使用该<code>toggle</code>组件的父组件所需要的状态时，那么它将会正常的运作。但是如果父组件所需要的状态并不在我们的设想之内，我们该怎么办？</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>将<code>toggle</code>组件的状态直接提供给父组件，同时允许父组件提供相应的渲染视图(<code>view</code>)。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><code>&lt;ng-template&gt;</code>组件可以完美地解决问题。</p>
<h4 id="1-Toggle-组件"><a href="#1-Toggle-组件" class="headerlink" title="1. Toggle 组件"></a>1. <code>Toggle</code> 组件</h4><p><code>&lt;toggle&gt;</code>组件能够通过<code>ContentChild</code>装饰器得到关于<code>&lt;ng-template&gt;</code>的引用，之后会赋予模板在渲染时所需要的状态，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ng-container</span><br><span class="line">  *ngTemplateOutlet=&quot;layoutTemplate; context: &#123; on: this.on, toggle: this.toggle, fns: &#123; toggle: this.toggle &#125; &#125;&quot;&gt;</span><br><span class="line">&lt;/ng-container&gt;</span><br></pre></td></tr></table></figure>
<p>这里<code>&lt;ng-container&gt;</code>被当做一个占位符来使用，之后你可以使用<code>*ngTemplateOutlet</code>指令来填充它，<code>layoutTemplate</code>变量指代的是需要被渲染的模板，<code>context</code>对象包含的键值对会作为组件状态注入<code>layoutTemplate</code>中。</p>
<h4 id="2-父组件"><a href="#2-父组件" class="headerlink" title="2. 父组件"></a>2. 父组件</h4><p>从<code>toggle</code>组件中传入的状态是通过<code>let</code>关键字在父组件的<code>&lt;ng-template&gt;</code>标签上显示声明的。</p>
<p><code>let</code>关键字的使用方式类是这样的：<code>let-templatevar=&quot;inputvar&quot;</code>，<code>templatevar</code>指代在<code>&lt;ng-template&gt;</code>标签中，关联组件状态值的变量名，而<code>inputvar</code>指代使用<code>&lt;toggle&gt;</code>组件的模板作用域中的变量名。</p>
<p>这种语法会有效地避免命名冲突，比如在父组件作用域中已经有一个<code>inputvar</code>变量了。</p>
<h3 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h3><p><a href="https://stackblitz.com/edit/adv-ng-patterns-06-use-template-refs" target="_blank" rel="noopener">stackblitz演示地址</a></p>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>这种组件设计模式按我个人的理解，其实是依赖倒置原则在视图渲染层的一种延伸，为什么这么说呢？是因为通常情况下子组件视图的渲染逻辑取决于传入的<code>props</code>状态和自身提供的模板，这在大多数情况下不会造成任何困扰，但是当我们无法在提前得知我们需要渲染什么的时候，这个问题就会变得十分棘手。</p>
<p>一种解决方法，我们可以使用条件渲染指令，根据传入的状态来判定组件渲染的状态，这种解决方法在情况比较少的情况下是可以解决问题的，但是当情况数量十分庞大的情况下，增加过多的条件判定会致使子组件的模板代码量剧增，同时降低性能，因为每次渲染都会进行若干次条件逻辑判断。</p>
<p>除了上面的解决方法，就是使用正文中所提及的模式了，这种模式将子组件视图的渲染逻辑倒置为子组件仅仅声明模板中所会使用的状态变量，对于这些变量和模板的注入工作，全权赋予父组件，因此会使子组件的复用性和可测试性大大提高。</p>
<p>正文中仅列举了一个简单的例子中，我这里在简单提及一个实际工作可能会用到的例子，就是表单校验的错误提示组件，一般前端组件设计但凡涉及表单，都会是十分复杂的，更不用说校验这种灵活性很高的功能了。</p>
<p>为了适应表单校验的灵活性，我们使用这种模式会事半功倍，提供校验信息的组件仅仅声明渲染表单错误提示信息需要设计的状态变量即可，比如<code>dirty</code>、<code>touched</code>等等，对于错误信息的文案及样式，统统交由错误提示组件的使用者完成。</p>

      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/翻译/">翻译</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/js/">js</a><a href="/tags/angular/">angular</a>
    </span>
    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2018/05/30/aacp-6/"><span>more</span></a></h3>
    
  
</article>





  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2018/04/27/angular-services-do-not-have-to-be-singletons/"><span>小心 Angular 中的单例 Service</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/27/angular-services-do-not-have-to-be-singletons/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-27T09:58:30.000Z">
          2018-04-27
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
      
          <blockquote>
<p>原文: <a href="https://netbasal.com/angular-services-do-not-have-to-be-singletons-ffa879e62082" target="_blank" rel="noopener">Angular Services do NOT have to be Singletons</a></p>
</blockquote>
<p>你可能知道，当我们通过<code>@NgModule()</code>装饰器来声明一个<code>service</code>时，它将符合<a href="https://en.wikipedia.org/wiki/Singleton_pattern" target="_blank" rel="noopener">单例模式</a>，同时还意味着它与整个应用的生命周期保持一致。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export class AdminService &#123;</span><br><span class="line">  data = Array(10000).fill(dummy);</span><br><span class="line">&#125;</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  providers: [AdminService, AdminDataService]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们在刚开始接触<em>Angular</em>的时候，总是不计后果的将所有<code>service</code>都使用<code>@NgModule()</code>来声明，这将会造成一个不易发现的问题：</p>
<blockquote>
<p>You are not releasing memory.</p>
</blockquote>
<p>在上面的例子中，尽管你不再需要这些内存中储存的数据，但是让我们停下来仔细想一想，我们真的需要将一个<code>service</code>声明为单例的吗？</p>
<p>比如，在我们整个应用中，我们会有一个管理区域需要呈现大量的表格数据（同时这些数据只在这个管理区域展现），这些数据会储存在内存中。在这种情况下，我们没有必要将这个<code>service</code>声明为单例的，因为我们不需要缓冲层来缓存这些数据以供应用中的其他模块使用。</p>
<p>进一步讲，当前我们仅仅是想使这些表格数据在多个<code>component</code>之间共享，同时将数据与<code>service</code>中的多个<code>helper</code>方法耦合起来。所以我们完全可以直接使用<code>@Component()</code>装饰器来声明<code>service</code>，这样它就会成为一个<strong>非单例</strong>的<code>service</code>，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;admin-tab&apos;,</span><br><span class="line">  providers: [AdminService, AdminDataService]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样做的好处是，当<em>Angular</em>注销组件实例时，<em>Angular</em>将同时注销与之绑定的<code>service</code>实例，y也会释放那些用来储存数据的内存。</p>
<h3 id="OnDestroy-钩子函数"><a href="#OnDestroy-钩子函数" class="headerlink" title="OnDestroy 钩子函数"></a>OnDestroy 钩子函数</h3><p>许多开发者也许不知道<strong>非单例</strong>的<code>service</code>有<code>ngOnDestroy()</code>生命周期，所以你也可以在这个生命周期中进行一些销毁逻辑代码的编写，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export class AdminService implements OnDestroy &#123;</span><br><span class="line">  ngOnDestroy() &#123;</span><br><span class="line">    // Clean subscriptions, intervals, etc</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，如果我们调用<code>NgModuleRef.destroy()</code>或者<code>PlatformRef.destroy()</code>，单例<code>service</code>的<code>ngOnDestroy</code>钩子函数也会被[执行]。(<a href="https://github.com/angular/angular/blob/674c3def319e2c444823319ae43394d46f3973b7/packages/core/src/view/ng_module.ts#L199-L204)。" target="_blank" rel="noopener">https://github.com/angular/angular/blob/674c3def319e2c444823319ae43394d46f3973b7/packages/core/src/view/ng_module.ts#L199-L204)。</a></p>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>之所以翻译了这篇文章，是因为今天在整理项目代码的时候，偶然发现了这个问题，虽然我使用<code>Angular</code>也有一段时间了，但是依然将很多没有必要声明在<code>NgModule</code>中的服务以单例模式的方式声明了。文章中指出的问题确实是一个重要但又难以发现的问题。</p>
<p>大体总结一下<code>Angular</code>中声明<code>service</code>的不同方式和应用场景。</p>
<h3 id="使用-Component"><a href="#使用-Component" class="headerlink" title="使用@Component"></a>使用<code>@Component</code></h3><p>这时<code>service</code>与组件本身生命周期保持一致，非单例，适合声明一些需要<em>暂存</em>数据的工具类或者仅在某个或某几个组件中需要<em>缓存</em>数据的状态管理类<code>service</code></p>
<h3 id="使用-NgModule的providers"><a href="#使用-NgModule的providers" class="headerlink" title="使用@NgModule的providers"></a>使用<code>@NgModule</code>的<code>providers</code></h3><p>这时<code>service</code>与应用本身生命周期保持一致（非懒加载），单例，适合声明一些需要在全局<em>缓存</em>数据的状态管理类<code>service</code>。</p>
<p>但是有一个特例，懒加载模块中的<code>service</code>是会在模块加载时重新创建一个实例的，懒加载模块中均会注入后创建的<code>service</code>实例，因此懒加载模块与非懒加载模块间的<code>service</code>非单例。</p>
<h3 id="使用forRoot"><a href="#使用forRoot" class="headerlink" title="使用forRoot"></a>使用<code>forRoot</code></h3><p>使用<code>forRoot</code>可以保证当前模块即使是懒加载模块，在加载时也不会重新创建一个新的<code>service</code>实例，因为懒加载模块在加载时，会临时创建一个从属于根<code>injector</code>的子<code>injector</code>，根据<em>Angular</em>中的依赖注入流程，当尝试通过一个子<code>injector</code>中注入不存在的实例对象时，会尝试向父级<code>injector</code>获取，因此最终可保证该<code>service</code>在应用任何地方被注入均是单例。</p>
<p>关于官方文档的介绍，可以参考<a href="https://angular.io/guide/providers" target="_blank" rel="noopener">Providers</a>和<a href="https://angular.io/guide/singleton-services" target="_blank" rel="noopener">Singleton Services</a>。</p>

      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/翻译/">翻译</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/js/">js</a><a href="/tags/angular/">angular</a>
    </span>
    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2018/04/27/angular-services-do-not-have-to-be-singletons/"><span>more</span></a></h3>
    
  
</article>





  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2018/04/02/30-minutes-graphql/"><span>30分钟理解GraphQL核心概念</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/02/30-minutes-graphql/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-02T04:13:29.000Z">
          2018-04-02
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
      
          <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章<a href="http://littlelyon.com/2018/03/24/rpc-reset-graphql/">RPC vs REST vs GraphQL</a>中，对于这三者的优缺点进行了比较宏观的对比，而且我们也会发现，一般比较简单的项目其实并不需要GraphQL，但是我们仍然需要对新的技术有一定的了解和掌握，在新技术普及时才不会措手不及。</p>
<p>这篇文章主要介绍一些我接触GraphQL的这段时间，觉得需要了解的比较核心的概念，比较适合一下人群：</p>
<ul>
<li>听说过GraphQL的读者，想深入了解一下</li>
<li>想系统地学习GraphQL的读者</li>
<li>正在调研GraphQL技术的读者</li>
</ul>
<p>这些概念并不局限于服务端或者是客户端，如果你熟悉这些概念，在接触任意使用GraphQL作为技术背景的库或者框架时，都可以通过文档很快的上手。</p>
<p>如果你已经GraphQL应用于了实际项目中，那么这篇文章可能不适合你，因为其中并没有包含一些实践中的总结和经验，关于实践的东西我会在之后再单另写一篇文章总结。</p>
<h2 id="什么是GraphQL"><a href="#什么是GraphQL" class="headerlink" title="什么是GraphQL"></a>什么是GraphQL</h2><p>介绍GraphQL是什么的文章网上一搜一大把，篇幅有长有短，但是从最核心上讲，它是一种查询语言，再进一步说，是一种API查询语言。</p>
<p>这里可能有的人就会说，什么？API还能查？API不是用来调用的吗？是的，这正是GraphQL的强大之处，引用官方文档的一句话：</p>
<blockquote>
<p>ask what exactly you want.</p>
</blockquote>
<p>我们在使用REST接口时，接口返回的数据格式、数据类型都是后端预先定义好的，如果返回的数据格式并不是调用者所期望的，作为前端的我们可以通过以下两种方式来解决问题：</p>
<ul>
<li>和后端沟通，改接口（更改数据源）</li>
<li>自己做一些适配工作（处理数据源）</li>
</ul>
<p>一般如果是个人项目，改后端接口这种事情可以随意搞，但是如果是公司项目，改后端接口往往是一件比较敏感的事情，尤其是对于三端（web、andriod、ios）公用同一套后端接口的情况。大部分情况下，均是按第二种方式来解决问题的。</p>
<p>因此如果接口的返回值，可以通过某种手段，从静态变为动态，即调用者来声明接口返回什么数据，很大程度上可以进一步解耦前后端的关联。</p>
<p>在GraphQL中，我们通过预先定义一张<code>Schema</code>和声明一些<code>Type</code>来达到上面提及的效果，我们需要知道：</p>
<ul>
<li>对于数据模型的抽象是通过Type来描述的</li>
<li>对于接口获取数据的逻辑是通过Schema来描述的</li>
</ul>
<p>这么说可能比较抽象，我们一个一个来说明。</p>
<h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><p>对于数据模型的抽象是通过Type来描述的，每一个Type有若干Field组成，每个Field又分别指向某个Type。</p>
<p>GraphQL的Type简单可以分为两种，一种叫做<code>Scalar Type(标量类型)</code>，另一种叫做<code>Object Type(对象类型)</code>。</p>
<h3 id="Scalar-Type"><a href="#Scalar-Type" class="headerlink" title="Scalar Type"></a>Scalar Type</h3><p>GraphQL中的内建的标量包含，<code>String</code>、<code>Int</code>、<code>Float</code>、<code>Boolean</code>、<code>Enum</code>，对于熟悉编程语言的人来说，这些都应该很好理解。</p>
<p>值得注意的是，GraphQL中可以通过<code>Scalar</code>声明一个新的标量，比如：</p>
<ul>
<li>prisma（一个使用GraphQL来抽象数据库操作的库）中，还有<code>DateTime</code>和<code>ID</code>这两个标量分别代表日期格式和主键</li>
<li>在使用GraphQL实现文件上传接口时，需要声明一个<code>Upload</code>标量来代表要上传的文件</li>
</ul>
<p>总之，我们只需要记住，标量是GraphQL类型系统中最小的颗粒，关于它在GraphQL解析查询结果时，我们还会再提及它。</p>
<h3 id="Object-Type"><a href="#Object-Type" class="headerlink" title="Object Type"></a>Object Type</h3><p>仅有标量是不够的抽象一些复杂的数据模型的，这时候我们需要使用对象类型，举个例子(先忽略语法，仅从字面上看)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Article &#123;</span><br><span class="line">  id: ID</span><br><span class="line">  text: String</span><br><span class="line">  isPublished: Boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，就声明了一个<code>Article</code>类型，它有3个Field，分别是<code>ID</code>类型的id，<code>String</code>类型的text和<code>Boolean</code>类型的isPublished。</p>
<p>对于对象类型的Field的声明，我们一般使用标量，但是我们也可以使用另外一个对象类型，比如如果我们再声明一个新的<code>User</code>类型，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type User &#123;</span><br><span class="line">  id: ID</span><br><span class="line">  name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时我们就可以稍微的更改一下关于<code>Article</code>类型的声明代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Article &#123;</span><br><span class="line">  id: ID</span><br><span class="line">  text: String</span><br><span class="line">  isPublished: Boolean</span><br><span class="line">  author: User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Article</code>新增的<code>author</code>的Field是<code>User</code>类型, 代表这篇文章的作者。</p>
<p>总之，我们通过对象模型来构建GraphQL中关于一个数据模型的形状，同时还可以声明各个模型之间的内在关联（一对多、一对一或多对多）。</p>
<h3 id="Type-Modifier"><a href="#Type-Modifier" class="headerlink" title="Type Modifier"></a>Type Modifier</h3><p>关于类型，还有一个较重要的概念，即类型修饰符，当前的类型修饰符有两种，分别是<code>List</code>和<code>Required</code>，它们的语法分别为<code>[Type]</code>和<code>Type!</code>, 同时这两者可以互相组合，比如<code>[Type]!</code>或者<code>[Type!]</code>或者<code>[Type!]!</code>(请仔细看这里<code>!</code>的位置)，它们的含义分别为：</p>
<ul>
<li>列表本身为必填项，但其内部元素可以为空</li>
<li>列表本身可以为空，但是其内部元素为必填</li>
<li>列表本身和内部元素均为必填</li>
</ul>
<p>我们进一步来更改上面的例子，假如我们又声明了一个新的<code>Comment</code>类型，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Comment &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  desc: String,</span><br><span class="line">  author: User!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会发现这里的<code>ID</code>有一个<code>!</code>，它代表这个Field是必填的，再来更新<code>Article</code>对象，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Article &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  text: String</span><br><span class="line">  isPublished: Boolean</span><br><span class="line">  author: User!</span><br><span class="line">  comments: [Comment!]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们这里的作出的更改如下：</p>
<ul>
<li>id字段改为必填</li>
<li>author字段改为必填</li>
<li>新增了comments字段，它的类型是一个元素为Comment类型的List类型</li>
</ul>
<p>最终的<code>Article</code>类型，就是GraphQL中关于文章这个数据模型，一个比较简单的类型声明。</p>
<h2 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h2><p>现在我们开始介绍<code>Schema</code>，我们之前简单描述了它的作用，即它是用来描述<code>对于接口获取数据逻辑</code>的，但这样描述仍然是有些抽象的，我们其实不妨把它当做REST架构中每个独立资源的<code>uri</code>来理解它，只不过在GraphQL中，我们用Query来描述资源的获取方式。因此，我们可以将<code>Schema</code>理解为多个Query组成的一张表。</p>
<p>这里又涉及一个新的概念<code>Query</code>，GraphQL中使用<code>Query</code>来抽象数据的查询逻辑，当前标准下，有三种查询类型，分别是<em>query（查询）</em>、<em>mutation（更改）</em>和<em>subscription（订阅）</em>。 </p>
<p>Note: 为了方便区分，<code>Query</code>特指GraphQL中的查询（包含三种类型），<code>query</code>指GraphQL中的查询类型（仅指查询类型）</p>
<h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><p>上面所提及的3中基本查询类型是作为<code>Root Query（根查询）</code>存在的，对于传统的CRUD项目，我们只需要前两种类型就足够了，第三种是针对当前日趋流行的<code>real-time</code>应用提出的。</p>
<p>我们按照字面意思来理解它们就好，如下：</p>
<ul>
<li>query（查询）：当获取数据时，应当选取Query类型</li>
<li>mutation（更改）：当尝试修改数据时，应当使用mutation类型</li>
<li>subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型</li>
</ul>
<p>仍然以一个例子来说明。</p>
<p>首先，我们分别以REST和GraphQL的角度，以<code>Article</code>为数据模型，编写一系列CRUD的接口，如下：</p>
<p>Rest 接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/articles/</span><br><span class="line">GET /api/v1/article/:id/</span><br><span class="line">POST /api/v1/article/</span><br><span class="line">DELETE /api/v1/article/:id/</span><br><span class="line">PATCH /api/v1/article/:id/</span><br></pre></td></tr></table></figure>
<p>GraphQL Query</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Query &#123;</span><br><span class="line">  articles(): [Article!]!</span><br><span class="line">  article(id: Int): Article!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutation &#123;</span><br><span class="line">  createArticle(): Article!</span><br><span class="line">  updateArticle(id: Int): Article!</span><br><span class="line">  deleteArticle(id: Int): Article!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比我们较熟悉的REST的接口我们可以发现，GraphQL中是按根查询的类型来划分Query职能的，同时还会明确的声明每个Query所返回的数据类型，这里的关于类型的语法和上一章节中是一样的。需要注意的是，我们所声明的任何<code>Query</code>都必须是<code>Root Query</code>的子集，这和GraphQL内部的运行机制有关。</p>
<p>例子中我们仅仅声明了Query类型和Mutation类型，如果我们的应用中对于评论列表有<code>real-time</code>的需求的话，在REST中，我们可能会直接通过长连接或者通过提供一些带验证的获取长连接url的接口，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /api/v1/messages/</span><br></pre></td></tr></table></figure>
<p>之后长连接会将新的数据推送给我们，在GraphQL中，我们则会以更加声明式的方式进行声明，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">subscription &#123;</span><br><span class="line">  updatedArticle() &#123;</span><br><span class="line">    mutation</span><br><span class="line">    node &#123;</span><br><span class="line">    	comments: [Comment!]!</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们不必纠结于这里的语法，因为这篇文章的目的不是让你在30分钟内学会GraphQL的语法，而是理解的它的一些核心概念，比如这里，我们就声明了一个订阅Query，这个Query会在有新的Article被创建或者更新时，推送新的数据对象。当然，在实际运行中，其内部实现仍然是建立于长连接之上的，但是我们能够以更加声明式的方式来进行声明它。</p>
<h3 id="Resolver"><a href="#Resolver" class="headerlink" title="Resolver"></a>Resolver</h3><p>如果我们仅仅在Schema中声明了若干Query，那么我们只进行了一半的工作，因为我们并没有提供相关Query所返回数据的逻辑。为了能够使GraphQL正常工作，我们还需要再了解一个核心概念，<code>Resolver（解析函数）</code>。</p>
<p>GraphQL中，我们会有这样一个约定，Query和与之对应的Resolver是同名的，这样在GraphQL才能把它们对应起来，举个例子，比如关于<code>articles(): [Article!]!</code>这个Query, 它的Resolver的名字必然叫做<code>articles</code>。</p>
<p>在介绍Resolver之前，是时候从整体上了解下GraphQL的内部工作机制了，假设现在我们要对使用我们已经声明的<code>articles</code>的Query，我们可能会写以下查询语句（同样暂时忽略语法）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Query &#123;</span><br><span class="line">  articles &#123;</span><br><span class="line">  	 id</span><br><span class="line">  	 author &#123;</span><br><span class="line">  	 	name</span><br><span class="line">  	 &#125;</span><br><span class="line">  	 comments &#123;</span><br><span class="line">      id</span><br><span class="line">      desc</span><br><span class="line">      author</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GraphQL在解析这段查询语句时会按如下步骤（简略版）：</p>
<ul>
<li>首先进行第一层解析，当前<code>Query</code>的<code>Root Query</code>类型是<code>query</code>，同时需要它的名字是<code>articles</code></li>
<li>之后会尝试使用<code>articles</code>的<code>Resolver</code>获取解析数据，第一层解析完毕</li>
<li>之后对第一层解析的返回值，进行第二层解析，当前<code>articles</code>还包含三个子<code>Query</code>，分别是<code>id</code>、<code>author</code>和<code>comments</code><ul>
<li>id在Author类型中为标量类型，解析结束</li>
<li>author在Author类型中为对象类型User，尝试使用<code>User</code>的<code>Resolver</code>获取数据，当前field解析完毕</li>
<li>之后对第二层解析的返回值，进行第三层解析，当前<code>author</code>还包含一个<code>Query</code>, <code>name</code>，由于它是标量类型，解析结束</li>
<li>comments同上…</li>
</ul>
</li>
</ul>
<p>我们可以发现，GraphQL大体的解析流程就是遇到一个Query之后，尝试使用它的Resolver取值，之后再对返回值进行解析，这个过程是递归的，直到所解析Field的类型是<code>Scalar Type（标量类型）</code>为止。解析的整个过程我们可以把它想象成一个很长的Resolver Chain（解析链）。</p>
<p>这里对于GraphQL的解析过程只是很简单的概括，其内部运行机制远比这个复杂，当然这些对于使用者是黑盒的，我们只需要大概了解它的过程即可。</p>
<p>Resolver本身的声明在各个语言中是不一样的，因为它代表数据获取的具体逻辑。它的函数签名(以js为例子)如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function(parent, args, ctx, info) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的参数的意义如下：</p>
<ul>
<li>parent: 当前上一个Resolver的返回值</li>
<li>args: 传入某个Query中的函数（比如上面例子中<code>article(id: Int)</code>中的<code>id</code>）</li>
<li>ctx: 在Resolver解析链中不断传递的中间变量（类似中间件架构中的context）</li>
<li>info: 当前Query的AST对象</li>
</ul>
<p>值得注意的是，Resolver内部实现对于GraphQL完全是黑盒状态。这意味着Resolver如何返回数据、返回什么样的数据、从哪返回数据，完全取决于Resolver本身，基于这一点，在实际中，很多人往往把GraphQL作为一个中间层来使用，数据的获取通过Resolver来封装，内部数据获取的实现可能基于RPC、REST、WS、SQL等多种不同的方式。同时，基于这一点，当你在对一些未使用GraphQL的系统进行迁移时（比如REST），可以很好的进行增量式迁移。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大概就这么多，首先感谢你耐心的读到这里，虽然题目是30分钟熟悉GraphQL核心概念，但是可能已经超时了，不过我相信你对GraphQL中的核心概念已经比较熟悉了。但是它本身所涉及的东西远远比这个丰富，同时它还处于飞速的发展中。</p>
<p>最后我尝试根据这段时间的学习GraphQL的经验，提供一些进一步学习和了解GraphQL的方向和建议，仅供参考：</p>
<h3 id="想进一步了解GraphQL本身"><a href="#想进一步了解GraphQL本身" class="headerlink" title="想进一步了解GraphQL本身"></a>想进一步了解GraphQL本身</h3><p>我建议再仔细去官网，读一下官方文档，如果有兴趣的话，看看GraphQL的spec也是极好的。这篇文章虽然介绍了核心概念，但是其他一些概念没有涉及，比如Union、Interface、Fragment等等，这些概念均是基于核心概念之上的，在了解核心概念后，应当会很容易理解。</p>
<h3 id="偏向服务端"><a href="#偏向服务端" class="headerlink" title="偏向服务端"></a>偏向服务端</h3><p>偏向服务端方向的话，除了需要进一步了解GraphQL在某个语言的具体生态外，还需要了解一些关于缓存、上传文件等特定方向的东西。如果是想做系统迁移，还需要对特定的框架做一些调研，比如graphene-django。</p>
<p>如果是想使用GraphQL本身做系统开发，这里推荐了解一个叫做<a href="https://www.prisma.io/docs/" target="_blank" rel="noopener">prisma</a>的框架，它本身是在GraphQL的基础上构建的，并且与一些GraphQL的生态框架兼容性也较好，在各大编程语言也均有适配，它本身可以当做一个ORM来使用，也可以当做一个与数据库交互的中间层来使用。</p>
<h3 id="偏向客户端"><a href="#偏向客户端" class="headerlink" title="偏向客户端"></a>偏向客户端</h3><p>偏向客户端方向的话，需要进一步了解关于graphql-client的相关知识，我这段时间了解的是apollo，一个开源的grapql-client框架，并且与各个主流前端技术栈如Angular、React等均有适配版本，使用感觉良好。</p>
<p>同时，还需要了解一些额外的查询概念，比如分页查询中涉及的Connection、Edge等。</p>
<p>大概就这么多，如有错误，还望指正。</p>

      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/原创/">原创</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/graphql/">graphql</a><a href="/tags/api/">api</a>
    </span>
    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2018/04/02/30-minutes-graphql/"><span>more</span></a></h3>
    
  
</article>





  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2018/03/24/rpc-reset-graphql/"><span>RPC vs REST vs GraphQL</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/03/24/rpc-reset-graphql/" rel="bookmark">
        <time class="entry-date published" datetime="2018-03-24T10:03:27.000Z">
          2018-03-24
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
      
          <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近2周的时间由于工作不忙，一直在看有关<code>GraphQL</code>的东西，前后端均有涉及，由于我之前做过后端开发，当时实现的接口的大体是符合<code>RPC</code>风格的接口。后来转做了前端开发，从实现接口者变成了调用接口者，接触最多的当属<code>REST</code>风格的接口。因此在这段学习<code>GraphQL</code>的过程中，并且也尝试使用它以全栈的角度做了一个小项目，在这个过程中，一直在思考它对比前两者在<code>API</code>设计的整体架构体系中的各个指标上，孰优孰劣。</p>
<p>其实在使用和学习的过程中，有很多文章都对比过它们的异同，但是大部分文章并没有从一个相对客观的角度来对比，更多是为了突显一个的优点而刻意指出另外一个的缺点。这让我想到一句话，脱离业务情景谈技术就是耍流氓。</p>
<p>昨天订阅的<code>GraphQL Weekly</code>中推送的一个视频正好是讲关于它们这三者的，于是就点进去看了看，发现质量还是不错的，于是就想整理出来，分享给大家。</p>
<p>原视频地址(油管地址，自备梯子)：<a href="https://www.youtube.com/watch?v=IvsANO0qZEg" target="_blank" rel="noopener">这里</a></p>
<p>如果没有梯子的话直接看我整理的东西也可以，我觉的应该都覆盖到视频中所讲的重点内容了。</p>
<p>当然，这些内容如果分开来讲，每一块内容所涉及的东西都够写一本书了，这里仅仅是简单归纳和整理，从宏观的角度来对比它们的异同，从而能够在日后面临技术选型时，有一个更佳明确的决策方向。</p>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>先简单介绍下<code>RPC</code>，它是<code>Remote Procedure Call(远程过程调用)</code>的简称。一般基于<code>RPC</code>协议所设计的接口，是基于网络采用客户端/服务端的模式完成调用接口的。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>简单并且易于理解（面向开发者）</li>
<li>轻量级的数据载体</li>
<li>高性能</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>对于系统本身耦合性高</li>
<li>因为RPC本身很简单、轻量，因此很容易造成 <code>function explosion</code></li>
</ul>
<p>关于<code>RPC</code>的优点其实很好理解，就是因为它性能高同时又很简单，但是我认为这是对于接口提供者来讲的（因为它的高耦合性）。</p>
<p>但是如果从接口调用者的角度来看，高耦合性就变成了缺点，因为高耦合意味着调用者必须要足够了解系统本身的实现才能够完成调用，比如：</p>
<ul>
<li>调用者需要知道所调用接口的函数名、参数格式、参数顺序、参数名称等等</li>
<li>如果接口提供者(server)要对接口做出一些改变，很容易对接口调用者(client)造成<code>breaking change</code>（违背开闭原则)</li>
<li>一般<code>RPC</code>所暴露接口仅仅会暴露函数的名称和参数等信息，对于函数之间的调用关系无法提供，这意味着调用者必须足够了解系统，从能够知道如何正确的调用这些接口，但是对于接口调用者往往不需要了解过多系统内部实现细节</li>
</ul>
<p>关于上面的第二点，为了减少<code>breaking change</code>，我之前实现接口的时候一般都会引入版本的概念，就是在暴露接口的方法名中加入版本号，一开始效果确实不错，但是随后就不知不觉的形成了<code>function explosion</code>，和视频中主讲人所举例的例子差不多，贴一下视频中的截图感受一波：</p>
<img src="/img/func_explosion.png">
<h1 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h1><p>当前REST风格的API架构方式已经成了主流解决方案了，相比较RPC，它的主要不同之处在于，它是对于资源(Resource)的模型化而非步骤(Procedure)。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>对于系统本身耦合性低，调用者不再需要了解接口内部处理和实现细节</li>
<li>重复使用了一些 http 协议中的已定义好的部分状态动词，增强语义表现力</li>
<li>API可以随着时间而不断演进</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>缺少约束，缺少简单、统一的规范</li>
<li>有时候 payload 会变的冗余(overload)，有时候调用api会比较繁琐(chattiness) </li>
<li>有时候需要发送多条请求已获取数据，在网络带宽较低的场景，往往会造成不好的影响</li>
</ul>
<p>REST的优点基本解决了RPC中存在的问题，就是解耦，从而使得前后端分离成为可能。接口提供者在修改接口时，不容易造成breaking-change，接口调用者在调用接口时，往往面向数据模型编程，而省去了了解接口本身的时间成本。</p>
<p>但是，我认为REST当前最大的问题在于虽然它利用<code>http</code>的动词约束了接口的暴露方式，同时增强了语义，但是却没有约束接口如何返回数据的最佳实践，总让人感觉只要是返回json格式的接口都可以称作REST。</p>
<p>我在实际工作中，经常会遇到第二条缺点所指出的问题，就是接口返回的数据冗余度很高，但是却缺少我真正需要的数据，因此不得已只能调用其他接口或者直接和后端商议修改接口，并且这种问题会在web端和移动端共用一套接口中被放大。</p>
<p>当前比较好的解决方案就是规范化返回数据的格式，比如json-schema或者自己制定的规范。</p>
<h1 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h1><p>GraphQL是近来比较热门的一个技术话题，相比REST和RPC，它汲取了两者的优点，即不面向资源，也不面向过程，而是面向数据查询(ask for exactly what you want)。</p>
<p>同时GraphQL本身需要使用强类型的Schema来对数据模型进行定义，因此相比REST它的约束性更强。</p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li>网络开销低，可以在单一请求中获取REST中使用多条请求获取的资源</li>
<li>强类型Schema（约束意味着可以根据规范形成文档、IDE、错误提示等生态工具）</li>
<li>特别适合<em>图</em>状数据结构的业务场景（比如好友、流程、组织架构等系统）</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>本身的语法相比较REST和RPC均复杂一些</li>
<li>实现方面需要配套 Caching 以解决性能瓶颈</li>
<li>对于 API 的版本控制当前没有完善解决方案（社区的建议是不要使API版本化）</li>
<li>仍然是新鲜事物，很多技术细节仍然处于待验证状态</li>
</ul>
<p>鉴于GraphQL这两个星期我也仅仅是做了一些简单地使用和了解，仅仅说一下感受。</p>
<p>首先值得肯定的是，在某些程度上确实解决了REST的缺点所带来的问题，同时配套社区建议的各种工具和库，相比使用REST风格，全栈开发体验上升一个台阶。</p>
<p>但是这个看起来很好的东西为什么没有火起来呢？我觉的最主要的原因是因为GraphQL所带来的好处，大部分是对于接口调用者而言的，但是实现这部分的工作却需要接口提供者来完成。</p>
<p>同时GraphQL的最佳实践场景应当是类似像Facebook这样的网站，业务逻辑模型是图状数据结构，比如社交。如果在一些业务逻辑模型相对简单的场景，使用GraphQL确实不如使用REST来得简单明了、直截了当。</p>
<p>另外一方面是GraphQL的使用场景相当灵活，在我自己的调研项目中，我是把它当做一个类似ORM的框架来使用的，在别人的一些文章中，会把它当做一个中间层来做渐进式开发和系统升级。这应当算是另外一个优点。</p>
<h3 id="到底用哪个"><a href="#到底用哪个" class="headerlink" title="到底用哪个"></a>到底用哪个</h3><p>下面根据要设计的API类型给予一些技术选型建议。</p>
<p>如果是<code>Management API</code>，这类API的特点如下：</p>
<ul>
<li>关注于对象与资源</li>
<li>会有多种不同的客户端</li>
<li>需要良好的可发现性和文档</li>
</ul>
<p>这种情景使用<code>REST + JSON API</code>可能会更好。</p>
<p>如果是<code>Command or Action API</code>，这类API的特点如下：</p>
<ul>
<li>面向动作或者指令</li>
<li>仅需要简单的交互</li>
</ul>
<p>这种情况使用<code>RPC</code>就足够了。</p>
<p>如果是<code>Internal Micro Services API</code>，这类API的特点如下：</p>
<ul>
<li>消息密集型</li>
<li>对系统性能有较高要求</li>
</ul>
<p>这种情景仍然建议使用<code>RPC</code>。</p>
<p>如果是<code>Micro Services API</code>，这类API的特点如下：</p>
<ul>
<li>消息密集型</li>
<li>期望系统开销较低</li>
</ul>
<p>这种情景使用<code>RPC</code>或者<code>REST</code>均可。</p>
<p>如果是<code>Data or Mobile API</code>，这类API的特点是：</p>
<ul>
<li>数据类型是具有图状的特点</li>
<li>希望对于高延迟场景可以有更好的优化</li>
</ul>
<p>这种场景无疑<code>GraphQL</code>是最好的选择。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>提供一张表格来总览它们之间在不同指标下的表现：</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">耦合性</th>
<th style="text-align:center">约束性</th>
<th style="text-align:center">复杂度</th>
<th style="text-align:center">缓存</th>
<th style="text-align:center">可发现性</th>
<th style="text-align:center">版本控制</th>
</tr>
</thead>
<tbody>
<tr>
<td>RPC(Function)</td>
<td style="text-align:center">high</td>
<td style="text-align:center">medium</td>
<td style="text-align:center">low</td>
<td style="text-align:center">custom</td>
<td style="text-align:center">bad</td>
<td style="text-align:center">hard</td>
</tr>
<tr>
<td>REST(Resource)</td>
<td style="text-align:center">low</td>
<td style="text-align:center">low</td>
<td style="text-align:center">low</td>
<td style="text-align:center">http</td>
<td style="text-align:center">good</td>
<td style="text-align:center">easy</td>
</tr>
<tr>
<td>GraphQL(Query)</td>
<td style="text-align:center">medium</td>
<td style="text-align:center">high</td>
<td style="text-align:center">medium</td>
<td style="text-align:center">custom</td>
<td style="text-align:center">good</td>
<td style="text-align:center">???</td>
</tr>
</tbody>
</table>
<p>最后引用人月神话中的观点<code>no silver bullet</code>，在技术选型时需要具体情况具体分析，不过鉴于GraphQL的灵活性，把它与RPC和REST配置使用，也是不错的选择。</p>

      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/原创/">原创</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/graphql/">graphql</a><a href="/tags/api/">api</a>
    </span>
    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2018/03/24/rpc-reset-graphql/"><span>more</span></a></h3>
    
  
</article>





  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2018/02/17/aacp-4/"><span>高级 Angular 组件模式 (4)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/17/aacp-4/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-17T11:08:26.000Z">
          2018-02-17
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
      
          <h2 id="04-Avoid-Namespace-Clashes-with-Directives"><a href="#04-Avoid-Namespace-Clashes-with-Directives" class="headerlink" title="04 Avoid Namespace Clashes with Directives"></a>04 Avoid Namespace Clashes with Directives</h2><blockquote>
<p>原文: <a href="https://blog.angularindepth.com/avoid-namespace-clashes-with-directives-1f00d62de445" target="_blank" rel="noopener">Avoid Namespace Clashes with Directives</a></p>
</blockquote>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>在同一个<code>html</code>元素上绑定多个指令可能会造成命名冲突。</p>
<p>命名冲突不仅存在于指令的选择器之间，同时也会存在于指令的<code>Inputs</code>和<code>Outputs</code>属性，当这些属性名一样时，Angular并不会进行提示，它会按原本的逻辑正常工作。这种情况有时候是我们希望看到的，有些时候却不是。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>避免存在于绑定在相同元素上的多个指令上的命名冲突。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>因为<code>toggle</code>和<code>withToggle</code>指令都绑定于<code>&lt;toggle&gt;</code>元素，我们将通过为它们增加一个<code>label</code>属性来说明问题。</p>
<p>首先我们设置一个<code>label</code>属性，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;toggle label=&quot;some label&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>这个<code>label</code>属性的值会同时绑定在每个指令上，如果想要为其中的某个指令单独绑定，只能通过使用<code>prefix(前缀)</code>来实现。</p>
<p>Angular官方提供的规范指南也警示了这一点，当你在使用<code>prefix</code>修饰指令的名称时，也需要注意使用<code>prefix</code>来修饰<code>Input</code>和<code>Output</code>属性的名称。</p>
<p>Note: 当使用<code>Output</code>属性重写原生<code>DOM</code>元素的事件和使用<code>Input</code>属性重写原生元素的属性时，请额外注意，没有任何方式可以获知别人在他们编写的应用或者库中使用的命名，但是你可以很轻易的知道的具体命名的大体规则是什么，并且不要重写它们，除非你有意为之。</p>
<p>增加<code>prefix</code>的一种方式是在每个指令的<code>label</code>属性的装饰器内增加一个字符串参数，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// In withToggle.directive.ts</span><br><span class="line">@Input(&apos;withToggleLabel&apos;) label;</span><br><span class="line"></span><br><span class="line">// In toggle.directive.ts</span><br><span class="line">@Input(&apos;toggleLabel&apos;) label;</span><br></pre></td></tr></table></figure></p>
<p>但是这种解决方案的前提时，你至少能够更改存在命名冲突中的一个或多个指令的源码。如果在两个第三方库中存在命名冲突，这种情况是最棘手的，我们不在这里讨论它们。</p>
<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p><a href="https://stackblitz.com/edit/adv-ng-patterns-04-namespace-clashes" target="_blank" rel="noopener">https://stackblitz.com/edit/adv-ng-patterns-04-namespace-clashes</a></p>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>原文中关于最后一段提出的关于在多个第三方库中存在的命名冲突的场景，作者提供做出具体的解决方案，我在这里简单分享一下自己对于这种情况的解决方案：</p>
<p>通常这种情况比较少见，但是万一存在这种情况，我们可以通过创建一个新的<code>wrapper</code>指令来封装第三方指令，<code>wrapper</code>指令提供与第三方指令一样的接口属性，但是因为我们对于<code>wrapper</code>指令有绝对的控制权，我们可以提供统一的<code>prefix</code>来修饰这些接口属性，从而达到解决冲突的效果。</p>

      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/翻译/">翻译</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/js/">js</a><a href="/tags/angular/">angular</a>
    </span>
    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2018/02/17/aacp-4/"><span>more</span></a></h3>
    
  
</article>





  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2018/02/17/aacp-5/"><span>高级 Angular 组件模式 (5)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/17/aacp-5/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-17T11:07:14.000Z">
          2018-02-17
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
      
          <h2 id="05-Handle-Template-Reference-Variables-with-Directives"><a href="#05-Handle-Template-Reference-Variables-with-Directives" class="headerlink" title="05 Handle Template Reference Variables with Directives"></a>05 Handle Template Reference Variables with Directives</h2><blockquote>
<p>原文: <a href="https://blog.angularindepth.com/handle-template-reference-variables-with-directives-223081bc70c2" target="_blank" rel="noopener">Handle Template Reference Variables with Directives</a></p>
</blockquote>
<p>在之前的例子中，已经出现多次使用<code>template reference variable（模板引用变量）</code>的场景，现在让我们来深入研究如何通过使用模板引用变量来关联某个具体指令。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在视图模板内，获取一个指令的引用。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>模板引用变量是获取某个元素、组件或者指令引用的一种方式，这个引用可以在当前的视图模板中的任何地方使用。它们通常是以<code>#baseToggle</code>或者<code>#myToggle=&quot;toggle&quot;</code>的语法声明的。一旦声明，在视图模板的任何地方就可以使用它。</p>
<p>Note: 请注意作用域的问题，如果你使用<code>&lt;ng-template&gt;</code>或者是一个结构性指令，比如<code>*ngIf</code>或者<code>*ngFor</code>，它会在这个模板上创建一个新的作用域，之后在其内部声明的模板引用变量无法在该模板作用域以外使用。</p>
<p>模板引用变量的解析顺序通常为：</p>
<ol>
<li>一个指令或者组件通过它自身的<code>exportAs</code>属性，比如<code>#myToggle=&quot;toggle&quot;</code></li>
<li>声明于以自定义标签存在的组件，比如<code>&lt;toggle-on #toggleOn&gt;&lt;/toggle-on&gt;</code></li>
<li>原生html元素，并且没有任何组件绑定与它，比如<code>&lt;div #someDiv&gt;&lt;/div&gt;</code></li>
</ol>
<p>之后我们来分别看3个例子。</p>
<h3 id="指令与exportAs"><a href="#指令与exportAs" class="headerlink" title="指令与exportAs"></a>指令与<code>exportAs</code></h3><p>指令可以在它的元数据中声明<code>exportAs</code>属性，这个属性表示它被这个模板引用变量所标识，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// toggle.directive.ts</span><br><span class="line">@Directive(&#123;</span><br><span class="line">  selector: &apos;[toggle]&apos;,</span><br><span class="line">  exportAs: &apos;toggle&apos;,</span><br><span class="line">&#125;)</span><br><span class="line">export class ToggleDirective &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>之后我们可以在视图模板中直接使用<code>toggle</code>来获取指令的引用，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// app.component.html</span><br><span class="line">&lt;div toggle #myTemplateRefVar=&quot;toggle&quot;&gt;&lt;/div&gt;</span><br><span class="line">// myTemplateRefVar is the ToggleDirective</span><br></pre></td></tr></table></figure></p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>对于每一个<code>html</code>元素，只会有一个组件与之对应。当一个组件绑定于一个元素时，那么声明的模板引用变量将会被解析为当前元素上所绑定的组件，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// app.component.html</span><br><span class="line">&lt;toggle-on #toggleOn&gt;&lt;/toggle-on&gt;</span><br><span class="line">// toggleOn is the ToggleOnComponent</span><br></pre></td></tr></table></figure></p>
<h3 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h3><p>如果没有组件与元素绑定，模板引用变量会指向当前这个<code>html</code>元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// app.component.html</span><br><span class="line">&lt;div #someDiv&gt;&lt;/div&gt;</span><br><span class="line">// someDiv is an HTMLDivElement</span><br></pre></td></tr></table></figure></p>
<h3 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h3><p>Note: 在<code>stackblitz</code>中，我通过打印模板引用变量所指向的类的名字（constructor.name）来演示它所代表的引用。</p>
<p><a href="https://stackblitz.com/edit/adv-ng-patterns-05-template-ref-variables" target="_blank" rel="noopener">https://stackblitz.com/edit/adv-ng-patterns-05-template-ref-variables</a></p>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>这篇文章作者关于模板引用变量，仅仅介绍了关于如何声明和在视图模板中如何使用，我在这里再补充一些，如何在组件或者指令类的内部使用。</p>
<p>在类内部获取模板引用变量所指向的引用是通过使用<code>ViewChild</code>装饰器完成的，比如上述文章中的第二个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;my-app&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;div #myDiv&gt;&lt;/div&gt;</span><br><span class="line">  `,</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent &#123;</span><br><span class="line">  @ViewChild(&apos;myDiv&apos;)</span><br><span class="line">  myDiv: ElementRef;</span><br><span class="line"></span><br><span class="line">  ngAfterViewInit() &#123;</span><br><span class="line">    console.log(this.myDiv);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>myDiv</code>即指向当前模板引用变量所指向的html元素。</p>
<p>Note: 在类中获取模板引用变量所指向的引用时，请格外注意你期望获取的引用类型，在例子中，我们期望获取html元素，因此这里的引用类型是<code>ElementRef</code>，如果是指令或者组件，则分别要对应其类型的<code>Type</code>。</p>

      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/翻译/">翻译</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/js/">js</a><a href="/tags/angular/">angular</a>
    </span>
    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2018/02/17/aacp-5/"><span>more</span></a></h3>
    
  
</article>





  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2018/02/08/javascript原型链review/"><span>javascript原型链-review</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/08/javascript原型链review/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-08T09:28:48.000Z">
          2018-02-08
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
      
          <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>虽然现在es8都已经在预发布阶段了，但是无论发布到es几，其本身的运作原理都是一样的。</p>
<p>首先祭上一张图, 这张图主要描述了以下的关系，如果觉的这里的说明过于复杂可以直接看<a href="#总结">最后一段</a>。<br><img src="/img/e83bca5f1d1e6bf359d1f75727968c11_hd.jpg"></p>
<h2 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h2><p>关于<code>function(class)A</code>和它的原型之间的关系</p>
<blockquote>
<p><code>A.prototype.constructor</code>与<code>A</code>等价</p>
</blockquote>
<p>关于<code>function(class)A</code>的实例<code>a</code>与它的原型之间的关系</p>
<blockquote>
<p><code>a.__proto__</code>与<code>A.prototype</code>等价</p>
</blockquote>
<p>在上面两个等价条件的基础上，就可以很容易得到</p>
<blockquote>
<p><code>a.__proto__.prototype.constructor</code>与<code>A</code>等价</p>
</blockquote>
<p>这是一般的类和对象实例之间的原型继承关系。</p>
<p>在此基础上，对于<code>Object</code>和<code>Function</code>还有一些特殊的关系。</p>
<p>关于<code>function(class)A</code>和<code>Function</code>之间的关系</p>
<blockquote>
<p><code>A.__proto__</code>与<code>Function.prototype</code>等价</p>
</blockquote>
<p>关于<code>function(class)A</code>的原型和<code>Object</code>之间的关系</p>
<blockquote>
<p><code>A.prototype.__proto__</code>与<code>Object.prototype</code>等价</p>
</blockquote>
<p>关于<code>Function</code>的原型和<code>Object</code>之间的关系</p>
<blockquote>
<p><code>Function.prototype.__proto__</code>与<code>Object.prototype</code>等价</p>
</blockquote>
<p>所以也可以很容易知道</p>
<blockquote>
<p><code>A.__proto__.__proto__</code>与<code>Object.prototype</code>等价</p>
</blockquote>
<p><code>Object</code>对象比较特殊，因为它是所有对象的根，所以约定它的原型所指向的原型对象为空</p>
<blockquote>
<p><code>Object.prototype.__proto__</code>与<code>null</code>等价</p>
</blockquote>
<p>同时javascript中一切皆为对象，但<code>Object</code>本身是一个构造函数，因此它本身的原型对象指向<code>Function.prototype</code></p>
<blockquote>
<p><code>Object.__proto__</code>与<code>Function.prototype</code></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以无论是es5风格的继承还是es6风格的继承语法，原型链的形成是都是通过<code>__proto__</code>和<code>prototype</code>描述的，举个例子，这里使用<code>es6</code>, 即:</p>
<p>如果有:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class B extends A &#123;&#125;</span><br><span class="line">const a = new B()</span><br></pre></td></tr></table></figure></p>
<p>则有：</p>
<ul>
<li><code>a.__proto__ === B.prototype</code></li>
<li><code>B.prototype.constructor.__proto__ === B.__proto__</code></li>
<li><code>B.__proto__ === A</code></li>
<li><code>A.prototype.constructor.__proto === A.__proto__</code></li>
<li><code>A.__proto__ === Function.prototype</code></li>
<li><code>Function.prototype.__proto__ === Object.prototype</code></li>
<li><code>Object.prototype.__proto__ === null</code></li>
</ul>
<p>其他的以此类推。</p>

      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/原创/">原创</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/js/">js</a>
    </span>
    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2018/02/08/javascript原型链review/"><span>more</span></a></h3>
    
  
</article>





  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2018/02/08/SOLID-l/"><span>【译】Understanding SOLID Principles - Liskov Substitution Principle</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/08/SOLID-l/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-08T03:16:57.000Z">
          2018-02-08
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
      
          <h1 id="Understanding-SOLID-Principles-Liskov-Substitution-Principle"><a href="#Understanding-SOLID-Principles-Liskov-Substitution-Principle" class="headerlink" title="Understanding SOLID Principles: Liskov Substitution Principle"></a><a href="https://codeburst.io/understanding-solid-principles-liskov-substitution-principle-e7f35277d8d5" target="_blank" rel="noopener">Understanding SOLID Principles: Liskov Substitution Principle</a></h1><blockquote>
<p>这是理解<code>SOLID</code>原则，关于<strong>里氏替换原则</strong>为什么提倡我们面向抽象层编程而不是具体实现层，以及为什么这样可以使代码更具维护性和复用性。</p>
</blockquote>
<h2 id="什么是里氏替换原则"><a href="#什么是里氏替换原则" class="headerlink" title="什么是里氏替换原则"></a>什么是里氏替换原则</h2><blockquote>
<p>Objects should be replaceable with instances of their subtypes without altering the correctness of that program.</p>
</blockquote>
<blockquote>
<p>某个对象实例的子类实例应当可以在不影响程序正确性的基础上替换它们。</p>
</blockquote>
<p>这句话的意思是说，当我们在传递一个父抽象的子类型时，你需要保证你不会修改任何关于这个父抽象的行为和状态语义。</p>
<p>如果你不遵循里氏替换原则，那么你可能会面临以下问题：</p>
<ul>
<li>类继承会变得很混乱，因此奇怪的行为会发生</li>
<li>对于父类的单元测试对于子类是无效的，因此会降低代码的可测试性和验证程度</li>
</ul>
<p>通常打破这条原则的情况发生在修改父类中在其他方法中使用的，与当前子类无关联的内部或者私有变量。这通常算得上是一种对于类本身的一次潜在攻击，而且这种攻击可能是你在不经意间自己发起的，而且不仅在子类中。</p>
<h2 id="反面例子"><a href="#反面例子" class="headerlink" title="反面例子"></a>反面例子</h2><p>让我们通过一个<strong>反面例子</strong>来演示这种修改行为和它所产生的后果。比如，我们有一个关于<code>Store</code>的抽象类和它的实现类<code>BasicStore</code>，这个类会储存一些消息在内存中，直到储存的个数超过每个上限。客户端代码的实现也很简单明了，它期望通过调用<code>retrieveMessages</code>就可以获取到所有储存的消息。</p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">interface Store &#123;</span><br><span class="line">    store(message: string);</span><br><span class="line">    retrieveMessages(): string[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const STORE_LIMIT = 5;</span><br><span class="line"></span><br><span class="line">class BasicStore implements Store &#123;</span><br><span class="line">   protected stash: string[] = [];</span><br><span class="line">   protected storeLimit: number = STORE_LIMIT;</span><br><span class="line">  </span><br><span class="line">   store(message: string) &#123;</span><br><span class="line">     if (this.storeLimit === this.stash.length) &#123;</span><br><span class="line">         this.makeMoreRoomForStore();</span><br><span class="line">      &#125;</span><br><span class="line">      this.stash.push(message);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    retrieveMessages(): string[] &#123;</span><br><span class="line">      return this.stash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    makeMoreRoomForStore(): void &#123;</span><br><span class="line">       this.storeLimit += 5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后通过继承<code>BasicStore</code>，我们又创建了一个新的<code>RotatingStore</code>实现类，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class RotatingStore extends BasicStore &#123;</span><br><span class="line">    makeMoreRoomForStore() &#123;</span><br><span class="line">        this.stash = this.stash.slice(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意<code>RotatingStore</code>中覆盖父类<code>makeMoreRoomForStore</code>方法的代码以及它是如何隐蔽地改变了父类<code>BasicStore</code>关于<code>stash</code>的状态语义的。它不仅修改了<code>stash</code>变量，还销毁了在程序进程中已储存的消息已为将来的消息提供额外的空间。</p>
<p>在使用<code>RotatingStore</code>的过程中，我们会遇到一些奇怪的现象，这正式由于<code>RotatingStore</code>本身产生的，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const st: Store = new RotatingStore()</span><br><span class="line"></span><br><span class="line">st.store(&quot;hello&quot;)</span><br><span class="line">st.store(&quot;world&quot;)</span><br><span class="line">st.store(&quot;how&quot;)</span><br><span class="line">st.store(&quot;are&quot;)</span><br><span class="line">st.store(&quot;you&quot;)</span><br><span class="line">st.store(&quot;today&quot;)</span><br><span class="line">st.store(&quot;sir?&quot;)</span><br><span class="line"></span><br><span class="line">st.retrieveMessages() // 一些消息丢失了</span><br></pre></td></tr></table></figure>
<p>一些消息会无故消失，当前这个类的表现逻辑与所有消息均可以被取出的基本需求不一致。</p>
<h2 id="如何实践里氏替换原则"><a href="#如何实践里氏替换原则" class="headerlink" title="如何实践里氏替换原则"></a>如何实践里氏替换原则</h2><p>为了避免这种奇怪现象的发生，里氏替换原则推荐我们通过在子类中调用父类的公有方法来获取一些内部状态变量，而不是直接使用它。这样我们就可以保证父类抽象中正确的状态语义，从而避免了副作用和非法的状态转变。</p>
<p>它也推荐我们应当尽可能的使基本抽象保持简单和最小化，因为对于子类来说，有助于提供父类的扩展性。如果一个父类是比较复杂的，那么子类在覆盖它的时候，在不影响父类状态语义的情况下进行扩展绝非易事。</p>
<p>对于内部系统做可行的后置条件检查也是一个不错的方式，这种检查通常会验证是否子类会搅乱一些关键代码的运行路径（译者注：也可以理解为状态语义），但是我本身对这个实践并没有太多的经验，所以无法给予具体的例子。</p>
<p>代码评论也可以一定程度上给予好的帮助。当你在开发一些你可能无意间做出一些对已有系统的破坏，但是你的同事可能会很容易地发现这些（当局者迷旁观者清）。软件设计保持一致性是一件十分重要的事情，因此应当尽早、尽可能多地查明那些对对象继承链作出潜在修改的代码。</p>
<p>最后，在<strong>单一职责原则</strong>中，我们曾提及，考虑使用<strong>组合模式</strong>来替换<strong>继承模式</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正如你所看到的，在开发软件时，我们往往需要额外花一些努力和精力来使它变得更好。将这些原则牢记于心，理解它们所存在的意义以及它们想要解决的问题，这样会使你的工作变得更加容易、更具条理性，但是同时记住，这并不是一件容易的事，相反，你应当在构思软件时，花相当多的事件思考如何更好地实践这些原则。</p>
<p>试着让自己设计的软件系统具备可适应性，这种适应性可以抵御各种不利的变化以及潜在的错误，这样自然而然地可以使你少加班和早回家（译者注：看来加班是每个程序员都要面临的问题啊）</p>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>这是<strong>SOLID</strong>原则中我所接触和了解较少的一个原则，但经过仔细思考后，发现其实我们还是经常会在实际工作中运用它的。</p>
<p>在许多面向相对的编程语言中，关于对象的继承机制中，都会提供一些内部变量和状态的修饰符，比如<code>public（公有）</code>、<code>protect（保护）</code>和<code>private（私有）</code>，关于这些修饰符本身的异同这里不再赘述，我想说的是，这些修饰符存在必然有它存在的意义，一定要在实际工作中，使用它们。之前做java后端时，经常在公司的项目的历史代码中发现，很少使用<code>protect</code>和<code>private</code>对类内部的方法和变量做约束，可见当时的编写者并没有对类本身的职能有一个清晰的认识，又或者是随着时间一步步迭代出来的结果。</p>
<p>那么问题来了，一些静态语言有这些修饰符，但是像<code>javascript</code>这种鸭子类型语言怎么办呢？其实没有必要担心，最早开始学前端的时候，这个问题我就问过自己无数次，<code>javascript</code>虽然没有这些修饰符，但是我们可以通过别的方式来达到类似的效果，或者使用<code>typescript</code>。</p>
<p>除了在编程语言层面，在前端实际工作中，你可能会听到一个叫作<code>immutable</code>的概念，这个概念我认为也是里氏替换原则的一直延伸。因为当前的前端框架一般提倡的理念均是<code>f(state) =&gt; view</code>，即数据状态代表视图，而数据状态本身由于<code>javascript</code>动态语言的特性，很容易会在不经意间被修改，一旦存在这种修改，视图中便会产生一些意想不到的问题，因此<code>immutable</code>和<code>函数式</code>的概念才会在前段时间火起来。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>经过这五篇文章，我们来分别总结一下这五条基本原则以及它们带来的好处：</p>
<ul>
<li>单一职责原则：提高代码实现层的内聚度，降低实现单元彼此之间的耦合度</li>
<li>开闭原则：提高代码实现层的可扩展性，提高面临改变的可适应性，降低修改代码的冗余度</li>
<li>里氏替换原则：提高代码抽象层的可维护性，提高实现层代码与抽象层的一致性</li>
<li>接口隔离原则：提高代码抽象层的内聚度，降低代码实现层与抽象层的耦合度，降低代码实现层的冗余度</li>
<li>依赖倒置原则：降低代码实现层由依赖关系产生的耦合度，提高代码实现层的可测试性</li>
</ul>
<p>可以注意到我这里刻意使用了<code>降低/提高 + 实现层/抽象层 + 特性/程度（耦合度、内聚度、扩展性、冗余度、可维护性，可测试性）</code>这样的句式，之所以这么做是因为在软件工作中，我们理想中的软件应当具备的特点是, 高内聚、低耦合、可扩展、少冗余、可维护、易于测试，而这五个原则也按正确的方向，将我们的软件系统向我们理想中的标准推进。</p>
<p>为了便于对比，特别绘制了下面的表格，希望大家从真正意义上做到将这些原则牢记于心，并付诸于行。</p>
<table>
<thead>
<tr>
<th>原则</th>
<th>耦合度</th>
<th>内聚度</th>
<th>扩展性</th>
<th>冗余度</th>
<th>维护性</th>
<th>测试性</th>
<th>适应性</th>
<th>一致性</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一职责原则</td>
<td>-</td>
<td>+</td>
<td>o</td>
<td>o</td>
<td>+</td>
<td>+</td>
<td>o</td>
<td>o</td>
</tr>
<tr>
<td>开闭原则</td>
<td>o</td>
<td>o</td>
<td>+</td>
<td>-</td>
<td>+</td>
<td>o</td>
<td>+</td>
<td>o</td>
</tr>
<tr>
<td>里氏替换原则</td>
<td>-</td>
<td>o</td>
<td>o</td>
<td>o</td>
<td>+</td>
<td>o</td>
<td>o</td>
<td>+</td>
</tr>
<tr>
<td>接口隔离原则</td>
<td>-</td>
<td>+</td>
<td>o</td>
<td>-</td>
<td>o</td>
<td>o</td>
<td>+</td>
<td>o</td>
</tr>
<tr>
<td>依赖倒置原则</td>
<td>-</td>
<td>o</td>
<td>o</td>
<td>-</td>
<td>o</td>
<td>+</td>
<td>+</td>
<td>o</td>
</tr>
</tbody>
</table>
<p>Note: <code>+</code>代表增加, <code>-</code>代表降低, <code>o</code>代表持平</p>

      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/翻译/">翻译</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/principle/">principle</a>
    </span>
    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2018/02/08/SOLID-l/"><span>more</span></a></h3>
    
  
</article>





  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2018/02/08/SOLID-i/"><span>【译】Understanding SOLID Principles - Interface Segregation Principle</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/08/SOLID-i/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-08T01:40:33.000Z">
          2018-02-08
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
      
          <h1 id="Understanding-SOLID-Principles-Interface-Segregation-Principle"><a href="#Understanding-SOLID-Principles-Interface-Segregation-Principle" class="headerlink" title="Understanding SOLID Principles: Interface Segregation Principle"></a><a href="https://codeburst.io/understanding-solid-principles-interface-segregation-principle-b2d57026cf6c" target="_blank" rel="noopener">Understanding SOLID Principles: Interface Segregation Principle</a></h1><blockquote>
<p>这是理解<code>SOLID</code>原则，关于<strong>接口隔离</strong>原则如何帮助我们创建简单的抽象接口，并使客户端代与接口之间存在的更少的依赖关系。</p>
</blockquote>
<h2 id="接口隔离原则是什么"><a href="#接口隔离原则是什么" class="headerlink" title="接口隔离原则是什么"></a>接口隔离原则是什么</h2><blockquote>
<p>Clients should not be forced to depend on methods that they do not use.</p>
</blockquote>
<blockquote>
<p>客户端代码不应当被迫依赖于它们不需要的方法。</p>
</blockquote>
<p>这个原则本身与单一职责原则关系十分紧密，它意味着当你在定义你的抽象层代码时，不应当在客户端代码在实现抽象逻辑时，暴露一些客户端代码不需要使用或者关心的方法。</p>
<p>进一步说明的话，就是当你有意地在抽象层中暴露的方法时，这意味着所有实现这些抽象逻辑的客户端代码都必须要实现所有的抽象方法，尽管这些方法并不一定都对客户端代码有意义。</p>
<p>将你的接口的保持精简和小颗粒度，并且不要在它们中间增加无用的抽象方法，当你在对新的抽象接口进行命名时，你就会拥有更好的选择，因为你已有了若干小颗粒的命名类型。这样做的意义在于当你在需要提供一个更加大颗粒度的抽象接口时，你可以拥有足够的灵活性来将已有的小颗粒度接口进行组合。</p>
<h2 id="如何实践接口隔离原则"><a href="#如何实践接口隔离原则" class="headerlink" title="如何实践接口隔离原则"></a>如何实践接口隔离原则</h2><p>这个例子是关于一个ATM用户界面的抽象接口，这个接口会处理诸如存款请求、取款请求等逻辑，从这个例子中我们会了解到，我们如何对这个接口进行隔离，使其进一步划分为多个独立的、更加具体的若干接口。</p>
<p>首先我们应当有一个工具函数库接口，这个接口会描述我们想要暴露的关于<code>byte</code>操作逻辑的方法，让我们创建这样一个接口，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type ByteUtils interface &#123;</span><br><span class="line">    Read(b []byte) (n int, err error) // Read into buffer</span><br><span class="line">    Write(b []byte)(n int, err error) // Write into buffer</span><br><span class="line">    Trim(b []byte, exclusions string)[]byte // Trim buffer by removing bytes from the exclusion chars</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它可以正常工作一段时间，但是很快我们就会发现以下两个问题：</p>
<ul>
<li>它的命名<code>ByteUtils</code>太过于通用，如果我们仅通过命名本身，基本无法获取任何具体的信息</li>
<li>当使用它时，会有一些古怪的感觉，因为当你根据不同的优化场景来按不同逻辑实现<code>trim</code>方法时，你所实现的<code>read</code>和<code>write</code>几乎没什么差别，但是你却需要重复地实现它们，同时在某些不需要读或者写的场景，仍然需要实现它们。</li>
</ul>
<p>所以它虽然能够正常工作，但是却不够好。</p>
<p>我们可以通过创建三个更精简、更具体的接口来替代原先通用的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Reader interface &#123;</span><br><span class="line">    Read(b []byte) (n int, err error) </span><br><span class="line">&#125;</span><br><span class="line">type Writer interface &#123;</span><br><span class="line">    Write(b []byte)(n int, err error) </span><br><span class="line">&#125;</span><br><span class="line">type Trimmer interface &#123;</span><br><span class="line">    Trim(b []byte, exclusions string)[]byte </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种颗粒度比较细的接口也可以称为<strong>角色接口</strong>，因为它们更易于重构和改变，甚至对于已经定义好的角色和目的也可以很容易的进行重新部署和定义。</p>
<p>在这三个基础上，我们可以通过组合它们来获取一个更有关联性的接口列表，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type ReadWriter interface &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer </span><br><span class="line">&#125;</span><br><span class="line">type TrimReader interface &#123;</span><br><span class="line">    Trimmer</span><br><span class="line">    Reader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这意味客户端代码拥有了可以根据它们各自的需求来组合抽象层接口的灵活性，这样就会避免在实现抽象接口时不必要的麻烦（比如必须要实现某些无用的方法），比如上面的<code>TrimReader</code>的实现并未包含多余的<code>Write</code>方法的声明。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正如你所看到的，通用的接口往往会无意识的将自己和类的实现耦合在了一起，所以你应当尽量的避免这种情况的发生。在设计接口时，你应当时刻提醒自己，我是否需要使用所有在接口中声明的方法呢？如果不是的话，将接口细分为更多个更精简、更具体的接口。</p>
<p>正如甘地曾经说过：</p>
<blockquote>
<p>你的行动决定你的习惯，你的习惯决定你的价值，你的价值会决定你的命运。</p>
</blockquote>
<p>如果在架构中，你每次都会经过仔细思考，会按照好的模式来进行设计，它将会成为一种习惯，自然慢慢会转变为你的价值或者原则，最终则会成为你的命运，比如成为了一个始终给予完善解决方案的软件架构师。</p>
<p>我的观点是，始终通过挑战自己来变的更好，在某些时刻，你可能会遇到问题，但是往往你可能已经拥有了答案。</p>
<p>Happy coding!</p>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>对于接口隔离原则的理解，我一直觉的它本身其实是单一职责原则的一个扩展，但是它们之间也有细微的不同：</p>
<ul>
<li>单一职责原则往往面向实现层，比如具体的类或者某个方法</li>
<li>接口隔离原则往往面向抽象层，比如一些抽象类或者抽象方法</li>
</ul>
<p>所以将两个原则结合起来看的话，可以很容器得到当时提出这两个原则的人的意图，那就是一定要时刻<code>保持简单</code>。</p>
<p>在实际工作中，我深知<strong>保持简单</strong>是一件十分困难的事情，因为工程师本身的使命便是解决问题，而问题往往充满了未知性，而未知性往往代表着改变，这还没有考虑到在项目实施过程中，产品经理天马行空的设计思路，客户们五花八门的需求等等。在这些外界条件下，我们的代码往往会变得复杂无比，充满了各种反模式和冗余代码，最终会使自己陷入无尽的bug修复和维护工作中，怎么还会有时间进行自我提升呢？</p>
<p>所以，为了能够按时下班，为了能够及早回家，为了能够让我们的拥有更多的时间来提升自己和陪伴家人，在软件设计之初，尽可能地针对将来所面临的改变，在设计层面降低软件抽象模块间的耦合程度，在项目实施时，提高每个具体实现模块内部的内聚程度，同时使它们保持简单，这样便是一个好的开始。</p>

      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/翻译/">翻译</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/principle/">principle</a>
    </span>
    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2018/02/08/SOLID-i/"><span>more</span></a></h3>
    
  
</article>





  <article class="article-container ">

  
    
    <h3 class="article-title"><a href="/2018/02/04/SOLID-o/"><span>【译】Understanding SOLID Principles - Open Closed Principle</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/04/SOLID-o/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-04T01:34:48.000Z">
          2018-02-04
        </time>
      </a>
    </span>
    <br />
    
  </div>


  

  <div class="article-content">
    <div class="entry">
      
          <h1 id="Understanding-SOLID-Principles-Open-Closed-Principle"><a href="#Understanding-SOLID-Principles-Open-Closed-Principle" class="headerlink" title="Understanding SOLID Principles: Open Closed Principle"></a><a href="https://codeburst.io/understanding-solid-principles-open-closed-principle-e2b588b6491f" target="_blank" rel="noopener">Understanding SOLID Principles: Open Closed Principle</a></h1><blockquote>
<p>这是理解<code>SOLID</code>原则，介绍什么是<strong>开闭原则</strong>以及它为什么能够在对已有的软件系统或者模块提供新功能时，避免不必要的更改（重复劳动）。</p>
</blockquote>
<h2 id="开闭原则是什么"><a href="#开闭原则是什么" class="headerlink" title="开闭原则是什么"></a>开闭原则是什么</h2><blockquote>
<p>Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.</p>
</blockquote>
<blockquote>
<p>软件实体（类、模块、函数等）都应当对扩展具有开放性，但是对于修改具有封闭性。</p>
</blockquote>
<p>首先，我们假设在代码中，我们已经有了若干抽象层代码，比如类、模块、高阶函数，它们都仅做一件事（还记得单一职责原则吗？），并且都做的十分出色，所以我们想让它们始终处于简洁、高内聚并且好用的状态。</p>
<p>但是另一方面，我们还是会面临改变，这些改变包含范围（译者注：应当是指抽象模块的职责范围）的改变，新功能的增加请求还有新的业务逻辑需求。</p>
<p>所以对于上面我们所拥有的抽象层代码，在长期想让它处于一成不变的状态是不现实的，你不可避免的会针对以上的需要作出改变的需求，增加更多的功能，增加更多的逻辑和交互。在上一篇文章，我们知道，改变会使系统复杂，复杂会促使模块间的耦合性上升，所以我们迫切地需要寻找一种方法能够使我们的抽象模块不仅可以扩大它的职责范围，同时还能够保持当前良好的状态（简洁、高内聚、好用）。</p>
<p>这便是<strong>开闭原则</strong>存在的意义，它能够帮助我们完美地实现这一切。</p>
<h2 id="如何实践开闭原则"><a href="#如何实践开闭原则" class="headerlink" title="如何实践开闭原则"></a>如何实践开闭原则</h2><p>当你需要对已有代码作出一些修改时，请切记以下两点：</p>
<ul>
<li>保持函数、类、模块当前它们本身的状态，或者是近似于它们一般情况下的状态（即不可修改性）</li>
<li>使用组合的方式（避免使用继承方式）来扩展现有的类，函数或模块，以使它们可能以不同的名称来暴露新的特性或功能</li>
</ul>
<p>这里关于继承，我们特意增加了一个注释，在这种情况下使用继承可能会使模块之间耦合在一起，同时这种耦合是可避免的，我们通常在一些预先有着良好定义的结构上使用继承。（译者注：这里应该是指，对于我们预先设计好的功能，推荐使用继承方式，对于后续新增的变更需求，推荐使用组合方式）</p>
<p>举个例子（译者注：我对这里的例子做了一些修改，原文中并没有详细的说明）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface IRunner &#123;</span><br><span class="line">  run: () =&gt; void;</span><br><span class="line">&#125;</span><br><span class="line">class Runner implements IRunner &#123;</span><br><span class="line">  run(): void &#123;</span><br><span class="line">    console.log(&quot;9.78s&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IJumper &#123;</span><br><span class="line">  jump: () =&gt; void;</span><br><span class="line">&#125;</span><br><span class="line">class Jumper implements IJumper &#123;</span><br><span class="line">  jump(): void &#123;</span><br><span class="line">    console.log(&quot;8.95,&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例子中，我们首先声明了一个<code>IRunner</code>接口，之后又声明了<code>IJumper</code>，并分别实现了它们，并且实现类的职能都是单一的。</p>
<p>假如现在我们需要提供一个既会跑又会跳的对象，如果我们使用继承的方式，可以这么写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class RunnerAndJumper extends Runner &#123;</span><br><span class="line">  jump: () =&gt; void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class RunnerAndJumper extends Jumper &#123;</span><br><span class="line">  run: () =&gt; void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是使用继承的方式会使这个<code>RunnerAndJumper</code>与<code>Runner</code>（或者<code>Jumper</code>）耦合在一起（耦合在一起的原因是因为它的职责不再单一），我们再来用组合的方式试试看，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class RunnerAndJumper &#123;</span><br><span class="line">  private runnerClass: IRunner;</span><br><span class="line">  private jumperClass: IJumper;</span><br><span class="line">  constructor(runner: IRunner, jumper: IJumper) &#123;</span><br><span class="line">    this.runnerClass = new runner();</span><br><span class="line">    this.jumperClass = new jumper();</span><br><span class="line">  &#125;</span><br><span class="line">  run() &#123;</span><br><span class="line">    this.runnerClass.run();</span><br><span class="line">  &#125;</span><br><span class="line">  jump() &#123;</span><br><span class="line">    this.jumperClass.jump();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在<code>RunnerAndJumper</code>的构造函数中声明两个依赖，一个是<code>IRunner</code>类型，一个是<code>IJumper</code>类型。</p>
<p>最终的代码其实和<strong>依赖倒置原则</strong>中的例子很像，而且你会发现，<code>RunnerAndJumper</code>类本身并没有与任何别的类耦合在一起，它的职能同样是单一的，它是对一个即会跑又会跳的实体的抽象，并且这里我们还可以使用<code>DI（依赖注入）</code>技术进一步的优化我们的代码，降低它的耦合度。</p>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p><strong>开闭原则</strong>所带来最有用的好处就是，当我们在实现我们的抽象层代码时，我们就可以对未来可能需要作出改变的地方拥有一个比较完整的设想，这样当我们真正面临改变时，我们所对原有代码的修改，更贴近于改变本身，而不是一味的修改我们已有的抽象代码。</p>
<p>在这种情况下，由于我们节省了不必要的劳动和时间，我们就可以将更多的精力投入到关于更加长远的事宜计划上面，而且可以针对这些事宜需要作出的改变，提前和团队沟通，最终给予一套更加健壮、更符合系统模块本身的解决方案。</p>
<p>在整个软件开发周期中（比如一个敏捷开发周期），你对于整个周期中的事情了解的越透彻、越多，则越好。身为一个工程师，在一个开发冲刺中，为了在冲刺截止日期结束前，实现一个高效的、可靠的系统，你不会期望作出太多的改变，因此往往你可能会“偷工减料”。</p>
<p>从另一个角度来讲，我们也应当致力于在每一次面临需求变更的情况下，不需要一而再，再而三的更改我们已有的代码。所有新的功能都应当通过增加一个新的组合类或方法实现，或者通过复用已有的代码来实现。</p>
<h2 id="插件与中间件"><a href="#插件与中间件" class="headerlink" title="插件与中间件"></a>插件与中间件</h2><p>充分贯彻开闭原则的另一个例子，便是<strong>插件与中间件</strong>架构，我们可以从三个角度来简单分析这种架构是如何运作的：</p>
<ul>
<li>内核或者容器：往往是核心功能的实现的前提，一般会成为整个系统最核心的部分</li>
<li>插件：在实现容器的基础上，往往一些核心功能都是以内置的插件实现的，并且，通过实现一套通用的网关类接口，我们可以使插件具有可插拔性，这样在需要新增特性和功能时，只需要实现新的插件并添加到容器即可，比如支持插件扩展功能的浏览器<code>Chrome</code>。</li>
<li>中间件：中间件我们可以通过一个例子来说明，比如我们拥有一个请求 - 响应周期，我们可以通过中间件，在周期中添加中间业务逻辑，以便为应用程序提供额外的服务或横切关注点，比如<code>Redux</code>、<code>express</code>还有很多框架都支持这样的功能。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望这篇文章能够帮助你学会如何应用<strong>开闭原则</strong>并且从中收益。设计一个具有可组合性的系统，同时提供具有良好定义的扩展接口，是一种非常有用的技术，这种技术最关键的地方在于，它使我们的系统能够在保持强健的同时，提供新功能、新特性，但是却不会影响它当前的状态。</p>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>开闭原则是面向对象编程中最重要的原则之一，有多重要呢？这么说吧，很多的设计原则和设计模式所希望达成的最终状态，往往符合开闭原则，因此需要原则也都作为实现开闭原则的一种手段，在原文的例子中，我们可以很明显的体会到，在实现开闭原则所提倡的理念的过程中，我们不经意地使用之前两篇文章中涉及的原则，比如：</p>
<ul>
<li>保持对象的单一性（单一职责）</li>
<li>实现依赖于抽象（依赖倒置原则）</li>
</ul>
<p>我之前一直是做后端相关工作的，所以对于开闭原则接触较早，这两年转行做了前端，随着<code>nodejs</code>的发展，框架技术日新月异，但是其中脱颖而出的优秀框架往往是充分贯彻了开闭原则，比如<code>express</code>、<code>webpack</code>还有状态管理容器<code>redux</code>，它们均是开闭原则的最佳实践。</p>
<p>另外一方面，在这两年的工作也感受到，适当的使用函数式编程的思想，往往是贯彻开闭原则一个比较好的开始，因为函数式的编程中的核心概念之一便是<code>compose（组合）</code>。以函数式描述业务往往是原子级的指令，之后在需要描述更复杂的业务时，我们复用并组合之前已经存在的指令以达到目的，这恰恰符合开闭原则所提倡的可组合性。</p>
<p>最后在分享一些前端中，经常需要使用开闭原则的最佳业务场景，</p>
<ul>
<li>UI组件的表单组件：对于表单本身以容器来实现，表单项以插件来实现，这样对于表单项如何渲染、如何加载、如何布局等功能，均会封闭与表单容器中，而对于表单项如何校验、如何取值、如何格式化等功能，则会开放与表单项容器中。</li>
<li>API服务：一般我们可能会在项目中提供自定义修改请求头部的工具方法，并在需要的时候调用。但这其实是一种比较笨的方法，如果可能的话，建议使用拦截器来完成这项任务，不仅会提供代码的可读性，同时还会使发接口的业务层代码保持封闭。</li>
<li>事件驱动模型：对于一些复杂的事件驱动模型，比如拖拽，往往使用开闭原则会达到意想不到的效果。最近有一个比较火的拖拽库<a href="https://github.com/Shopify/draggable" target="_blank" rel="noopener">draggable</a>，提供的拖拽体验相比其他同类型的库简直不是一个级别。我前段时间去读它的源码，发现它之所以强大，是因为在它内部，针对多种拖拽事件，封装了独立的事件发射器（其内部称作<code>Sensor</code>），之后根据这些发射器指定了一套独立的抽象事件驱动模型，在这个模型基础上，针对不同的业务场景提供不同的插件，比如：<ul>
<li>原生拖拽(Draggable)</li>
<li>拖拽排序(Sortable)</li>
<li>拖拽放置(Droppable)</li>
<li>拖拽交换(Swappable)</li>
</ul>
</li>
</ul>
<p>还有若干提高用户体验的其他插件，这一切均是以开闭原则而实现的。</p>

      
    </div>
    
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/翻译/">翻译</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/principle/">principle</a>
    </span>
    

    </div>

    
  </div>
  
    
    <h3 class="article-read"><a href="/2018/02/04/SOLID-o/"><span>more</span></a></h3>
    
  
</article>






<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">Next</a>
  
</nav>
                </main>
                <div class="sidebar
                    col-lg-3 col-lg-offset-0
                    col-md-3 col-md-offset-0
                    col-sm-12
                    col-xs-12
                    sidebar-container
                ">

                  <div class="sidebar-container">



<div class="search-container">
<form class="site-search-form">
    <span class="glyphicon glyphicon-search"></span><input type="text" id="local-search-input" class="st-search-input" placeholder="Search..." />
</form>
<div id="local-search-result" class="local-search-result-cls"></div>
</div>
<script type="text/javascript" id="local.search.active">
var inputArea       = document.querySelector("#local-search-input");
inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script>




    <div class="categories-container" style="margin-top:40px;">
        <p>归档:</p>
            
                <a href="/categories/原创/" title="原创" rel="7">原创</a>
            
                <a href="/categories/心情/" title="心情" rel="4">心情</a>
            
                <a href="/categories/源码分析/" title="源码分析" rel="1">源码分析</a>
            
                <a href="/categories/翻译/" title="翻译" rel="15">翻译</a>
            
    </div>




    <div class="social-container" style="margin-top:40px;">
        <p>Links:</p>
            
                
                    <li class="social-item"><i class="fa fa-fw fa-github"></i><a href="https://github.com/haoliangwu">GitHub</a></li>
                
            
                
                    <li class="social-item"><i class=" fa fa-fw zhihu-icon"></i><a href="https://www.zhihu.com/people/wu-hao-liang-81/activities">知乎</a></li>
                
            
                
                    <li class="social-item"><i class="fa fa-fw fa-sf"></i><a href="https://segmentfault.com/u/littlelyon">SegmentFault</a></li>
                
            
    </div>

</div>
                </div>
              </div>
            </div>
            





                <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/BosenY/Lap" target="_blank">Lap</a>
    <br/><span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>
    </br>
    
      
        &copy; 2018 Lyon Wu
      
    
  </p>
</footer>
                  
      </div>

    </div>
    <script>
      window.onload = function () {
        document.querySelector('.loading').remove()
      }
    </script>
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <script src="https://cdn.bootcss.com/vue/2.5.13/vue.min.js"></script>
    <script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
    <script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
      crossorigin="anonymous"></script>
    <script src="/js/index.js"></script>
    <script src="/js/search.js"></script>

  <script>'use strict';'serviceWorker'in navigator&&navigator.serviceWorker.register('service-worker.js').then(function(a){a.onupdatefound=function(){var b=a.installing;b.onstatechange=function(){switch(b.state){case'installed':navigator.serviceWorker.controller?console.log('New or updated content is available.'):console.log('Content is now available offline!');break;case'redundant':console.error('The installing service worker became redundant.');}}}}).catch(function(a){console.error('Error during service worker registration:',a)});
</script></body></html>